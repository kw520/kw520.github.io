<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		leetcode做题笔记 | 
	 
	BIGKEL BLOB
	</title>
	
	<!-- keywords,description -->
	
	

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/bigkel.png">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "kw520.github.io";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>


	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.5.1/dist/Valine.min.js"></script>

	
	

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="BIGKEL BLOB" type="application/atom+xml">
</head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">BIGKEL BLOB</a>

	<ul id="menu">
    

    

    

    
  
    
      <li class="menu-item">
        <a href='https://github.com/kw520' class="menu-item-link" target="_blank">
          <i class="fa fa-github fa-2x"></i>
        </a>
      </li>
    
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="Press Enter to search">
		<div id="tree">
			

			
							<ul>
								<li class="file active">
									<a href="/2023/09/05/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/">
                     
										    leetcode做题笔记
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/18/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">
                     
										    面试总结
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content" class="content">
		<h1 id="article-title">
	leetcode做题笔记
</h1>

<!-- meta -->
<div class="article-meta">
	

	<span>jiakuan.chen</span>
	<span>2023-09-05 18:56:11</span>

  <div id="article-categories">
    
		  <span>Categories：</span>
      
    

    
		    <span>Tags：</span>
        
    
  </div>

</div>

<!-- content -->
<div id="article-content">
	<h1 id="一、合并两个有序数组"><a href="#一、合并两个有序数组" class="headerlink" title="一、合并两个有序数组"></a>一、<strong>合并两个有序数组</strong></h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/clipboard.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>从原始nums1和nums2的末尾开始比较，不比nums2小的数往nums1的后面放，若一方遍历完，则另一方继续遍历直到结束。</strong></font></p>
<p>三个指针，分别为	 int one &#x3D; m - 1;</p>
<p>​    	    						int two &#x3D; n - 1;</p>
<p>​    	    						int tail &#x3D; m + n - 1;</p>
<p>若one &#x3D;&#x3D; -1，则nums1[tail] &#x3D; nums2[two]，且two–，tail–；</p>
<p>反之若two &#x3D;&#x3D; -1，则nums1[tail] &#x3D; nums1[one]，且one–，tail–；</p>
<p>反之若nums1[one] &gt;&#x3D; nums2[two]，则nums1[tail] &#x3D; nums1[one]，且one–，tail–；</p>
<p>反之，则nums1[tail] &#x3D;  nums2[two]，且two–，tail–；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(one &gt; -<span class="number">1</span> || two &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(one == -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums2[two];</span><br><span class="line">            two --;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(two == -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums1[one];</span><br><span class="line">            one --;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[one] &gt;= nums2[two]) &#123;</span><br><span class="line">            cur = nums1[one];</span><br><span class="line">            one --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[two];</span><br><span class="line">            two --;</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail] = cur;</span><br><span class="line">        tail --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二、移除元素"><a href="#二、移除元素" class="headerlink" title="二、移除元素"></a><strong>二、移除元素</strong></h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/remove.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p>​		<strong>方法一、双指针，都从头开始，R指针若不等于val，则赋值给L后，L和R同时右移，若等于，则L不动，R右移寻找不等于val的值赋值给L</strong></p>
<p>​		<font color=blue>**方法二、双指针，L指向头，R指向尾，L &lt; R，若L指针不等于val，则右移，若等于val，则R指针值赋值给L指针，R指针左移，一直循环。**</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、删除有序数组中的重复项"><a href="#三、删除有序数组中的重复项" class="headerlink" title="三、删除有序数组中的重复项"></a>三、删除有序数组中的重复项</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230905200311.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针p指向第一个数，指针q指向第二个数，如果两个值相等，则q++。如果不相等，当q - p &gt; 1时（避免0，1，2，3，4这种极端情况，表示当p和q不相邻时，才用调换值，避免自己和自己调换），调换q和p+1的值，且p++， q++。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[q] != nums[p]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q - p &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                nums[p + <span class="number">1</span>] = nums[q];</span><br><span class="line">            &#125;</span><br><span class="line">            p ++;</span><br><span class="line">        &#125;</span><br><span class="line">        q ++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四、有序数组中只能重复两次"><a href="#四、有序数组中只能重复两次" class="headerlink" title="*四、有序数组中只能重复两次"></a>*四、有序数组中只能重复两次</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906181755.png"></p>
<p><font color=red><strong>思路：</strong></font><strong>指针slow、fast都指向下标为2的位置</strong></p>
<p>​		<font color=blue><strong>若fast &#x3D;&#x3D; slow[n-2]，由于slow[n]之前已经是整理好后的，并且数组有序，那么slow[n-1]不可能比slow[n-2]小，也不可能比fast大，所以此时必然有fast &#x3D;&#x3D; slow[n-2] &#x3D;&#x3D; slow[n-1]，则需要fast右移找到不等于slow[n-2]的值赋值给slow[n]（若fast找到的值和slow当前值相等，则可以不用赋值），然后slow和fast同时右移。</strong></font></p>
<p>​		<font color=blue>**若fast !&#x3D; slow[n-2]，则说明slow[n]之前排好序的slow[n-2] &lt; slow[n-1]，那么此时fast的值可以给slow[n]**</font></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906190249.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != nums[slow -<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            slow ++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、多数元素"><a href="#五、多数元素" class="headerlink" title="五、多数元素"></a>五、多数元素</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906203706.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p>​		<strong>方法一、排序，多数元素一定占据n&#x2F;2的位置。</strong></p>
<p>​		<font color=blue><strong>方法二、排序，p、q指针从0开始，若q &#x3D;&#x3D; p，则q向右遍历，若q !&#x3D; p，则q-1-p+1为当前数的个数，若此个数大于n&#x2F;2，则返回nums[p]，反之则p &#x3D; q，继续向后遍历，直到q &gt;&#x3D; n为止</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[p] == nums[q]) &#123;</span><br><span class="line">            q ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(q - p &gt; more)&#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六、轮转数组"><a href="#六、轮转数组" class="headerlink" title="*六、轮转数组"></a>*六、轮转数组</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230907184201.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>实际轮转次数 k &#x3D; k – 整数*n，比如n &#x3D; 5，轮转6次，那么实际次数为1，n &#x3D; 5，轮转2次，实际次数为2。将nums全部反转，然后根据实际轮转次数分割，[0, k - 1] 和 [k, n - 1]再各自反转。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    swap(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    swap(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    swap(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        nums[start] = nums[start] ^ nums[end];</span><br><span class="line">        nums[end] = nums[start] ^ nums[end];</span><br><span class="line">        nums[start] = nums[start] ^ nums[end];</span><br><span class="line">        start ++;</span><br><span class="line">        end --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七、买卖股票最佳时机"><a href="#七、买卖股票最佳时机" class="headerlink" title="七、买卖股票最佳时机"></a>七、买卖股票最佳时机</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230907203725.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针p和q分别指向0和1，记录最大利润max &#x3D; 0，q向后移动，若 q - p &lt; 0，则后面的数字在和q求差时一定比和p求差时大，说明 q 点买进的利润一定大于当前 p 点买进的利润，所以 p 点重新定位，p &#x3D; q。若 q - p &gt; 0，则判断利润是否比之前的利润 max 大，大则覆盖。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; prices.length) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> prices[q] - prices[p];</span><br><span class="line">        <span class="keyword">if</span>(money &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = money &gt; max ? money : max;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        q ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八、买卖股票最佳时机2"><a href="#八、买卖股票最佳时机2" class="headerlink" title="*八、买卖股票最佳时机2"></a>*八、买卖股票最佳时机2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909101503.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p><font color=red><strong>方法一：</strong></font><strong>动态规划</strong>    <font color=blue><strong>时间复杂度O(n)，空间复杂度O(n)</strong></font></p>
<p>​		每天手里股票的状态有两种，<code>dp[i,0]</code>表示第 <code>i</code> 天未持有股票，<code>dp[i,1]</code>表示第 <code>i</code> 天持有股票。</p>
<p>​		<code>dp[i,0]</code>的时候，可以看作是 <code>i-1</code> 天已经卖出了股票，<code>i</code> 天还没有买进，即<code>dp[i-1,0]</code>。或者是 <code>i-1</code> 天买进了股票，<code>i</code> 天卖出，即<code>dp[i-1,1] + price[i]</code>。所以 <code>i</code> 天最大的利润可以可以列出如下转换方程：</p>
<p><strong>dp[i,0] &#x3D; max{dp[i-1,0], dp[i-1,1]+price[i]}</strong></p>
<p>​		<code>dp[i,1]</code>的时候，可以看作是 <code>i-1</code> 天买入了股票，<code>i</code> 天还没有卖出，即<code>dp[i-1,1]</code>。或者是 <code>i-1</code> 天卖出了股票，<code>i</code> 天买入，即<code>dp[i-1,0] - price[i]</code>。所以 <code>i</code> 天最大的利润可以列出如下转换方程：</p>
<p><strong>dp[i,1] &#x3D; max{dp[i-1,1], dp[i-1,0]-price[i]}</strong></p>
<p>​		到最后一天的时候，卖出股票肯定要比买入股票利润高，所以只用返回<code>dp[n,0]</code>即可。(空间优化) 由于当天的最大利润只与前一天有关，并且每天只有0、1两种状态，那么可以只用<code>dp0</code>表示当天未持有股票状态，<code>dp1</code>表示当天持有股票状态，每过一天用最新值覆盖<code>dp0、dp1</code>即可。那么到了最后一天的最大利润可以用<code>dp0</code>表示即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp0 = Math.max(dp0, dp1+prices[i]);</span><br><span class="line">        dp1 = Math.max(dp1, dp0-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p><font color=red><strong>方法二：</strong></font><strong>贪心算法</strong>    <font color=blue><strong>时间复杂度O(n)，空间复杂度O(1)</strong></font></p>
<p>​		买入股票的最大利润，其实就是每相邻两天利润差大于0的和。比如1，4，3，12这一组数，我们只要避开两个产生负数的数，即可保证利润最大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max += Math.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="九、跳跃游戏"><a href="#九、跳跃游戏" class="headerlink" title="*九、跳跃游戏"></a>*九、跳跃游戏</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909143444.png"></p>
<p><font color=red><strong>思路：</strong></font><strong>贪心算法</strong>   <font color=blue><strong>时间复杂度O(n)，空间复杂度O(1)。</strong></font></p>
<p>​		存在可到达的最大的位置maxend，判断当前位置是否小于maxend。</p>
<p>​		若小于，则说明存在步数可以到达此位置</p>
<p>​					判断此位置可跳跃到的位置是否大于maxend。</p>
<p>​					若大于，则更新maxend，反之继续遍历。</p>
<p>​		若大于，则说明当前位置不存在步数可以到达，直接返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxend</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; maxend) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxend = Math.max(maxend, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十、跳跃游戏2"><a href="#十、跳跃游戏2" class="headerlink" title="*十、跳跃游戏2"></a>*十、跳跃游戏2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909165449.png"></p>
<p><strong><font color=red>思路：</font>贪心算法   <font color=blue>时间复杂度O(n)，空间复杂度O(1)。</font></strong></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909170300.png">		</p>
<p>​		从<code>下标0</code>开始遍历，其能够走到的最远的距离是走到<code>下标2</code>，此时记录<code>max = 2，end = 2，step = 1</code>。遍历到<code>下标1</code>的时候，发现<code>下标1</code>最大能走到<code>下标4</code>，此时更新<code>max = 4</code>，但是不能更新<code>end</code>，因为上一步的<code>end</code>还没走完，需要走完上一步的<code>end</code>之后，才能确定下一步需要走到哪里。遍历到<code>下标2</code>的时候，发现<code>下标2</code>最大只能走到<code>下标3</code>，小于<code>max</code>，此时<code>end</code>已经走完，确定了<code>max = 4</code>，重新设置<code>end = 4</code>，<code>step ++</code>。此处就可以确定是使用<code>下标1</code>的时候，这步能够走到最远为<code>下标4</code>。依次遍历，由于我们当前代码设定<code>step</code>的自增是在起点时自增，而不是走完后自增，所以为了避免最后一步刚好是在数组的最后一个数时，导致程序又把最后一个数当成是起点，所以这里让数组的界限设置为<code>nums.length - 1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        max = Math.max(nums[i] + i, max);   <span class="comment">// 持续更新跳跃的最大点，结算时确定下次要跳的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i == end) &#123;   <span class="comment">// 已经遍历到了上一次起跳的最大位置的终点（结算）</span></span><br><span class="line">            end = max;   <span class="comment">// 设置下次需要跳到的位置的终点</span></span><br><span class="line">            step ++;     <span class="comment">// 跳动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十一、O-1-插入、删除、随机获取"><a href="#十一、O-1-插入、删除、随机获取" class="headerlink" title="*十一、O(1)插入、删除、随机获取"></a>*十一、O(1)插入、删除、随机获取</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230911152620.png"></p>
<p><font color=red><strong>思路</strong></font>：<font color=blue><strong>变长数组可以在 O(1) 的时间内完成获取随机元素操作，但是由于无法在 O(1) 的时间内判断元素是否存在，因此不能在 O(1) 的时间内完成插入和删除操作。哈希表可以在 O(1) 的时间内完成插入和删除操作，但是由于无法根据下标定位到特定元素，因此不能在 O(1) 的时间内完成获取随机元素操作。为了满足插入、删除和获取随机元素操作的时间复杂度都是 O(1)，需要将变长数组和哈希表结合，变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标。所以使用变长数组 + 哈希表</strong></font></p>
<p>操作插入时，首先判断<code>val</code>是否存在哈希表中，如果存在，则返回<code>false</code>，如果不存在，则插入<code>val</code>。操作如下：</p>
<p>​		1、在变长数组末尾加入<code>val</code></p>
<p>​		2、将加入后的<code>(val, index)</code>放入哈希表，返回<code>true</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.add(val);</span><br><span class="line">    map.put(val, nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作删除时，首先判断<code>val</code>是否存在哈希表中，如果不存在，则返回<code>false</code>，如果存在，则操作如下：</p>
<p>​		1、在哈希表中，获取要删除的值<code>val</code>的下标<code>index</code>。</p>
<p>​		2、将变长数组中的最后一个数<code>end</code>，放入下标为<code>index</code>中，并将这个数的<code>(end, index)</code>在哈希表中更新。</p>
<p>​		2、删除变长数组中的最后一个数<code>end</code>，删除哈希表中<code>key</code>为<code>val</code>的键值对。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.containsKey(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(val);   </span><br><span class="line">    nums.set(index, end);</span><br><span class="line">    map.put(end, index);</span><br><span class="line">    nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">    map.remove(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十二、除自身以外数组的乘积"><a href="#十二、除自身以外数组的乘积" class="headerlink" title="*十二、除自身以外数组的乘积"></a>*十二、除自身以外数组的乘积</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230912162504.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将当前数组每个节点的左侧乘积和右侧乘积单独算出来，然后一一对应相乘。下标0的左侧乘积为 1，下标n的右侧乘积为 1</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        answer[i] = answer[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];      <span class="comment">// 首先存放每个节点的左侧乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        answer[j] = answer[j] * R;</span><br><span class="line">        R = R * nums[j];                              <span class="comment">// 下一个节点的右侧乘积 = 当前节点 * 当前节点右侧乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十三、加油站"><a href="#十三、加油站" class="headerlink" title="*十三、加油站"></a>*十三、加油站</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230913185934.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue> <strong>无论从哪个点开始，只要总油量大于总耗油量（即剩余油量大于 0），就肯定可以跑完一圈，所以使用sum记录剩余油量，如果从当前点出发的总剩余油量（sum）小于上一步到达当前点的总剩余油量（sum），则从当前点出发无法到达下一步，则存储下一步的坐标表示当前点无法作为起点，下一步作为起点。依次循环，直到遍历结束</strong></font></p>
<p><code>sum</code>记录着每一步的剩余油量的总和，即使走到<code>下标4</code>，需要去判断其是否能走一圈，也需要用到前面三个点的剩余油量，<code>sum</code>又有记录，所以可以直接将<code>下标4</code>的剩余油量和<code>sum</code>相加。</p>
<p>例如：若<code>下标3</code>能够到达<code>下标4</code>，那么<code>for</code>中的<code>if</code>不会进入，<code>idx</code>还是保留着（从<code>下标2</code>开始走时，无法走到<code>下标3</code>，<code>idx</code>始终保留无法到达下一步坐标的当前点的下一步的坐标，这样才能确定是从哪一步开始可以到达下一步从而绕一圈的）<code>下标3</code>。如果当前剩余油量+之前剩余总油量（sum）小于0，则说明，无法绕一圈。反之，则可以绕一圈，且起点为<code>idx</code>（即使下标1无法到达下标2，下标2无法到达下标3，但是下标3可以到达下标4，且到达之后的剩余油量可以弥补之前的空缺，那么就可绕一圈，且起点为下标3）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(gas == <span class="literal">null</span> || cost == <span class="literal">null</span> || gas.length == <span class="number">0</span> || cost.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">        sum += gas[i] - cost[i];       <span class="comment">// 总的剩余油量</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; min) &#123;                <span class="comment">// 判断当前总剩余油量和上一次总剩余油量的大小，若小于，则说明当前点不能到达下一点</span></span><br><span class="line">            min = sum;                 <span class="comment">// 更新总的剩余油量</span></span><br><span class="line">            idx = i + <span class="number">1</span>;			   <span class="comment">// 保存当前点的下一点为idx，若循环不再进来，则说明可以从idx出发到达下一步</span></span><br><span class="line">        &#125;							   <span class="comment">// 当前循环进if，说明无法到达下一步，又能够到达下一步的不会进来，所以idx使用i+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &lt; <span class="number">0</span> ? -<span class="number">1</span> : idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十四、分发糖果"><a href="#十四、分发糖果" class="headerlink" title="**十四、分发糖果"></a>**十四、分发糖果</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230914200424.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p><strong>情况1：先升序，后降序。</strong>此时第一个人肯定会有一颗糖，记录pre &#x3D; 1，在升序部分，后面每一步都作pre +&#x3D; 1，记录升序的数量inc（到达最高点时，也会将最高点算到inc中，但是降序时，最高点也要算到降序部分，但是降序部分没法从最高点开始算起，只能遍历到最高点的后一个点时，才会知晓数组开始降序，所以降序会有特殊处理，后面会用降序的数量和其比较）。开始降序时，使用dec表示降序的数量（如果前一个值是最高点，后一个值开始降序，那么dec只是从后一个值开始算起降序的数量，其实最高点也要算是降序的一部分，当dec和inc相等时，说明降序部分肯定超过升序部分了，所以dec要加上1才能当作总的降序部分，如 1 2 3 4 3 2 1 0。升序部分是 1 2 3 4 inc &#x3D; 4，降序部分是 4 3 2 1 0，但是只有遍历到3时才知道降序开始，dec是从3开始算起 dec &#x3D; 4，但是实际是5，所以当dec &#x3D;&#x3D; inc时，dec需要累加），也可以看作是降序部分，总的应发的糖果数（因为降序是从高点往下，但是dec是从0开始的，所以无法满足dec的每一次累加的值，是降序每个小孩的应发的糖果，只能算是应发的总糖果）。如果dec &#x3D;&#x3D; inc时，降序部分超过了升序部分，dec应当累加。</p>
<p><strong>情况2：先降序，后升序。</strong>开始降序时，无法知晓后一步是否变成升序操作，所以降序的每一步都需要将pre重新置为1，若后一步变成升序，那么后一步的pre就是2，升序部分便可以看作是从这一步开始的。</p>
<p><strong>情况3：先升序，平序，后降序。</strong>由于平序部分没有大小关系，所以从第二个平序数开始，pre可以用最小的数1即可，并且升序数量inc也可以看作是1，然后再按照降序部分的操作计算dec的值即可，如 5 5 3，此时inc为1，dec最开始为1，刚好和inc相等，那么dec需要累加1，因为实际dec是2。</p>
<p><strong>情况4：先降序，平序，后升序。</strong>由于开始降序时，是从1开始计算的，所以降序的最低点就可以看作是1（只不过倒序了而已），平序部分只用给最小数1即可，即pre &#x3D; 1，然后再按照升序的逻辑计算，最后一个平序数当然就可以看作是升序数的起点。</p>
<p><strong>汇总：</strong>整合这4种情况，若数组只有一个数，则只需要返回1，若有两个数，则可以看作是以上四种情况的任何一种情况。使用ret  &#x3D; 1作为结果的初始值，从数组的第二个开始遍历，升序、平序时，ret &#x3D; ret + pre，降序时，ret &#x3D; ret + dec，最后返回ret即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">1</span>, dec = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt;= ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            dec = <span class="number">0</span>;</span><br><span class="line">            pre = ratings[i] == ratings[i - <span class="number">1</span>] ? <span class="number">1</span> : pre + <span class="number">1</span>;</span><br><span class="line">            ret += pre;</span><br><span class="line">            inc = pre;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dec++;</span><br><span class="line">            <span class="keyword">if</span> (dec == inc) &#123;</span><br><span class="line">                dec++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += dec;</span><br><span class="line">            pre = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十五、接雨水"><a href="#十五、接雨水" class="headerlink" title="**十五、接雨水"></a>**十五、接雨水</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230916145358.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p><strong>方法一：动态规划</strong>       <font color=blue><strong>时间复杂度O(n)    空间复杂度O(n)</strong></font></p>
<p>对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。</p>
<p>开始遍历，每到一步都可以得到当前点和最大值的数值差，此时可以看作该点能够接雨水的量。但是当达到最高点后，后面的点肯定相对于最高点来说是降序，因此这些点和最高点之间的差不能当成该点能够接雨水的量。所以我们既要从左往右遍历，也要从右往左遍历，这样，我们就可以得到最高点左侧的准确的接雨水量和最高点右侧的准确的接雨水量。</p>
<p>此时我们既可以根据最高点区分左右侧，然后相加可得到总的能够接雨水量，也可以根据左右分别遍历得到的接雨水量的交集来确定总的接雨水量。</p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] leftMax = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>; left &lt; n; left ++) &#123;</span><br><span class="line">        leftMax[left] = Math.max(leftMax[left - <span class="number">1</span>], height[left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] rightMax = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">2</span>; right &gt;= <span class="number">0</span>; right --) &#123;</span><br><span class="line">        rightMax[right] = Math.max(rightMax[right + <span class="number">1</span>], height[right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        res += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：双指针</strong>           <font color=blue><strong>时间复杂度O(n)    空间复杂度O(1)</strong></font></p>
<p>对于方法一中的左右两边分别遍历，得到总的接雨水量，这样会出现达到最高点之后，后面的操作都是浪费资源的，根本就不用去计算。此时可以优化成双指针，左右两个指针移动时，也记录移动过程中，分别得到的最大值（因为左边指针移动时，只能去根据右边的最大值去比对当前点能否接雨水，比如leftMax &#x3D; 2，rightMax &#x3D; 3，cur &#x3D; 1，此时就可以看作是cur可以接雨水。若rightMax &#x3D; 1，那么cur无法接雨水）左右两个指针总有一个会先走到最高点，走到最高点的指针停止不动，另外一个指针按照当前指针算出来的最大值减去当前点，得到当前点能够接的雨水量。直到两个指针会和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">        rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; rightMax) &#123;           <span class="comment">// 此时左边的指针将rightMax当成最高点</span></span><br><span class="line">            res += leftMax - height[left];</span><br><span class="line">            left ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 此时右边的指针将leftMax当成最高点</span></span><br><span class="line">            res += rightMax - height[right];</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：单调栈</strong>                   <font color=blue><strong>时间复杂度O(n)    空间复杂度O(n)</strong></font></p>
<p>维护一个单调递减栈，里面存储的是下标，满足从栈底到栈顶下标所对应的值单调递减。</p>
<p>栈顶元素为top，第二个元素为left。当height[i] &gt; height[top]，就说明top可以接雨水，该区域的宽度为 i - left - 1，高度为top下一个栈left的值和当前点 i 的值之间的最小值与top点值的差，即min(height[left], height[i]) − height[top]。</p>
<p>为了得到left，top需要出栈，top计算完所接雨水后，left变成新的top，然后 i 继续和此top比较，重复上一步操作。直到栈空或者 i 对应的值小于等于top的值。（为什么是小于等于呢，因为栈是单调递减的，小于等于就可以直接入栈，只有大于才用和栈中数据去比对）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> Math.min(height[i], height[left]) - height[top];</span><br><span class="line">            res += width * high;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十六、罗马数字转整数"><a href="#十六、罗马数字转整数" class="headerlink" title="十六、罗马数字转整数"></a>十六、罗马数字转整数</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230916163252.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>XIV &#x3D; X - I + V &#x3D; 10 - 1 + 5 &#x3D; 14</strong></font></p>
<p>将罗马字符和数字用map映射起来，如果当前的罗马字符对应的数字比下一个罗马字符对应的数字小，则说明要做减法，反之做加法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; map.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">            res -= value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十七、整数转罗马数字"><a href="#十七、整数转罗马数字" class="headerlink" title="*十七、整数转罗马数字"></a>*十七、整数转罗马数字</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230917131917.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>计算出每个数字在每个位上的表示形式，整理成一张硬编码表</strong></font></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230917132521.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String[] thousands = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">    String[] hundreds  = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    String[] tens      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    String[] ones      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        roman.append(thousands[num / <span class="number">1000</span>]);</span><br><span class="line">        roman.append(hundreds[num % <span class="number">1000</span> / <span class="number">100</span>]);</span><br><span class="line">        roman.append(tens[num % <span class="number">100</span> / <span class="number">10</span>]);</span><br><span class="line">        roman.append(ones[num % <span class="number">10</span>]);</span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十八、最长公共前缀"><a href="#十八、最长公共前缀" class="headerlink" title="十八、最长公共前缀"></a>十八、最长公共前缀</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230917140448.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>数组中的每个字符依次比较，每得到一个公共前缀，直接拿当前公共前缀和后一个字符比较即可，然后再更新公共前缀，比较途中公共前缀为空，则直接返回空字符。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strs.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">        prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Math.min(str1.length(), str2.length());</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十九、反转字符串中的单词"><a href="#十九、反转字符串中的单词" class="headerlink" title="*十九、反转字符串中的单词"></a>*十九、反转字符串中的单词</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230918144116.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>首先去除字符串头尾空格，后去除单词间多余空格，为了降低空间复杂度，那么直接对字符串进行更改，首先将字符串颠倒，然后再颠倒每个单词即可</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> trimSpaces(s);</span><br><span class="line">        reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);   <span class="comment">// 翻转字符串</span></span><br><span class="line">        reverseEachWord(sb);    <span class="comment">// 翻转每个单词</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">trimSpaces</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串间多余的空白字符去除</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;    <span class="comment">// 若sb中已经加入了空格，则多余的空格不用加入</span></span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(StringBuilder sb, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 循环至单词的末尾</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转单词   此时end指向空格或超过字符串长度</span></span><br><span class="line">            reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二十、N字形变换"><a href="#二十、N字形变换" class="headerlink" title="*二十、N字形变换"></a>*二十、N字形变换</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230918153309.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>遍历字符串，当从N字形头开始的时候，字符放置的位置是从第一行递增，到尾之后，开始递减</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StringBuilder&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        rows.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 初始化是反向，s遍历开始时，会变为正向递增。列结尾后会递减</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        rows.get(i).append(c);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">            flag = -flag;</span><br><span class="line">        &#125;</span><br><span class="line">        i += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(StringBuilder row : rows) &#123;</span><br><span class="line">        res.append(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二一、String中第一个匹配项下标"><a href="#二一、String中第一个匹配项下标" class="headerlink" title="二一、String中第一个匹配项下标"></a>二一、String中第一个匹配项下标</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230919184526.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue> <strong>若从0开始，到n - m为止的时候，还没有遍历到长字符串中有字符和短字符串中的头字符相等，那么就不用遍历了。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> needle.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) &#123;   <span class="comment">// 此处需要使用&lt;=，比如5-3，遍历前两个后，还需要遍历第三个才行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i, b = <span class="number">0</span>;      <span class="comment">// 此处使用a从i开始继续递增，如果递增到后面不想等了，a还是会等于后一步的i</span></span><br><span class="line">        <span class="keyword">while</span>(b &lt; m &amp;&amp; haystack.charAt(a) == needle.charAt(b)) &#123;</span><br><span class="line">            a ++;</span><br><span class="line">            b ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(b == m) &#123;       <span class="comment">// 说明b遍历完了，已经相等了，那么返回起始点i即可</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二二、文本对齐"><a href="#二二、文本对齐" class="headerlink" title="** 二二、文本对齐"></a>** 二二、文本对齐</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230921155638.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>首先确定每一行可以放置的单词的个数，这样可以得到这行的空格的个数，从而计算出每个单词之间的空格数</strong></font></p>
<p>空格要如何填充，可以分为一下三种情况：</p>
<p><strong>情形一：当前行是最后一行。</strong>则每个单词间空格个数为1个，行尾使用空格填充。</p>
<p><strong>情形二：当前行非最后一行，且只有一个单词。</strong>则单词左对齐，行尾使用空格填充。</p>
<p><strong>情形三：当前行非最后一行，且有多个单词。</strong>设当前行单词个数为<code>nums</code>，空格数为<code>spaces</code>，则每个单词之间的空格数应该为</p>
<p><code>avg = nums / (spaces - 1)</code>。其余数<code>extra</code>应该填充在当前行第一个单词后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">fullJustify</span><span class="params">(String[] words, <span class="type">int</span> maxWidth)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>, n = words.length;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> right; <span class="comment">// 当前行的第一个单词在 words 的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sumLen</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计这一行单词长度之和</span></span><br><span class="line">            <span class="comment">// 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格。</span></span><br><span class="line">            <span class="comment">// (right-left)可以看作是如果将right位的单词放置进来，需要的空格数，也可以看作是当前行的单词数</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; sumLen + words[right].length() + right - left &lt;= maxWidth) &#123;</span><br><span class="line">                sumLen += words[right++].length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格</span></span><br><span class="line">            <span class="keyword">if</span> (right == n) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> join(words, left, n, <span class="string">&quot; &quot;</span>);</span><br><span class="line">                sb.append(blank(maxWidth - sb.length()));</span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">numWords</span> <span class="operator">=</span> right - left;    <span class="comment">// 当前行的单词数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">numSpaces</span> <span class="operator">=</span> maxWidth - sumLen;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行只有一个单词：该单词左对齐，在行末填充剩余空格</span></span><br><span class="line">            <span class="keyword">if</span> (numWords == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(words[left]);</span><br><span class="line">                sb.append(blank(numSpaces));</span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行不只一个单词</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">avgSpaces</span> <span class="operator">=</span> numSpaces / (numWords - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">extraSpaces</span> <span class="operator">=</span> numSpaces % (numWords - <span class="number">1</span>);</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="comment">// 拼接额外加一个空格的单词</span></span><br><span class="line">            sb.append(join(words, left, left + extraSpaces + <span class="number">1</span>, blank(avgSpaces + <span class="number">1</span>))); </span><br><span class="line">            sb.append(blank(avgSpaces));</span><br><span class="line">            sb.append(join(words, left + extraSpaces + <span class="number">1</span>, right, blank(avgSpaces))); <span class="comment">// 拼接其余单词</span></span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// blank 返回长度为 n 的由空格组成的字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">blank</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sb.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串</span></span><br><span class="line">    <span class="keyword">public</span> StringBuffer <span class="title function_">join</span><span class="params">(String[] words, <span class="type">int</span> left, <span class="type">int</span> right, String sep)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(words[left]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt; right; ++i) &#123;</span><br><span class="line">            sb.append(sep);</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二三、验证回文字符串"><a href="#二三、验证回文字符串" class="headerlink" title="二三、验证回文字符串"></a>二三、验证回文字符串</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230921162837.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>若是标点符号、空格等特殊字符串，直接跳过即可</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) &#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left ++;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二四、判断子序列"><a href="#二四、判断子序列" class="headerlink" title="二四、判断子序列"></a>二四、判断子序列</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230922102946.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>s和t匹配上了，则同时右移，匹配不上，则t右移即可，以一方结束而终止循环，最后判断s的指针是否和s的长度相等</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sl</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">tl</span> <span class="operator">=</span> t.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp &lt; tl &amp;&amp; sp &lt; sl) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.charAt(tp) == s.charAt(sp)) &#123;</span><br><span class="line">            sp ++;</span><br><span class="line">        &#125;</span><br><span class="line">        tp ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sp == sl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二五、两数之和2"><a href="#二五、两数之和2" class="headerlink" title="*二五、两数之和2"></a>*二五、两数之和2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230922131259.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>二分法、双指针</strong></font></p>
<p><strong>方法一：二分法    时间复杂度O(nlogn)    空间复杂度O(1)</strong></p>
<p>首先循环数组，确定一个数 i，从 i + 1到 n - 1的范围中，使用二分法循环判断 mid，是否满足 nums[mid] &#x3D;&#x3D; target - nums[i]。相等则返回，小于则说明 mid 的值小于差值，差值出现在 mid 之后，所以更新 low 值位mid + 1，大于则更新 high 值为 mid - 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numbers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;   <span class="comment">// numbers只有两个数时，只用&lt;，无法进入while循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i + <span class="number">1</span>, mid + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：双指针   时间复杂度O(n)   空间复杂度O(1)</strong></p>
<p>first指针指向数组首，last指针指向数组尾，判断first + last 和 target 的大小。相等则返回，小于则first ++，大于则last –。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numbers.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>, last = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subv</span> <span class="operator">=</span> target - numbers[last];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fv</span> <span class="operator">=</span> numbers[first];</span><br><span class="line">        <span class="keyword">if</span>(subv == fv) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;first + <span class="number">1</span>, last + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(subv &gt; fv) &#123;</span><br><span class="line">            first ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二六、盛最多水的容器"><a href="#二六、盛最多水的容器" class="headerlink" title="*二六、盛最多水的容器"></a>*二六、盛最多水的容器</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230923143539.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>使用双指针，left指向头，right指向尾。left和right之间的距离总是在变小的，这时left和right的移动就要保证哪边小移动那边。</strong></font></p>
<p>盛水的长度 X &#x3D; right - left</p>
<p>盛水的高度 Y &#x3D; min(height[left], height[right])</p>
<p>盛水的容积 V &#x3D;  X * Y，在 X 总是变小的情况下，我们就得保证Y要变大，这样 V 才有可能变大，所以left、right指向的值，那边小，移动哪边指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> right - left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> height[right] - height[left];</span><br><span class="line">        <span class="keyword">if</span>(y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = Math.max(max, height[right] * x);</span><br><span class="line">            right --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, height[left] * x);</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二七、三数之和"><a href="#二七、三数之和" class="headerlink" title="*二七、三数之和"></a>*二七、三数之和</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230923170141.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将数组排序，确定第一个数后，剩下的两个数便可以根据它们的和去判断哪个指针要右移，哪个指针要左移。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>; first &lt; n; first ++) &#123;</span><br><span class="line">        <span class="comment">// 若后一个数与前一个数相同，则直接跳过当前循环</span></span><br><span class="line">        <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[first];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>; second &lt; n; second ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时说明third指向的值过大，third需要左移</span></span><br><span class="line">            <span class="keyword">while</span>(second &lt; third &amp;&amp; nums[third] + nums[second] &gt; target) &#123;</span><br><span class="line">                third --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明second的当前循环没有值满足条件，直接break，让first进行下一次遍历</span></span><br><span class="line">            <span class="keyword">if</span>(second == third) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[second] + nums[third] == target) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                list.add(nums[first]);</span><br><span class="line">                list.add(nums[second]);</span><br><span class="line">                list.add(nums[third]);</span><br><span class="line">                ans.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是nums[third] + nums[second] &lt; target的情况，说明second指向的值较小，则需要second右移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二八、长度最小子数组"><a href="#二八、长度最小子数组" class="headerlink" title="*二八、长度最小子数组"></a>*二八、长度最小子数组</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230924105508.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>当left和right指针指向的位置之间的值大于等于给定值之后，right继续向右的话，值肯定是大于的，这个时候就要left右移，去尽可能缩小这个子数组。如果缩小到小于给定值之后，right便可以向右。循环如此。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; n) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">            res = Math.min(res, right-left+<span class="number">1</span>);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        right ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二九、无重复字串的最长子串"><a href="#二九、无重复字串的最长子串" class="headerlink" title="*二九、无重复字串的最长子串"></a>*二九、无重复字串的最长子串</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230924140857.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>若没碰到重复字符，则right可以右移，若碰到了，则left右移，并且删掉left之前指向的值，直到删除了set中存在的让right重复的值。然后right继续右移，循环如此。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; n) &#123;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n &amp;&amp; !set.contains(s.charAt(right))) &#123;</span><br><span class="line">            set.add(s.charAt(right));</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, right - left);</span><br><span class="line">        left ++;</span><br><span class="line">        set.remove(s.charAt(left-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三十、最小覆盖子串"><a href="#三十、最小覆盖子串" class="headerlink" title="**三十、最小覆盖子串"></a>**三十、最小覆盖子串</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230927190655.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针 l 和 r 都从 s 字符的下标0开始遍历，r 初步遍历到包含 t 中所有字符位置为止，然后 l 右移，逐步缩小滑动窗口中的字符数量，若右移之后又不包含 t 中的所有字符了，那就 r 继续右移。循环如此，找出最小覆盖子串。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; tmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; smap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tLen</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen &lt; tLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tLen; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tc</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            tmap.put(tc, tmap.getOrDefault(tc, <span class="number">0</span>) + <span class="number">1</span>);    <span class="comment">// 首先将t中的所有字符的数量放到tmap中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, resL = <span class="number">0</span>, resR = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; sLen) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">sc</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">            <span class="keyword">if</span>(tmap.containsKey(sc)) &#123;    <span class="comment">// 判断当前r指向的字符是否在t中</span></span><br><span class="line">                smap.put(sc, smap.getOrDefault(sc, <span class="number">0</span>) + <span class="number">1</span>);   <span class="comment">// 若在，将当前字符存放在smap中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(check() &amp;&amp; l &lt;= r) &#123;    <span class="comment">// 检查通过说明l -&gt; r之间已经包含了t，smap和tmap中的内容完全相同</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(l);</span><br><span class="line">                <span class="keyword">if</span>(r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    resL = l;</span><br><span class="line">                    resR = l + len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmap.containsKey(c)) &#123;   <span class="comment">// 此时缩小窗口</span></span><br><span class="line">                    smap.put(c, smap.get(c) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l ++;   <span class="comment">// 窗口缩小</span></span><br><span class="line">            &#125;</span><br><span class="line">            r ++;    <span class="comment">// 窗口中字符不包含t，或窗口无法继续缩小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(resL, resR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前l -&gt; r之间的字符是否包含了t</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> tmap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iter.next();</span><br><span class="line">            <span class="type">Character</span> <span class="variable">key</span> <span class="operator">=</span> (Character) entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> (Integer) entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(smap.getOrDefault(key, <span class="number">0</span>) &lt; value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三一、有效的数独"><a href="#三一、有效的数独" class="headerlink" title="*三一、有效的数独"></a>*三一、有效的数独</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230928145758.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>使用三个数组分别来记录每一行，每一列，每个九宫格中的数的出现次数</strong></font></p>
<p>对于每一行中的值，使用一个数组<code>rows[9][9]</code>来表示，当前数放在这个数组的哪里，出现了几次。</p>
<p>对于每一列中的值，使用一个数组<code>columns[9][9]</code>来表示，当前数放在这个数组的哪里，出现了几次。</p>
<p>对于每一个九宫格的值，使用一个数组<code>subboxes[3][3][9]</code>来表示，当前数放在这个数组的哪里，出现了几次。</p>
<p>比如<code>borad[5][6] = 9</code>，那么这个数 5 ，放在<code>rows</code>中的第 5 行，第 9 - 1 列，出现了 1 次。放在<code>columns</code>中的第 6 行，第 9 - 1 列，出现了一次。如果<code>borad[5][n] = 9</code>，那么这个数继续放在第 5 行，第 9 - 1 列，出现了2次。同理<code>board[n][6] = 9</code>也是如此。如果有位置出现了超过 1 次，那么就直接返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] rows = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span>[][] columns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span>[][][] subboxes = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">            <span class="keyword">if</span>(c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                rows[i][index] ++;        <span class="comment">// 定住行，判断这一行中有没有数字重复</span></span><br><span class="line">                columns[j][index] ++;     <span class="comment">// 定住列，判断这一列中有没有数字重复</span></span><br><span class="line">                subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][index] ++;</span><br><span class="line">                <span class="keyword">if</span>(rows[i][index] &gt; <span class="number">1</span> || columns[j][index] &gt; <span class="number">1</span> || subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][index] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三二、螺旋矩阵"><a href="#三二、螺旋矩阵" class="headerlink" title="*三二、螺旋矩阵"></a>*三二、螺旋矩阵</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230930203450.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将矩阵看作有若干层，一层一层输出</strong></font></p>
<p>假设左上角位于<code>(top, left)</code>，右下角位于<code>(bottom, right)</code>，按照如下顺序遍历当前层元素：</p>
<p>1、从左往右遍历，由<code>(top, left)</code> 到 <code>(top, right)</code>。</p>
<p>2、从上往下遍历，由<code>(top + 1, right)</code> 到 <code>(bottom, right)</code>。</p>
<p>3、如果<code>left &lt; right，top &lt; bottom</code>。</p>
<p>​		从右往左遍历，由<code>(bottom, right - 1)</code> 到 <code>(bottom, left)</code>。</p>
<p>​		从下往上遍历，由<code>(bottom - 1, left)</code> 到 <code>(top + 1, left)</code>。</p>
<p><font color=red>**当只剩下最后一列遍历时，需要判断此时的left &lt; right，否则会多输出。当剩下最后一行遍历时，需要判断此时的top &lt; bottom， 否则也会多输出。因为行和列都会在前两个循环输出，若后两个循环不判断，则会造成数据重复输出。**</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; order = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = columns - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">colomn</span> <span class="operator">=</span> left; colomn &lt;= right; colomn ++) &#123;</span><br><span class="line">            order.add(matrix[top][colomn]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> top + <span class="number">1</span>; row &lt;= bottom; row ++) &#123;</span><br><span class="line">            order.add(matrix[row][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">colomn</span> <span class="operator">=</span> right - <span class="number">1</span>; colomn &gt;= left; colomn --) &#123;</span><br><span class="line">                order.add(matrix[bottom][colomn]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> bottom - <span class="number">1</span>; row &gt; top; row --) &#123;</span><br><span class="line">                order.add(matrix[row][left]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">        top ++;</span><br><span class="line">        bottom --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三三、旋转图像"><a href="#三三、旋转图像" class="headerlink" title="*三三、旋转图像"></a>*三三、旋转图像</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231001183904.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>直接旋转。或者先水平轴对折，然后以左顶角和右底角连线为轴对折。</strong></font></p>
<p><font color=blue><strong>方法一：</strong></font><strong>直接旋转</strong></p>
<p>我们可以发现，<strong>对于矩阵中的第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。</strong></p>
<p>因此，对于矩阵中的元素<code>matrix[row][col]</code>，在旋转后，它的新位置为<code>matrix[col][n-row-1]</code>。新的行等于原来的列，新的列等于n减去原来的行减去1。<br>$$<br>\begin{cases}<br>   row &#x3D; col \<br>   col &#x3D; n - row - 1<br>  \end{cases}<br>$$<br>由此，我们可以得出矩形的四个方位的数据，旋转前后的位置关系如下：</p>
<p><strong>1旋转到3，行列变化为：</strong><code>matrix[row][col]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[col][n-row-1]</code></p>
<p><strong>3旋转到9，行列变化为：</strong><code>matrix[col][n-row-1]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[n-row-1][n-col-1]</code></p>
<p><strong>9旋转到7，行列变化为：</strong> <code>matrix[n-row-1][n-col-1]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[n-col-1][n-(n-row-1)-1]</code>  &#x3D;&#x3D;&#x3D;&gt;   <code>matrix[n-col-1][row]</code> </p>
<p><strong>7旋转到1，行列变化为：</strong> <code>matrix[n-col-1][row]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[row][n-(n-col-1)-1]</code>  &#x3D;&#x3D;&#x3D;&gt;   <code>matrix[row][col]</code> </p>
<p>对于我们实际需要遍历的行数和列数，我们可以推理出，若 n 是偶数矩阵，则行和列遍历到 n&#x2F;2 即可。若 n 是奇数矩阵，则行遍历到n&#x2F;2，列遍历到(n+1)&#x2F;2。如下图：</p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231001195011.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; j ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=blue><strong>方法二：</strong></font><strong>先水平轴对折，然后以左顶角和右底角连线为轴对折</strong></p>
<p><strong>水平轴对折，行列变化为：</strong><code>matrix[row][col]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[n-row-1][col]</code></p>
<p><strong>反斜轴对折，行列变化为：</strong><code>matrix[n-row-1][col]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[col][n-row-1]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="comment">// 水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - i - <span class="number">1</span>][j];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三四、矩阵置零"><a href="#三四、矩阵置零" class="headerlink" title="*三四、矩阵置零"></a>*三四、矩阵置零</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231002195709.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>首先记录第一行和第一列是否存在 0，对于非第一行和第一列为 0 的元素，可以将这个数所在的行和列的第一个数都置为 0，然后从第二行第二列开始遍历，判断遍历到的行和列的第一个数是否为 0，若为 0，则将当前行和列全部置为 0。最后再判断是否需要将第一行和第一列置为 0。</strong></font></p>
<p><strong>1、</strong>记录第一行和第一列是否本来就存在 0；</p>
<p><strong>2、</strong>判断除第一行第一列外，是否存在 0，若存在，就将当前行和列的第一个数（在第一行或第一列上）置为 0；</p>
<p><strong>3、</strong>根据第一行和第一列的 0（包括后期赋值的0）将非第一行和第一列的值全部变成 0；</p>
<p><strong>4、</strong>最后根据第一步的记录，判断第一行和第一列是否需要置为0；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flagCol</span> <span class="operator">=</span> <span class="literal">false</span>, flagRow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            flagCol = <span class="literal">true</span>;     <span class="comment">// 第一列存在0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            flagRow = <span class="literal">true</span>;     <span class="comment">// 第一行存在0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断除第一行第一列外，是否存在0，若存在，就将当前行和列的第一个数置为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据第一行和第一列的0（包括后期赋值的0）将非第一行和第一列的值全部变成0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后判断是否需要将第一行和第一列置为0</span></span><br><span class="line">    <span class="keyword">if</span>(flagRow) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flagCol) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三五、生命游戏"><a href="#三五、生命游戏" class="headerlink" title="*三五、生命游戏"></a>*三五、生命游戏</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231003200021.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231003200121.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>题目限定的条件都是根据相邻活细胞的数量来判断当前细胞是死是活。因此，对于活细胞变成死细胞后，我们可以使用额外的数据来表示当前细胞的状态，以便于后面可以准确的拿到细胞之前的状态。对于活细胞变成死细胞，可以将状态变成 -1，这样有相邻数据要去判断自己是否存活时，可以直接用 -1 的绝对值来查看它的相邻的细胞之前的状态。</strong></font></p>
<p><strong>1、</strong>两层嵌套遍历<code>&#123;-1,0,1&#125;</code>，可以快速得到某一点的周围 3 * 3 点的坐标，然后根据它们的值去判断它们之前的状态是否为活细胞。</p>
<p><strong>2、</strong>根据活细胞的数量，将当前细胞的状态设置成容易识别的数字，比如 -1 就代表之前活细胞，现在死细胞；2 代表之前死细胞，现在活细胞。方便之后当前细胞作为别的细胞的相邻细胞的时候，能够准确的判断其之前的状态，从而去计算 liveNear 的值。</p>
<p><strong>3、</strong>将细胞的状态设置完后，重新遍历，根据之前设置的值，重新将细胞的状态更新正常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] near = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">liveNear</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!(near[i] == <span class="number">0</span> &amp;&amp; near[j] == <span class="number">0</span>)) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> row + near[i];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> col + near[j];</span><br><span class="line">                        <span class="comment">// Math.abs(board[r][c]) == 1 可以替换成 board[r][c] == 1 || board[r][c] == 3</span></span><br><span class="line">                        <span class="keyword">if</span>((r &gt;= <span class="number">0</span> &amp;&amp; r &lt; rows) &amp;&amp; (c &gt;= <span class="number">0</span> &amp;&amp; c &lt; cols) &amp;&amp; Math.abs(board[r][c]) == <span class="number">1</span>) &#123;</span><br><span class="line">                            liveNear ++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(board[row][col] == <span class="number">1</span> &amp;&amp; (liveNear &gt; <span class="number">3</span> || liveNear &lt; <span class="number">2</span>)) &#123;</span><br><span class="line">                board[row][col] = -<span class="number">1</span>;     <span class="comment">// 这里也可以用别的值   如: board[row][col] = 3</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[row][col] == <span class="number">0</span> &amp;&amp; (liveNear == <span class="number">3</span>)) &#123;</span><br><span class="line">                board[row][col] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][col] == <span class="number">2</span>) &#123;</span><br><span class="line">                board[row][col] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[row][col] == -<span class="number">1</span>) &#123;</span><br><span class="line">                board[row][col] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三六、赎金信"><a href="#三六、赎金信" class="headerlink" title="三六、赎金信"></a>三六、赎金信</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231003203458.png"></p>
<p><font color = red><strong>思路：</strong></font><font color=blue><strong>magazine长度小于ransomNote，则直接返回false。判断ransomNote中使用到的字符的个数，在magazine中是否全部出现，个数是否能对上，不能对上，则返回false</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ransomNote.length() &gt; magazine.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">        cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">        cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三七、同构字符串"><a href="#三七、同构字符串" class="headerlink" title="三七、同构字符串"></a>三七、同构字符串</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231004192103.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将s中出现的字符和t中出现的字符先映射起来，若之后s中又碰到相同的字符，但是t中出现的字符和映射关系中s对应的字符不相同，则返回false。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    Map&lt;Character, Character&gt; s2t = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Character&gt; t2s = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="type">char</span> <span class="variable">y</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>((s2t.containsKey(x) &amp;&amp; s2t.get(x) != y) || (t2s.containsKey(y) &amp;&amp; t2s.get(y) != x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s2t.put(x, y);</span><br><span class="line">        t2s.put(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三八、单词规律"><a href="#三八、单词规律" class="headerlink" title="三八、单词规律"></a>三八、单词规律</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231004194413.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将pattern出现的字符和s中的单词相互映射起来，若后面pattern中碰到相同的字符，但是s中出现的单词和映射关系中pattern对应的单词不相同，则返回false。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String str)</span> &#123;</span><br><span class="line">    Map&lt;String, Character&gt; str2ch = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Character&gt;();</span><br><span class="line">    Map&lt;Character, String&gt; ch2str = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    String[] strs = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(m != strs.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sh</span> <span class="operator">=</span> strs[i];</span><br><span class="line">        <span class="keyword">if</span> (str2ch.containsKey(sh) &amp;&amp; str2ch.get(sh) != ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch2str.containsKey(ch) &amp;&amp; !sh.equals(ch2str.get(ch))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str2ch.put(sh, ch);</span><br><span class="line">        ch2str.put(ch, sh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String str)</span> &#123;</span><br><span class="line">    Map&lt;String, Character&gt; str2ch = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Character&gt;();</span><br><span class="line">    Map&lt;Character, String&gt; ch2str = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; pattern.length(); ++p) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> pattern.charAt(p);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m &amp;&amp; str.charAt(j) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> str.substring(i, j);</span><br><span class="line">        <span class="keyword">if</span> (str2ch.containsKey(tmp) &amp;&amp; str2ch.get(tmp) != ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch2str.containsKey(ch) &amp;&amp; !tmp.equals(ch2str.get(ch))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str2ch.put(tmp, ch);</span><br><span class="line">        ch2str.put(ch, tmp);</span><br><span class="line">        i = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &gt;= m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三九、有效的字母异位词"><a href="#三九、有效的字母异位词" class="headerlink" title="三九、有效的字母异位词"></a>三九、有效的字母异位词</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231005191641.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>判断 s 和 t 中的每个字符的个数是否相等即可。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四十、字母异位词分组"><a href="#四十、字母异位词分组" class="headerlink" title="*四十、字母异位词分组"></a>*四十、字母异位词分组</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231005193252.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将每个单词进行字符排序后作为key，同为异位词的单词，key肯定是相同的。也可以将每个单词中，按照 “字符 + 字符出现的次数” 进行拼接作为key，同为异位词的单词，key肯定也相同。</strong></font></p>
<p><strong>方法一：将每个单词进行字符排序后，作为key。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(key, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：将每个单词按照 “字符 + 字符出现的次数” 进行拼接作为key。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            counts[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counts[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">                sb.append(counts[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(key, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四一、两数之和"><a href="#四一、两数之和" class="headerlink" title="四一、两数之和"></a>四一、两数之和</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231007151542.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>存在一个map，我们遍历某个数的时候，判断map中是否存在这个数的另一对，存在直接返回，不存在便用map储存这个数以及其下标</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四二、快乐数"><a href="#四二、快乐数" class="headerlink" title="四二、快乐数"></a>四二、快乐数</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231008233833.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p><strong>方法一：用哈希集合检测循环</strong>     <font color=blue><strong>时间复杂度 O(logn)    空间复杂度 O(logn)</strong></font></p>
<p>对于一个整数来说，其变化有如下几种情况：</p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231008234128.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/202_fig2.png"></p>
<p>根据探索，会有如下三种情况：</p>
<p><strong>1、一个数经过变化，最终会变成 1 。</strong></p>
<p><strong>2、一个数经过变化，最终会形成循环。</strong></p>
<p><strong>3、一个数经过变化，会变得无限大。</strong></p>
<p>对于第三种情况是否真的存在，我们进行如下思考：</p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231008234424.png"></p>
<p>对于 <strong>3</strong> 位数的数字，它不可能大于 <strong>243</strong>。这意味着它要么被困在 <strong>243</strong> 以下的循环内，要么跌到 <strong>1</strong>。<strong>4</strong> 位或 <strong>4</strong> 位以上的数字在每一步都会丢失一位，直到降到 <strong>3</strong> 位为止。所以我们知道，最坏的情况下，算法可能会在 <strong>243</strong> 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 <strong>1</strong>。但它不会无限期地进行下去，所以我们排除第三种选择。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !seen.contains(n)) &#123;</span><br><span class="line">            seen.add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：快慢指针</strong>     <font color=blue><strong>时间复杂度 O(logn)      空间复杂度 O(1)</strong></font></p>
<p>对于非快乐数的变化，可以发现最终数据的变化形成了一个环，这里可以采用弗洛伊德循环查找算法，这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。</p>
<p>如果 <strong>n</strong> 是一个快乐数，即没有循环，那么快跑者会比慢跑者先到达 <strong>1</strong> 。</p>
<p>如果 <strong>n</strong> 不是一个快乐数，那么快跑者会先比慢跑者到达数字 <strong>1</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowRunner</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fastRunner</span> <span class="operator">=</span> getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：数字</strong>     <font color=blue><strong>时间复杂度 O(logn)     空间复杂度 O(1)</strong></font></p>
<p>下一个值可能比自己大的最大数字是什么？根据我们之前的分析，我们知道它必须低于 <strong>243</strong>。因此，我们知道任何循环都必须包含小于 <strong>243</strong> 的数字，用这么小的数字，编写一个能找到所有周期的强力程序并不困难。</p>
<p>如果这样做，您会发现只有一个循环：<code>4→16→37→58→89→145→42→20→4</code>。所有其他数字都在进入这个循环的链上，或者在进入<strong>1</strong> 的链上。</p>
<p>因此，我们可以硬编码一个包含这些数字的散列集，如果我们达到其中一个数字，那么我们就知道在循环中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; cycleMembers =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !cycleMembers.contains(n)) &#123;</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四三、存在重复元素2"><a href="#四三、存在重复元素2" class="headerlink" title="四三、存在重复元素2"></a>四三、存在重复元素2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231009222143.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231009222227.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>哈希表，滑动窗口</strong></font></p>
<p><strong>方法一：哈希表</strong>     <font color=blue><strong>时间复杂度 O(n)    空间复杂度 O(n)</strong></font></p>
<p>使用一个<code>map</code>，其<code>key</code>为数组中的数，<code>value</code>为这些数的下标。若遍历到的当前的数，不存在于<code>map</code>中，则将当前数和其下标都存放在<code>map</code>中，若存在于<code>map</code>中，则将<code>map</code>中与当前值相同的键值对取出来，判断它们两个的下标差是否小于等于<code>k</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(num) &amp;&amp; i - map.get(num) &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：滑动窗口</strong>     <font color=blue><strong>时间复杂度 O(n)    空间复杂度 O(k)</strong></font></p>
<p>维护一个滑动窗口，使窗口中的每个数的下标差的绝对值不超过<code>k</code>，那就说明这个窗口的长度要维护在<code>k+1</code>以内。由于下标是从<code>0</code>开始的，那么只有当<code>i &lt;= k</code>时，窗口的长度才维持在了<code>k+1</code>以内。当<code>i &gt; k</code>时，就可以从滑动窗口的头部移除元素<code>i - k - 1</code>，将新的元素加入到滑动窗口，此时只用判断新加入的元素是否已经存在在滑动窗口里即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">if</span>(!set.add(num)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四四、最长连续序列"><a href="#四四、最长连续序列" class="headerlink" title="*四四、最长连续序列"></a>*四四、最长连续序列</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231013154020.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>哈希表</strong></font>     <strong>时间复杂度 O(n)    空间复杂度 O(n)</strong></p>
<p>遍历数组，判断当前数 num 之前的数 num– 是否存在于数组中。</p>
<p>若存在，则说明不能从当前这个数开始计算序列。</p>
<p>若不存在，则判断 num ++ 是否存在于数组中；</p>
<p>​		若不存在，则说明当前这个数不存在任何连续数；</p>
<p>​		若存在，则说明可以从当前这个数开始计算序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; num_set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        num_set.add(num);         <span class="comment">// 也可不用单独去重，只不过去重可以省去很多不必要的对比判断操作。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">longestStreak</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : num_set) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!num_set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentStreak</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(num_set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                currentNum ++;</span><br><span class="line">                currentStreak ++;</span><br><span class="line">            &#125;</span><br><span class="line">            longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestStreak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四五、汇总区间"><a href="#四五、汇总区间" class="headerlink" title="四五、汇总区间"></a>四五、汇总区间</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231013151755.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231013151833.png"></p>
<p><font color= red><strong>思路：</strong></font><font color=blue><strong>判断后一个数和前一个数之间的差是否为 1 即可。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">summaryRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> i;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; nums[i] - nums[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(Integer.toString(nums[low]));</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            sb.append(Integer.toString(nums[high]));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四六、合并区间"><a href="#四六、合并区间" class="headerlink" title="*四六、合并区间"></a>*四六、合并区间</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231013201606.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将二维数组根据第一个数进行升序排列，这样就只用将后一个二维数组的两个数和前一个二维数组的第二个数比对即可。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">// 根据第一个元素排序二维数组</span></span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] one, <span class="type">int</span>[] two)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> one[<span class="number">0</span>] - two[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将当前数组的右侧元素r和下一个数组的左侧元素ll对比，若ll &lt;= r，说明存在重叠</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; intervals.length &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= r) &#123;</span><br><span class="line">            r = Math.max(r, intervals[j][<span class="number">1</span>]);    <span class="comment">// 取出两个数组右侧元素作比对，大的作为新的右侧元素</span></span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">0</span>], r&#125;);   <span class="comment">// 由于二维数组根据左侧元素有序，所以新的左侧元素不用作处理</span></span><br><span class="line">        i = j;   <span class="comment">// j跳出循环的时候要么数组遍历完毕，要么新的数组不存在重叠，所以j可以直接赋值给i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据第一个元素排序二维数组</span></span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 若merged为空，或者当前数组的左侧值比merged中最后一个数组的右侧值还要大，说明不存在重叠</span></span><br><span class="line">        <span class="keyword">if</span> (merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">            merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L, R&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存在重叠，将当前数组的右侧值和merged中最后一个数组的右侧值进行比较，更新merged中最后一个数组的右侧值</span></span><br><span class="line">            merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>], R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四七、插入区间"><a href="#四七、插入区间" class="headerlink" title="*四七、插入区间"></a>*四七、插入区间</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231013212950.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231013213014.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>判断插入区间和每个数组之间的关系，是否有重叠出现。</strong></font></p>
<p>待插入的区间为<code>[left, right]</code>，遍历每个数组，遍历到<code>[ll, rr]</code>时：</p>
<p>如果 <code>ll &gt; right</code>，说明待插入数组在当前数组的左侧，此时应该先将待插入数组放入集合，然后再放入当前数组。</p>
<p>如果 <code>rr &lt; left</code>，说明待插入数组在当前数组的右侧，此时应该先将当前数组放入集合，然后再去判断待插入数组和下一个数组的关系。</p>
<p>如果上面的条件都不满足，则说明存在重叠区域，将当前数组和待插入数组合并成新的待插入数组，<code>left</code>取两者最小，<code>right</code>取两者最大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> newInterval[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> newInterval[<span class="number">1</span>];</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">placed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ansList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 当前数组在插入区间的右侧且无交集</span></span><br><span class="line">            <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                ansList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                placed = <span class="literal">true</span>;                    </span><br><span class="line">            &#125;</span><br><span class="line">            ansList.add(interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">            <span class="comment">// 当前数组在插入区间的左侧且无交集</span></span><br><span class="line">            ansList.add(interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前数组与插入区间有交集，计算它们的并集变成新的插入区间</span></span><br><span class="line">            left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">            right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!placed) &#123;   <span class="comment">// 若原数组为空，或插入区间在最右侧，可以用此值来判断，是否需要往集合中加入待插入区间</span></span><br><span class="line">        ansList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansList.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ansList.size()][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四八、用最少的箭引爆气球"><a href="#四八、用最少的箭引爆气球" class="headerlink" title="*四八、用最少的箭引爆气球"></a>*四八、用最少的箭引爆气球</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231015112706.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231015112752.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将数组根据右侧元素进行排序后，将第一个数组的右侧数作为第一箭，当遍历到其他数组时，存在当前数组的左侧元素大于第一箭，则说明需要第二箭去引爆当前遍历到的区间，从而将当前数组的右侧数作为第二箭，然后再去判断别的数组区间的左侧数是否大于第二箭，以此类推。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用此方式排序会导致int溢出，从而使得计算结果有误</span></span><br><span class="line">    <span class="comment">// int[][] points = &#123;&#123;-2147483646,-2147483645&#125;,&#123;2147483646,2147483647&#125;&#125;;</span></span><br><span class="line">    <span class="comment">// Arrays.sort(points, new Comparator&lt;int[]&gt;() &#123;</span></span><br><span class="line">    <span class="comment">//     public int compare(int[] one, int[] two) &#123;</span></span><br><span class="line">    <span class="comment">//         return one[1] - two[1];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    Arrays.sort(points, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] one, <span class="type">int</span>[] two)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(one[<span class="number">1</span>] &gt; two[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(one[<span class="number">1</span>] &lt; two[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];    <span class="comment">// 将右边界最小的第一个区间的有边界作为第一箭</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] point : points) &#123;</span><br><span class="line">        <span class="keyword">if</span>(point[<span class="number">0</span>] &gt; pos) &#123;   <span class="comment">// 如果存在另外一个区间的左边界要比当前第一箭的位置大，则需要第二箭</span></span><br><span class="line">            res ++;</span><br><span class="line">            pos = point[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四九、有效的括号"><a href="#四九、有效的括号" class="headerlink" title="四九、有效的括号"></a>四九、有效的括号</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231015114218.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231015114238.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>遍历括号朝右时，将当前字符存储再index处，然后index自增。当碰到括号朝左时，就可以将index自减后，去判断这个位置存储的字符是否和当前字符成对。成对则继续遍历，不成对则直接返回false。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] stack = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack[index++] = s.charAt(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack[index++] = s.charAt(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack[index++] = s.charAt(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span> || stack[--index] != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span> || stack[--index] != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span> || stack[--index] != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五十、简化路径"><a href="#五十、简化路径" class="headerlink" title="*五十、简化路径"></a>*五十、简化路径</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231015141418.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>维护一个双端队列，若碰到 .. 时，则弹出队列的最后一个，若碰到字符时，往队列中添加此字符。最后从双端队列的头部一一获取字符进行拼接。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    String[] names = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;..&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty()) &#123;</span><br><span class="line">                stack.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(name.length() &gt; <span class="number">0</span> &amp;&amp; !<span class="string">&quot;.&quot;</span>.equals(name)) &#123;</span><br><span class="line">            stack.offerLast(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            sb.append(stack.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五一、最小栈"><a href="#五一、最小栈" class="headerlink" title="*五一、最小栈"></a>*五一、最小栈</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231016110913.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231016110949.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>维护一个最小栈，当往正常栈中push一个值的时候，也往最小栈中push一个当前栈中的最小值。这样获取最小值的时候，只用获取最小栈中的最顶端元素即可。</strong></font></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231016112315.png"></p>
<p>按照上面思路，只需要设计一个数据结构，是的每个元素<code>val</code>与其相应的最小值<code>min</code>时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p>
<p>1、当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p>
<p>2、当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p>
<p>3、在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), val));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五二、逆波兰表达式"><a href="#五二、逆波兰表达式" class="headerlink" title="*五二、逆波兰表达式"></a>*五二、逆波兰表达式</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231017180500.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>可以利用栈，碰到数字便放入栈，当碰到运算符时，依次取出栈顶的两个数进行运算，然后再入栈。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tokens.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">                stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        stack.push(num1 + num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        stack.push(num1 - num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        stack.push(num1 * num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        stack.push(num1 / num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="string">&quot;+&quot;</span>.equals(token) || <span class="string">&quot;-&quot;</span>.equals(token) || <span class="string">&quot;*&quot;</span>.equals(token) || <span class="string">&quot;/&quot;</span>.equals(token));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也可以倒着遍历数组，若碰到运算符，则将索引递减后，重新调用当前方法，若碰到数字，则返回当前数字，然后索引递减。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        index = tokens.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getNext(tokens);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从后往前的递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(String[] tokens)</span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">switch</span> (tokens[index]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> -&gt; &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">return</span> getNext(tokens) + getNext(tokens);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span> -&gt; &#123;</span><br><span class="line">                index--;</span><br><span class="line">                tmp = getNext(tokens);</span><br><span class="line">                <span class="keyword">return</span> getNext(tokens) - tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span> -&gt; &#123;</span><br><span class="line">                index--;</span><br><span class="line">                tmp = getNext(tokens);</span><br><span class="line">                <span class="keyword">return</span> getNext(tokens) * tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span> -&gt; &#123;</span><br><span class="line">                index--;</span><br><span class="line">                tmp = getNext(tokens);</span><br><span class="line">                <span class="keyword">return</span> getNext(tokens) / tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(tokens[index--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五三、基本计算器"><a href="#五三、基本计算器" class="headerlink" title="**五三、基本计算器"></a>**五三、基本计算器</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231018142744.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p>1、维护一个存放正负符号的栈。最开始的时候，我们需要给一个默认符号，这个默认符号给正，并将其放入栈中。</p>
<p>2、当碰到运算符 <code>+</code> 时，我们从栈中直接取出最顶端的数作为符号即可。</p>
<p>3、当碰到运算符 <code>-</code> 时，我们从栈中取出最顶端的数，并且将这个数正负反转，然后再作为符号。</p>
<p>4、当碰到 <code>(</code> 时，我们需要将当前正在使用的符号放入栈中，因为括号中是一个整体，括号里面运算时，也需要从栈最顶端取出符号，所以我们需要在碰到 <code>(</code> 时，将当前正在使用的符号放入栈中，以方便括号内运算时使用。</p>
<p>5、当碰到 <code>)</code> 时，说明括号已经运算完成，此时需要将栈顶元素弹出，以免这个括号运算的符号影响到后面的运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            sign = stack.peek();</span><br><span class="line">            i ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -stack.peek();</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(sign);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += sign * num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五四、两数相加"><a href="#五四、两数相加" class="headerlink" title="*五四、两数相加"></a>*五四、两数相加</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231019130430.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>对于两个单位数的和，它们相加之后的余数，可以作为当前位的数，它们相加之后的除数，可以作为进位数。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || t != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            t += l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            t += l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(t%<span class="number">10</span>);</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五五、合并两个有序链表"><a href="#五五、合并两个有序链表" class="headerlink" title="五五、合并两个有序链表"></a>五五、合并两个有序链表</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231020140042.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">            pre.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五六、反转链表2"><a href="#五六、反转链表2" class="headerlink" title="*五六、反转链表2"></a>*五六、反转链表2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231023144248.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>可以一个一个逐步反转</strong></font></p>
<p>使用三个指针 <code>pre</code>，<code>cur</code>，<code>temp</code> 来记录反转的过程中需要的变量，它们的意义如下：</p>
<p><code>pre</code>：永远指向待反转区域的第一个节点的前一个节点。</p>
<p><code>cur</code>：永远指向待反转区域的第一个节点</p>
<p><code>temp</code>：永远指向 <code>cur</code> 的后一个节点，循环过程中，<code>cur.next</code> 会一直变化。</p>
<p><strong>操作步骤：</strong></p>
<p>将 <code>temp </code>  节点拿出来，放在 <code>pre</code> 和 <code>cur</code> 的中间。</p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/1615105296-bmiPxl-image.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/1615105353-PsCmzb-image.png"></p>
<p>先将 <code>cur</code> 的下一个节点记录为 <code>temp</code> ；</p>
<p>把 <code>cur</code> 的下一个节点指向 <code>temp</code> 的下一个节点；</p>
<p>把 <code>temp</code> 的下一个节点指向 <code>pre</code> 的下一个节点；</p>
<p>把 <code>pre</code> 的下一个节点指向 <code>temp</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    res.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    ListNode temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left; i ++) &#123;</span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = temp.next;  <span class="comment">// cur的下一个节点变成temp的下一个节点</span></span><br><span class="line">        temp.next = pre.next;  <span class="comment">// temp肯定是要变成紧跟在pre之后的，pre原来的下一个节点要变成temp的下一个节点</span></span><br><span class="line">        pre.next = temp;       <span class="comment">// temp节点肯定是要变成紧跟在pre之后的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五七、k个一组反转链表"><a href="#五七、k个一组反转链表" class="headerlink" title="**五七、k个一组反转链表"></a>**五七、k个一组反转链表</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231024105450.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>可以直接在链表上，对 k 个节点进行反转。也可以将 k 个节点单独拿出来成为一个链表，反转后再拼接回去。</strong></font></p>
<p><strong>方法一：直接在链表上对 k 个节点进行反转</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> hair;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 查看剩余节点是否有k个</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hair.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">            head.next = temp.next;</span><br><span class="line">            temp.next = pre.next;</span><br><span class="line">            pre.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：将 k 个节点单独拿出来成为一个链表，反转后再拼接回去</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy, end = dummy;</span><br><span class="line">        <span class="keyword">while</span>(end.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">                <span class="keyword">if</span>(end == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> dummy.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> end.next;</span><br><span class="line">            end.next = <span class="literal">null</span>;    <span class="comment">// 找到 k 个节点的链表之后，截断</span></span><br><span class="line">            pre.next = reverse(start);    <span class="comment">// 反转之后，将当前的头节点和pre连接</span></span><br><span class="line">            start.next = next;     <span class="comment">// 反转之后，将最后的节点和next进行连接</span></span><br><span class="line">            pre = start;    <span class="comment">// 更新pre为反转之后链表的最后一个节点</span></span><br><span class="line">            end = pre;      <span class="comment">// 更新end为pre，此时start，end，pre在同一个节点上</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, p = node;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = pre;    <span class="comment">// 将p的下一个变成pre，进行反转</span></span><br><span class="line">            pre = p;         <span class="comment">// 把当前的p变成pre</span></span><br><span class="line">            p = t;           <span class="comment">// 把之前p的下一个变成p</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;     <span class="comment">// pre指向的是原链表的最后一个节点，也就是反转之后的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五八、删除链表的倒数第n个节点"><a href="#五八、删除链表的倒数第n个节点" class="headerlink" title="*五八、删除链表的倒数第n个节点"></a>*五八、删除链表的倒数第n个节点</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231025093535.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>计算出总长度 L ，需要删除的节点就是第 L - n + 1 个。也可以将链表中的节点放在栈中，弹出的第 n 个节点就是需要删除的节点。</strong></font></p>
<p><strong>方法一：删除第 L - n + 1 个节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> hair;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            cur = cur.next;           <span class="comment">// 遍历完成之后，cur就是待删除节点的前一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="keyword">return</span> hair.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            length ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用栈，弹出第 n 个节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> hair;</span><br><span class="line">    Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 也需要将自定义的前结点放进去，避免链表只有一个节点所导致的stack.peek()取出的前节点为null的情况</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> stack.peek();     <span class="comment">// 此时需要删除的节点已经弹出，再取出的节点就是删除节点的前结点</span></span><br><span class="line">    pre.next = pre.next.next;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五九、删除排序链表中的重复项2"><a href="#五九、删除排序链表中的重复项2" class="headerlink" title="*五九、删除排序链表中的重复项2"></a>*五九、删除排序链表中的重复项2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231025124906.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>存在一个节点cur，当cur.next和cur.next.next相等的时候，可以将cur.next删除，即循环让cur.next &#x3D; cur.next.next，依次判断当前cur.next的值是否和之前cur.next的值相等，然后此时再重复上述操作再次将cur.next删除即可。</strong></font></p>
<p>若<code>cur.next.val == cur.next.next.val</code>，获取当前<code>cur.next.val</code>为<code>val</code>。由于后面会将<code>cur.next.next</code>赋值给<code>cur.next</code>（这一步是删除当前<code>cur.next</code>）。所以我们每一步都去判断<code>cur.next.val</code>是否和<code>val</code>相等，依次来达到删除一个之后，其后面的数据是否又和当前要删除的相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> hair;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">            <span class="comment">// 此时已经存在两个节点相同，所以要从第一个相同的节点开始删除，并将后面的节点替补过来</span></span><br><span class="line">            <span class="comment">// 所以我们只需要判断cur.next的val是否一直和val相等即可</span></span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next;   <span class="comment">// 后面节点依次往前替补</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六十、旋转链表"><a href="#六十、旋转链表" class="headerlink" title="*六十、旋转链表"></a>*六十、旋转链表</h1><p><img src="C:/Users/CJK/AppData/Roaming/Typora/typora-user-images/image-20231026103523708.png" alt="image-20231026103523708"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>可以先将整个链表变成环，然后在找到对应的节点位置，从后断开即可。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lengthNode</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lengthNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        length ++;</span><br><span class="line">        lengthNode = lengthNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// eg：旋转1次，此时lengthNode在原链表最后节点处，此时lengthNode需要走到length-k%length截断</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> length - k % length;</span><br><span class="line">    <span class="keyword">if</span>(add == length) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    lengthNode.next = head;</span><br><span class="line">    <span class="keyword">while</span>(add -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        lengthNode = lengthNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> lengthNode.next;</span><br><span class="line">    lengthNode.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六一、分割链表"><a href="#六一、分割链表" class="headerlink" title="*六一、分割链表"></a>*六一、分割链表</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231026105817.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>准备两个链表，一个存放比x小的，另一个存放剩下的。然后再把两个链表拼接起来即可。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">small</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">smallHead</span> <span class="operator">=</span> small;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">large</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">largeHead</span> <span class="operator">=</span> large;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val &lt; x) &#123;</span><br><span class="line">            small.next = head;</span><br><span class="line">            small = small.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large.next = head;</span><br><span class="line">            large = large.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    large.next = <span class="literal">null</span>;</span><br><span class="line">    small.next = largeHead.next;</span><br><span class="line">    <span class="keyword">return</span> smallHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六二、LRU缓存"><a href="#六二、LRU缓存" class="headerlink" title="*六二、LRU缓存"></a>*六二、LRU缓存</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231026145458.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将节点更新到链表头部可以先将节点删除，然后将节点插入到头部。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 加入到map</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加到双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">if</span>(size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 超出容量，删除链表的尾部</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// map中删除</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                size --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 更改值，并移动到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">value</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六三、二叉树的最大深度"><a href="#六三、二叉树的最大深度" class="headerlink" title="六三、二叉树的最大深度"></a>六三、二叉树的最大深度</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231027100605.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>深度遍历和广度遍历</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;   <span class="comment">// 当前层的层高是其下左节点和右节点层高的最大值然后加上当前层的1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();    <span class="comment">// 当前层的节点数</span></span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();      <span class="comment">// 当前层的左节点和右节点放入queue</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res ++;     <span class="comment">// 每层遍历完，层高 ++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六四、相同的树"><a href="#六四、相同的树" class="headerlink" title="六四、相同的树"></a>六四、相同的树</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231027114056.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>深度遍历和广度遍历</strong></font></p>
<p><strong>方法一：深度遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p.val != q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：广度遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue1.offer(p);</span><br><span class="line">    queue2.offer(q);</span><br><span class="line">    <span class="keyword">while</span>(!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">one</span> <span class="operator">=</span> queue1.poll();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">two</span> <span class="operator">=</span> queue2.poll();</span><br><span class="line">        <span class="keyword">if</span>(one.val != two.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">l1</span> <span class="operator">=</span> one.left, r1 = one.right, l2 = two.left, r2 = two.right;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span> ^ l2 == <span class="literal">null</span>) &#123;   <span class="comment">// 相同为0，相反为1。为1时，进if。此时l1和l2的状态不同，即返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="literal">null</span> ^ r2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue1.offer(l1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue1.offer(r1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue2.offer(l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue2.offer(r2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue1.isEmpty() &amp;&amp; queue2.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六五、反转二叉树"><a href="#六五、反转二叉树" class="headerlink" title="六五、反转二叉树"></a>六五、反转二叉树</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231028090220.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六六、对称二叉树"><a href="#六六、对称二叉树" class="headerlink" title="六六、对称二叉树"></a>六六、对称二叉树</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231028093958.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>可以看成是比较两个二叉树是否对称</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(p);</span><br><span class="line">        queue.offer(q);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            p = queue.poll();</span><br><span class="line">            q = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p.val != q.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(p.left);</span><br><span class="line">            queue.offer(q.right);</span><br><span class="line">            queue.offer(p.right);</span><br><span class="line">            queue.offer(q.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六七、从前序与中序遍历序列构造二叉树"><a href="#六七、从前序与中序遍历序列构造二叉树" class="headerlink" title="*六七、从前序与中序遍历序列构造二叉树"></a>*六七、从前序与中序遍历序列构造二叉树</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231029130356.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>根据前序可以知道根节点，然后可以根据中序确定当前根节点左子树和右子树的数量</strong></font></p>
<p><strong>方法一：</strong></p>
<p>1、遍历中序，将中序的节点信息和对应的下标信息存放在<code>map</code>中；</p>
<p>2、根据前序判断出根节点，然后根据map判断出根节点在中序中的位置，然后根据中序判断出左子树和右子树的节点数目；</p>
<p>3、确定好根节点之后：</p>
<p>​		左子树在<code>preorder</code>中的范围为<code>[pleft+1, pleft+left_size]</code>，右子树在<code>preorder</code>中的范围为<code>[pleft+1+left_size, pright]</code>。pleft+left_size实际上是pleft+1+left_size-1，表示从pleft+1处开始算起，总共有left_size个数。比如从1开始，有5个数，实际上是1、2、3、4、5。所以算术为1+5-1。</p>
<p>​		左子树在<code>inorder</code>中的范围为<code>[ileft, iroot-1]</code>，右子树在<code>inorder</code>中的范围为<code>[iroot+1, iright]</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">root_index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, Integer iLeft,Integer iRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(iLeft &gt; iRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序的第一个节点就是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootNum</span> <span class="operator">=</span> preorder[root_index ++];</span><br><span class="line">        <span class="comment">// 确定中序根节点的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexMap.get(rootNum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到左子树的节点个数</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootNum);</span><br><span class="line">        root.left = build(preorder, inorder, iLeft, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preorder, inorder, index + <span class="number">1</span>, iRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        <span class="comment">// 将中序中的节点信息保存在map中，使能快速定位根节点位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">root_index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, Integer iLeft,Integer iRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(iLeft &gt; iRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序的第一个节点就是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootNum</span> <span class="operator">=</span> preorder[root_index ++];</span><br><span class="line">        <span class="comment">// 确定中序根节点的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexMap.get(rootNum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到左子树的节点个数</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootNum);</span><br><span class="line">        root.left = build(preorder, inorder, iLeft, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preorder, inorder, index + <span class="number">1</span>, iRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        <span class="comment">// 将中序中的节点信息保存在map中，使能快速定位根节点位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六八、从中序与后序遍历序列构造二叉树"><a href="#六八、从中序与后序遍历序列构造二叉树" class="headerlink" title="*六八、从中序与后序遍历序列构造二叉树"></a>*六八、从中序与后序遍历序列构造二叉树</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231030124031.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>后序遍历，最后的节点即是根节点。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Integer post_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder, <span class="type">int</span> iLeft, <span class="type">int</span> iRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(iLeft &gt; iRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootNum</span> <span class="operator">=</span> postorder[post_index --];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootNum);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(rootNum);</span><br><span class="line">        root.right = build(inorder, postorder, index + <span class="number">1</span>, iRight);</span><br><span class="line">        root.left = build(inorder, postorder, iLeft, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        post_index = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> post_index; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, postorder, <span class="number">0</span>, post_index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六九、填充每个节点的下一个右侧节点指针2"><a href="#六九、填充每个节点的下一个右侧节点指针2" class="headerlink" title="*六九、填充每个节点的下一个右侧节点指针2"></a>*六九、填充每个节点的下一个右侧节点指针2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231030152641.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>可以使用一个队列，存储每一层的节点，然后进行指向处理。也可以将每一层当作一个链表，进行指向处理。</strong></font></p>
<p><strong>方法一：使用队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">levels</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span>(levels -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            node.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="literal">null</span>) &#123;</span><br><span class="line">                pre.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = node;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：每一层都作为链表</strong></p>
<p>遍历某一层时，将其下一层的节点进行指向处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur可以看成每一层的链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;  <span class="comment">// 下一层没有节点时，cur = dummy.next会为null</span></span><br><span class="line">        <span class="comment">// 遍历当前层时，将下一层添加一个哑节点，这样遍历下一层时，可以直接cur = dummy.next即可。</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// 遍历当前层</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                pre.next = cur.left;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                pre.next = cur.right;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;   <span class="comment">// 遍历上一层的时候，这一层就已经有指向关系了，所以要判断不同节点的下一层，可以用cur.next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 换到下一层</span></span><br><span class="line">        cur = dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七十、二叉树展开为链表"><a href="#七十、二叉树展开为链表" class="headerlink" title="*七十、二叉树展开为链表"></a>*七十、二叉树展开为链表</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231031121927.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>前序遍历时，最上层根节点的右子树一定会在左子树最后一个右节点的后面。</strong></font></p>
<p><strong>方法一：从头开始遍历，直接移位拼接</strong></p>
<p>1、当前根节点<code>root</code>为<code>cur</code>，其左子树节点为<code>next</code>。</p>
<p>2、存在一个<code>pre</code>节点，使其从当前<code>cur</code>节点的左子树开始，一直找到最底层最右侧的节点。</p>
<p>3、然后将当前<code>cur</code>节点的右子树移到<code>pre</code>节点的后面（右侧），即<code>pre.right = cur.right</code>。</p>
<p>4、将当前<code>cur</code>节点的左子树移到<code>cur</code>右子树的位置。</p>
<p>5、更新<code>cur</code>的节点为其右侧第一个节点（原左侧第一个节点）<code>cur = cur.right</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> next;</span><br><span class="line">            <span class="keyword">while</span>(pre.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.right = cur.right;</span><br><span class="line">            cur.left = <span class="literal">null</span>;</span><br><span class="line">            cur.right = next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用栈</strong></p>
<p>1、当获取到一个节点时，首先将此节点放到前一个节点的右侧，并将上一个节点的左侧置为<code>null</code>。</p>
<p>2、将当前节点的右侧节点先放入栈中，然后再将其左侧节点放入栈中。这样优先弹出的就是左侧节点，满足前序遍历条件。</p>
<p>3、将当前弹出的节点作为前一个节点<code>pre</code>，然后循环如此，直到栈为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.left = <span class="literal">null</span>;</span><br><span class="line">            pre.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// right先入栈，left后入栈。这样弹出时，首先弹出left，并且进行拼接。</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.left, right = node.right;</span><br><span class="line">        <span class="keyword">if</span>(right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七一、路径总和"><a href="#七一、路径总和" class="headerlink" title="七一、路径总和"></a>七一、路径总和</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231101141650.png"></p>
<p><strong>方法一：广度优先搜索</strong></p>
<p>实际始将每个叶子节点存在的路径和都算出来，然后进行比对。</p>
<p>1、使用两个队列，<code>queNode</code>用来保存节点、<code>queVal</code>用来保存节点值。</p>
<p>2、从队列<code>queNode</code>和<code>queVal</code>中弹出一个节点，然后将当前节点的左右节点依次放入队列<code>queNode</code>中，然后将此节点左右节点值和此节点值的和放入队列<code>queVal</code>中。这样我们遍历其左右子节点<code>left</code>和<code>right</code>的时候，就可以直接从<code>queVal</code>中拿到此时<code>left</code>和<code>right</code>的路径和是多少，从而去判断是否满足条件。</p>
<p>3、循环如此，直到队列中弹出的节点没有了左右节点，这个时候就判断当前节点所对应的值是否符合条件，不符合则继续弹出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queVal = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queNode.offer(root);</span><br><span class="line">    queVal.offer(root.val);</span><br><span class="line">    <span class="keyword">while</span>(!queNode.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queNode.poll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> queVal.poll();</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val == targetSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queNode.offer(node.left);</span><br><span class="line">            queVal.offer(node.left.val + val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queNode.offer(node.right);</span><br><span class="line">            queVal.offer(node.right.val + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：递归</strong></p>
<p>每递归一个节点的时候，就将<code>sum - val</code>的值传递给下一次递归，如果其子节点都为空的时候，就可以直接判断当前节点的值<code>val</code>和<code>sum</code>是否相等，判断左右子树有一方成立即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetSum == root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七二、求根节点到叶子节点数字之和"><a href="#七二、求根节点到叶子节点数字之和" class="headerlink" title="*七二、求根节点到叶子节点数字之和"></a>*七二、求根节点到叶子节点数字之和</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231102102151.png"></p>
<p><strong>方法一：广度优先搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queVal = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queNode.offer(root);</span><br><span class="line">    queVal.offer(root.val);</span><br><span class="line">    <span class="keyword">while</span>(!queNode.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queNode.poll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> queVal.poll();</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            res += val;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queNode.offer(node.left);</span><br><span class="line">            queVal.offer(val * <span class="number">10</span> + node.left.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queNode.offer(node.right);</span><br><span class="line">            queVal.offer(val * <span class="number">10</span> + node.right.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：深度优先搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sumTree(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumTree</span><span class="params">(TreeNode node, <span class="type">int</span> res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * <span class="number">10</span> + node.val;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sumTree(node.left, res) + sumTree(node.right, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七三、二叉树中的最大路径和"><a href="#七三、二叉树中的最大路径和" class="headerlink" title="**七三、二叉树中的最大路径和"></a>**七三、二叉树中的最大路径和</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231104143933.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231104144011.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>就是计算每一层的最大路径，然后再取最大值。若左侧为负数，则抛弃左边。右侧为负数，则抛弃右边。根节点为负数，则比较左边和右边的大小。然而，计算每一层的最大路径，需要知道左右节点的最大贡献值，最大贡献值只能是左右节点数的一半的最大路径，比如20+15和20+7比较大小，取最大值。因为计算路劲和不能重复经过某个节点。</strong></font></p>
<p>若树只有一层，那么最大路径就可以看成是<strong>左-&gt;根-&gt;右</strong>之和（若有一个不大于0，则可以不用计算）。</p>
<p>比如<code>15-&gt;20-&gt;7</code>。</p>
<p>若树有多层，除开最上层的树，那么我们就只能用到每一层树的一半路径大小，而不能去使用每层树的全路径。</p>
<p>比如<code>10-&gt;20-&gt;15</code>或<code>10-&gt;20-&gt;7</code>，而不是<code>10-&gt;20-&gt;15-&gt;20-&gt;7</code>。</p>
<p>如此，便可以知道，需要计算每层树的根节点的最大贡献值，即一半树的最大路径大小（若这个数为负数，则可以不计算这个根节点产生的贡献值，将此根节点排除在外，即当 0 处理）。也就是说：</p>
<p>每一层树的每一个节点的最大贡献值为<code>root.val + Math.max(leftGain, rightGain)</code>；</p>
<p>每一层树的最大路径和为<code>root.val + leftGain + rightGain</code>。</p>
<p>可能多层树的最大路径和还没有某一层的路径和大，所以需要每计算出一层最大路径和之后，和先前计算的路径和比较，取最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树的最大贡献值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftGain</span> <span class="operator">=</span> Math.max(maxGain(root.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightGain</span> <span class="operator">=</span> Math.max(maxGain(root.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的最大路径和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curMaxSum</span> <span class="operator">=</span> root.val + leftGain + rightGain;</span><br><span class="line">        maxSum = Math.max(maxSum, curMaxSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七四、二叉搜索树迭代器"><a href="#七四、二叉搜索树迭代器" class="headerlink" title="*七四、二叉搜索树迭代器"></a>*七四、二叉搜索树迭代器</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231105104008.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231105104111.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>可使用递归或迭代的方式中序遍历二叉树，从而 next( ) 中去输出值</strong></font></p>
<p><strong>方法一：递归、使用list按照中序遍历的先后顺序存储二叉树的节点值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idx;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        inorderTraversal(root, arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.get(idx ++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt; arr.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorderTraversal(root.left, arr);</span><br><span class="line">        arr.add(root.val);</span><br><span class="line">        inorderTraversal(root.right, arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：迭代、使用栈维护二叉树的中序遍历节点即可</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode cur;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        cur = root;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();   <span class="comment">// 按照 (左-&gt;中-&gt;右) 弹出，然后返回。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(cur == <span class="literal">null</span> &amp;&amp; stack.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七五、二叉树的最近公共祖先"><a href="#七五、二叉树的最近公共祖先" class="headerlink" title="*七五、二叉树的最近公共祖先"></a>*七五、二叉树的最近公共祖先</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231106133841.png"></p>
<p><strong>方法一：递归</strong></p>
<p>判断每个节点的左子树和右子树是否存在p或者q，或者当前节点和p或者q相等。若满足其中任意一项则返回true，表示从p或者q开始往上走，会经历当前节点。其判断条件为 <code>left || right || (root.val == p.val || root.val == q.val)</code>。</p>
<p>从p和q往上走的树路径中，刚开始相交的那个节点，即为最近公共祖先。可以看作是，从一个节点开始，p和q分别在其左子树或右子树当中，或者这个节点和p或q重合且p或q在其任意一条子树上。</p>
<p>比如：有个节点node，p在其左子树上，q在其右子树上，此时node就是p和q的最近公共祖先。又或者有个节点node，它和p重叠，q在其左子树或右子树上，此时node也是p和q的最近公共祖先。</p>
<p>判断条件为 <code>(left &amp;&amp; right) || ((root.val == p.val || root.val == q.val) &amp;&amp; (left || right))</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left, p, q);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>((left &amp;&amp; right) || ((root.val == p.val || root.val == q.val) &amp;&amp; (left || right))) &#123;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left || right || (root.val == p.val || root.val == q.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：存储父节点</strong></p>
<p>将二叉树的每个节点按照 <code>(self，parent)</code> 存储起来。然后从 <code>p</code> 节点开始，将值存放在Set集合中，并且将 <code>p.parent</code> 重新赋值给 <code>p</code>，循环将值放入Set集合中，直到 <code>p</code> 为空为止。<code>p.parent</code> 其实就是使用 <code>map.get(p.val)</code> 即可。然后，判断Set集合中是否包含了<code>q.val</code>，如果包含，则此时的 <code>q</code> 就是最近公共祖先。若不包含，则将 <code>q.parent</code> 重新赋值给 <code>q</code>，循环判断，直到 <code>q</code> 为空为止。若始终没有，则 <code>p</code> 和 <code>q</code> 没有最近公共祖先。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, TreeNode&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            parent.put(root.left.val, root);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            parent.put(root.right.val, root);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">            visited.add(p.val);</span><br><span class="line">            p = parent.get(p.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(q.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            q = parent.get(q.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七六、二叉树的右视图"><a href="#七六、二叉树的右视图" class="headerlink" title="*七六、二叉树的右视图"></a>*七六、二叉树的右视图</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231107105619.png"></p>
<p><font color=red><strong>思路：</strong></font><font color = blue><strong>遍历到每一层时，每一层最右侧节点即为需要打印的节点</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> TreeNode node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">                <span class="keyword">while</span>(size -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    node = queue.poll();     <span class="comment">// node最后肯定是这一层最右侧的节点</span></span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                        queue.offer(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                        queue.offer(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七七、二叉树的层平均值"><a href="#七七、二叉树的层平均值" class="headerlink" title="七七、二叉树的层平均值"></a>七七、二叉树的层平均值</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231108140250.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sum / size);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七八、二叉树的层序遍历"><a href="#七八、二叉树的层序遍历" class="headerlink" title="*七八、二叉树的层序遍历"></a>*七八、二叉树的层序遍历</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231109123958.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                ls.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(ls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七九、二叉树的锯齿形层序遍历"><a href="#七九、二叉树的锯齿形层序遍历" class="headerlink" title="*七九、二叉树的锯齿形层序遍历"></a>*七九、二叉树的锯齿形层序遍历</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231109131831.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231109131813.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; ls = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(order) &#123;</span><br><span class="line">                    ls.offerLast(node.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ls.offerFirst(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            order = !order;</span><br><span class="line">            res.add((LinkedList&lt;Integer&gt;)ls);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八十、二叉搜索树的最小绝对值"><a href="#八十、二叉搜索树的最小绝对值" class="headerlink" title="八十、二叉搜索树的最小绝对值"></a>八十、二叉搜索树的最小绝对值</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231110091524.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231110091544.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>二叉搜索树的特性为：树在中序遍历的时候，是升序的。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != -<span class="number">1</span>) &#123;</span><br><span class="line">            min = Math.min(min, root.val - pre);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八一、二叉搜索树中的第k小的元素"><a href="#八一、二叉搜索树中的第k小的元素" class="headerlink" title="*八一、二叉搜索树中的第k小的元素"></a>*八一、二叉搜索树中的第k小的元素</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231110093607.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231110093627.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>中序遍历的时候，到第k个为止即可。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!(root == <span class="literal">null</span> &amp;&amp; stack.isEmpty())) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        k --;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八二、验证二叉搜索树"><a href="#八二、验证二叉搜索树" class="headerlink" title="*八二、验证二叉搜索树"></a>*八二、验证二叉搜索树</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231110101026.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231110101120.png"></p>
<p><strong>方法一：中序遍历的时候，保存前一个值，然后进行比对</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> -Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!(root == <span class="literal">null</span> &amp;&amp; stack.isEmpty())) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= res) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = root.val;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：递归，左侧树一定在(Long.MIN_VALUE，root.val)之间，右侧树一定在(root.val，Long.MAX_VALUE)之间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, <span class="type">long</span> lower, <span class="type">long</span> upper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= lower || root.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, lower, root.val) &amp;&amp; isValidBST(root.right, root.val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八三、岛屿数量"><a href="#八三、岛屿数量" class="headerlink" title="*八三、岛屿数量"></a>*八三、岛屿数量</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231111105836.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231111105854.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>对于图来说，我们只需要深度遍历每个陆地节点相邻的陆地节点即可，若超出范围或遍历到海洋节点时，这一条深度遍历停止。</strong></font></p>
<p>图的深度遍历相当于是四叉树，如下图：</p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/63f5803e9452ccecf92fa64f54c887ed0e4e4c3434b9fb246bf2b410e4424555.jpg"></p>
<p>因此，我们可以得到图的遍历的框架代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是图在如此进行深度遍历的时候，会有可能导致重复遍历，因此我们需要将已经遍历过的陆地节点换成其他的标识。如下图：</p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20fe202fb5e5fc5048e140c29310c1bcbb17661860d2441e8a3feb1236a2e44d.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">// 将格子标记为「已遍历过」</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，此题题解为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid, r, c)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &gt;=<span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; grid.length; r ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八四、被围绕的区域"><a href="#八四、被围绕的区域" class="headerlink" title="*八四、被围绕的区域"></a>*八四、被围绕的区域</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231111114935.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将边缘的 O 替换成 A ，然后再将剩下的 O 替换成 X 后，再将 A 替换成 O。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= board.length || y &gt;= board[<span class="number">0</span>].length || board[x][y] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="literal">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 替换第一列和最后一列，或者是与第一列和最后一列相邻的都被替换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i ++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, c - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一列和最后一列已经被替换，所以此时只需要遍历剩下的列，然后将第一行和最后一行替换即可。同样相邻的也被替换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; c - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, r - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八五、克隆图"><a href="#八五、克隆图" class="headerlink" title="*八五、克隆图"></a>*八五、克隆图</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231112102858.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>无论是DFS还是BFS，都可以使用一个map去存储哪些节点已经被拷贝过了，若没有拷贝则拷贝后放到map中，拷贝过的直接从map中取出拷贝的值。</strong></font></p>
<p><strong>方法一：DFS</strong></p>
<p>判断当前节点是否有过拷贝，有则直接返回拷贝节点，若没有则进行拷贝后放入map中。然后再将其邻居节点也作如此判断。递归函数的返回值一直都是进入该递归节点的拷贝值，返回出去后给上一步递归节点使用。因为当前进入递归的节点是上一步递归节点的邻居节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若节点已经存在拷贝，则直接返回拷贝节点</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若没有拷贝，则将节点进行拷贝，并且存放到map中</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cloneNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        map.put(node, cloneNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前节点的所有邻接点，将邻接点进行拷贝后，与当前节点的拷贝节点关联起来</span></span><br><span class="line">        <span class="keyword">for</span>(Node neighbor : node.neighbors) &#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：BFS</strong></p>
<p>1、将开头的节点进行拷贝，并将拷贝信息存放到map中（表示当前节点已经拷贝），将自己放入到queue中（表示还要去检查当前节点的邻居节点）。</p>
<p>2、从队列中弹出节点，判断其邻居节点是否有被拷贝，没有拷贝则说明当前节点没有做过处理，需要将此节点放入队列中，并将其拷贝后放入map中。</p>
<p>3、将弹出节点的拷贝几点，与邻居节点的拷贝节点相互关联起来，至此一个节点的深拷贝完成。循环如此，直到队列为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存放拷贝节点</span></span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将开头的节点放入队列中</span></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(node);</span><br><span class="line">    <span class="comment">// 拷贝</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cloneNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    map.put(node, cloneNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 弹出队列节点，将其邻居节点全部进行拷贝</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(Node neighbor : n.neighbors) &#123;</span><br><span class="line">            <span class="comment">// 判断邻居是否在map中，没有则拷贝，有则直接取出</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(neighbor)) &#123;</span><br><span class="line">                <span class="comment">// 不存在则说明当前邻居节点还没做过处理</span></span><br><span class="line">                queue.offer(neighbor);</span><br><span class="line">                map.put(neighbor, <span class="keyword">new</span> <span class="title class_">Node</span>(neighbor.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(n).neighbors.add(map.get(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八六、课程表"><a href="#八六、课程表" class="headerlink" title="*八六、课程表"></a>*八六、课程表</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231113134755.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231113134818.png"></p>
<p><strong>方法一：DFS</strong></p>
<p>1、我们将学习课程的先后顺序关系保存起来，比如<code>prerequisites = [[1,0],[2,0],[3,0],[0,4]]</code>，根据以上课程信息我们可以知道，要想学习课程1&#x2F;2&#x2F;3，就要先学课程0。所以，我们将先要学习的课程作为下标，后要学习的课程作为当前下标存储的数组值，即将课程学习的先后顺序保存为<code>edge = [[1,2,3],[],[],[],[0]]</code>（当然，也可以保存为<code>edge = [[4],[0],[0],[0],[]]</code>，表示要想学课程0的时候，必须先学课程4，想要学课程1&#x2F;2&#x2F;3时，必须先学课程0。用此方法存储，更加符合题干的先后学习顺序，更容易理解。但是对于BFS来说，用此方法存储，不适合更方便的获取入度，并对入度进行更改）。</p>
<p>2、我们给每一个课程都设置三个状态值，0表示还未搜索、1表示正在搜索、2表示搜索完成。使用<code>visited[edge.size()]</code>来保存每个课程的状态（edge的下标值才是课程）。</p>
<p><strong>搜索过程为：</strong></p>
<p>先从<code>edge</code>的第一个课程开始，即<code>下标为0</code>的课程，并且将<code>visited[0]</code>的值设置为<code>1</code>，表示正在检索<code>课程0</code>。此时可以发现学习完<code>课程0</code>之后，还有三个课程要去学习，即<code>edge.get(0) = [1,2,3]</code>，这三个课程。因此，需要去递归<code>课程1/2/3</code>。<code>课程1/2/3</code>没有后续课程需要学习，所以搜索<code>课程1/2/3</code>之后，直接将其状态值改为<code>2</code>。此时<code>课程0</code>的后续课程都已经学完，没有了其他的后续课程，所以此时<code>课程0</code>的状态也要置为<code>2</code>。直到将<code>edge</code>遍历完。如果中途递归遍历后续课程的时候，发现此课程的状态为<code>1</code>，就说明形成了环，此时直接返回false即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;  <span class="comment">// 用来存放某个节点在多少个节点之前</span></span><br><span class="line">    <span class="type">int</span>[] visited;  <span class="comment">// 用来表示某个节点是否已经被搜索</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i ++) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 搜索当前这个节点</span></span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点置为1，表示正在搜索</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索与其关联的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : edges.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="comment">// 若经过某一结点时，形成了环，也就是经过的那个节点正在遍历，则直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：BFS</strong></p>
<p>1、同样将课程信息先后顺序保存为<code>edge = [[1,2,3],[],[],[],[0]]</code>。但是，在保存的时候也需要保存课程的<code>入度</code>，即学习此课程之前，还需要学习多少个与其相邻的课程。比如<code>edge</code>中课程的入度分别为<code>indge = [1,1,1,1,0]</code>，解释为，学习<code>课程0</code>之前，还需要学习<code>课程4</code>，因此<code>课程0的入度为1</code>。学习<code>课程1/2/3</code>之前，分别也都只需要学习<code>课程0</code>，所以<code>课程1/2/3的入度分别都为1</code>。学习<code>课程4</code>之前没有别的课程需要学习，所以<code>课程4的入度为0</code>。</p>
<p>2、使用<code>visited</code>，保存我们已经检索过的课程数量，也是放入过<code>queue</code>的节点的总个数。我们从<code>入度为0</code>的课程开始，将其放入<code>queue</code>中。表示学习完这个课程之后，哪些课程可以开始学习了。比如先学习<code>课程4</code>，此时<code>课程0</code>（<code>edge.get(4) = 0</code>）<code>入度就可以-1</code>，<code>课程0</code>离可以学习更近了一步。如果此时<code>课程0的入度成为了0</code>，那么<code>课程0</code>也可以放入<code>queue</code>了，表示<code>课程1/2/3</code>（<code>edge.get(0) = [1,2,3]</code>）入度也要-1，<code>课程1/2/3</code>离学习也更近了一步。当我们从<code>queue</code>中弹出学习的课程的时候，<code>visited</code>要+1。直到<code>queue</code>为空，此时<code>visited</code>和课程数量相等则说明没有成环，返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;  <span class="comment">// 用来存放某个节点在多少个节点之前</span></span><br><span class="line">    <span class="type">int</span>[] indeg;  <span class="comment">// 用来表示某个节点的入度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i ++) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];  <span class="comment">// 后学习的课程入度+1，再此之前要学习info[1]。</span></span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">visited</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            visited ++;    <span class="comment">// 检索的元素多了一个</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v : edges.get(u)) &#123;</span><br><span class="line">                indeg[v] --;   <span class="comment">// 挡在我前面的u学了，我离可以学习又进了一步</span></span><br><span class="line">                <span class="keyword">if</span>(indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八七、课程表2"><a href="#八七、课程表2" class="headerlink" title="*八七、课程表2"></a>*八七、课程表2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231114120644.png"></p>
<p><strong>方法一：DFS</strong></p>
<p>使用DFS时，后学的先递归完成，所以需要将<code>index --</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 栈下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = numCourses - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：BFS</strong></p>
<p>使用BFS时，先学的先遍历完成，所以<code>index ++</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="type">int</span>[] indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 答案下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result[index++] = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div>

<!-- post-guide -->

    <div class="post-guide">
        <div class="item left">
            
              <a href="/2023/10/18/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  面试总结
              </a>
            
        </div>
        <div class="item right">
            
        </div>
    </div>


<!-- comment - giscus -->


<!-- comment - valine -->


<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©<span id="footerYear-start"></span>-<span id="footerYear-end"></span>

	
	    <a href="/">jiakuan.chen</a>
	
	
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//wujun.me" target="_blank">Wu Jun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>


<script type="text/javascript">
	document.getElementById('footerYear-start').innerHTML = new Date().getFullYear() + '';
</script>

<script type="text/javascript">
	document.getElementById('footerYear-end').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>