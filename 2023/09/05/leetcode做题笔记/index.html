<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		leetcode做题笔记 | 
	 
	BIGKEL BLOB
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/bigkel.png">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "kw520.github.io";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>


	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.5.1/dist/Valine.min.js"></script>

	
	

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="BIGKEL BLOB" type="application/atom+xml">
</head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">BIGKEL BLOB</a>

	<ul id="menu">
    

    

    

    
  
    
      <li class="menu-item">
        <a href='https://github.com/kw520' class="menu-item-link" target="_blank">
          <i class="fa fa-github fa-2x"></i>
        </a>
      </li>
    
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="file active">
									<a href="/2023/09/05/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/">
                     
										    leetcode做题笔记
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">
	leetcode做题笔记
</h1>

<!-- meta -->
<div class="article-meta">
	

	<span>jiakuan.chen</span>
	<span>2023-09-05 18:56:11</span>

  <div id="article-categories">
    
		  <span>Categories：</span>
      
    

    
		    <span>Tags：</span>
        
    
  </div>

</div>

<!-- content -->
<div id="article-content">
	<h1 id="一、合并两个有序数组"><a href="#一、合并两个有序数组" class="headerlink" title="一、合并两个有序数组"></a>一、<strong>合并两个有序数组</strong></h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/clipboard.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>从原始nums1和nums2的末尾开始比较，不比nums2小的数往nums1的后面放，若一方遍历完，则另一方继续遍历直到结束。</strong></font></p>
<p>三个指针，分别为	 int one &#x3D; m - 1;</p>
<p>​    	    						int two &#x3D; n - 1;</p>
<p>​    	    						int tail &#x3D; m + n - 1;</p>
<p>若one &#x3D;&#x3D; -1，则nums1[tail] &#x3D; nums2[two]，且two–，tail–；</p>
<p>反之若two &#x3D;&#x3D; -1，则nums1[tail] &#x3D; nums1[one]，且one–，tail–；</p>
<p>反之若nums1[one] &gt;&#x3D; nums2[two]，则nums1[tail] &#x3D; nums1[one]，且one–，tail–；</p>
<p>反之，则nums1[tail] &#x3D;  nums2[two]，且two–，tail–；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(one &gt; -<span class="number">1</span> || two &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(one == -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums2[two];</span><br><span class="line">            two --;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(two == -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums1[one];</span><br><span class="line">            one --;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[one] &gt;= nums2[two]) &#123;</span><br><span class="line">            cur = nums1[one];</span><br><span class="line">            one --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[two];</span><br><span class="line">            two --;</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail] = cur;</span><br><span class="line">        tail --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二、移除元素"><a href="#二、移除元素" class="headerlink" title="二、移除元素"></a><strong>二、移除元素</strong></h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/remove.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p>​		<strong>方法一、双指针，都从头开始，R指针若不等于val，则赋值给L后，L和R同时右移，若等于，则L不动，R右移寻找不等于val的值赋值给L</strong></p>
<p>​		<font color=blue>**方法二、双指针，L指向头，R指向尾，L &lt; R，若L指针不等于val，则右移，若等于val，则R指针值赋值给L指针，R指针左移，一直循环。**</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、删除有序数组中的重复项"><a href="#三、删除有序数组中的重复项" class="headerlink" title="三、删除有序数组中的重复项"></a>三、删除有序数组中的重复项</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230905200311.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针p指向第一个数，指针q指向第二个数，如果两个值相等，则q++。如果不相等，当q - p &gt; 1时（避免0，1，2，3，4这种极端情况，表示当p和q不相邻时，才用调换值，避免自己和自己调换），调换q和p+1的值，且p++， q++。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[q] != nums[p]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q - p &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                nums[p + <span class="number">1</span>] = nums[q];</span><br><span class="line">            &#125;</span><br><span class="line">            p ++;</span><br><span class="line">        &#125;</span><br><span class="line">        q ++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四、有序数组中只能重复两次"><a href="#四、有序数组中只能重复两次" class="headerlink" title="*四、有序数组中只能重复两次"></a>*四、有序数组中只能重复两次</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906181755.png"></p>
<p><font color=red><strong>思路：</strong></font><strong>指针slow、fast都指向下标为2的位置</strong></p>
<p>​		<font color=blue><strong>若fast &#x3D;&#x3D; slow[n-2]，由于slow[n]之前已经是整理好后的，并且数组有序，那么slow[n-1]不可能比slow[n-2]小，也不可能比fast大，所以此时必然有fast &#x3D;&#x3D; slow[n-2] &#x3D;&#x3D; slow[n-1]，则需要fast右移找到不等于slow[n-2]的值赋值给slow[n]（若fast找到的值和slow当前值相等，则可以不用赋值），然后slow和fast同时右移。</strong></font></p>
<p>​		<font color=blue>**若fast !&#x3D; slow[n-2]，则说明slow[n]之前排好序的slow[n-2] &lt; slow[n-1]，那么此时fast的值可以给slow[n]**</font></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906190249.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != nums[slow -<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            slow ++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、多数元素"><a href="#五、多数元素" class="headerlink" title="五、多数元素"></a>五、多数元素</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906203706.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p>​		<strong>方法一、排序，多数元素一定占据n&#x2F;2的位置。</strong></p>
<p>​		<font color=blue><strong>方法二、排序，p、q指针从0开始，若q &#x3D;&#x3D; p，则q向右遍历，若q !&#x3D; p，则q-1-p+1为当前数的个数，若此个数大于n&#x2F;2，则返回nums[p]，反之则p &#x3D; q，继续向后遍历，直到q &gt;&#x3D; n为止</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[p] == nums[q]) &#123;</span><br><span class="line">            q ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(q - p &gt; more)&#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六、轮转数组"><a href="#六、轮转数组" class="headerlink" title="*六、轮转数组"></a>*六、轮转数组</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230907184201.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>实际轮转次数 k &#x3D; k – 整数*n，比如n &#x3D; 5，轮转6次，那么实际次数为1，n &#x3D; 5，轮转2次，实际次数为2。将nums全部反转，然后根据实际轮转次数分割，[0, k - 1] 和 [k, n - 1]再各自反转。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    swap(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    swap(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    swap(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        nums[start] = nums[start] ^ nums[end];</span><br><span class="line">        nums[end] = nums[start] ^ nums[end];</span><br><span class="line">        nums[start] = nums[start] ^ nums[end];</span><br><span class="line">        start ++;</span><br><span class="line">        end --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七、买卖股票最佳时机"><a href="#七、买卖股票最佳时机" class="headerlink" title="七、买卖股票最佳时机"></a>七、买卖股票最佳时机</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230907203725.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针p和q分别指向0和1，记录最大利润max &#x3D; 0，q向后移动，若 q - p &lt; 0，则后面的数字在和q求差时一定比和p求差时大，说明 q 点买进的利润一定大于当前 p 点买进的利润，所以 p 点重新定位，p &#x3D; q。若 q - p &gt; 0，则判断利润是否比之前的利润 max 大，大则覆盖。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; prices.length) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> prices[q] - prices[p];</span><br><span class="line">        <span class="keyword">if</span>(money &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = money &gt; max ? money : max;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        q ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八、买卖股票最佳时机2"><a href="#八、买卖股票最佳时机2" class="headerlink" title="*八、买卖股票最佳时机2"></a>*八、买卖股票最佳时机2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909101503.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p><font color=red><strong>方法一：</strong></font><strong>动态规划</strong>    <font color=blue><strong>时间复杂度O(n)，空间复杂度O(n)</strong></font></p>
<p>​		每天手里股票的状态有两种，<code>dp[i,0]</code>表示第 <code>i</code> 天未持有股票，<code>dp[i,1]</code>表示第 <code>i</code> 天持有股票。</p>
<p>​		<code>dp[i,0]</code>的时候，可以看作是 <code>i-1</code> 天已经卖出了股票，<code>i</code> 天还没有买进，即<code>dp[i-1,0]</code>。或者是 <code>i-1</code> 天买进了股票，<code>i</code> 天卖出，即<code>dp[i-1,1] + price[i]</code>。所以 <code>i</code> 天最大的利润可以可以列出如下转换方程：</p>
<p><strong>dp[i,0] &#x3D; max{dp[i-1,0], dp[i-1,1]+price[i]}</strong></p>
<p>​		<code>dp[i,1]</code>的时候，可以看作是 <code>i-1</code> 天买入了股票，<code>i</code> 天还没有卖出，即<code>dp[i-1,1]</code>。或者是 <code>i-1</code> 天卖出了股票，<code>i</code> 天买入，即<code>dp[i-1,0] - price[i]</code>。所以 <code>i</code> 天最大的利润可以列出如下转换方程：</p>
<p><strong>dp[i,1] &#x3D; max{dp[i-1,1], dp[i-1,0]-price[i]}</strong></p>
<p>​		到最后一天的时候，卖出股票肯定要比买入股票利润高，所以只用返回<code>dp[n,0]</code>即可。(空间优化) 由于当天的最大利润只与前一天有关，并且每天只有0、1两种状态，那么可以只用<code>dp0</code>表示当天未持有股票状态，<code>dp1</code>表示当天持有股票状态，每过一天用最新值覆盖<code>dp0、dp1</code>即可。那么到了最后一天的最大利润可以用<code>dp0</code>表示即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp0 = Math.max(dp0, dp1+prices[i]);</span><br><span class="line">        dp1 = Math.max(dp1, dp0-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p><font color=red><strong>方法二：</strong></font><strong>贪心算法</strong>    <font color=blue><strong>时间复杂度O(n)，空间复杂度O(1)</strong></font></p>
<p>​		买入股票的最大利润，其实就是每相邻两天利润差大于0的和。比如1，4，3，12这一组数，我们只要避开两个产生负数的数，即可保证利润最大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max += Math.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="九、跳跃游戏"><a href="#九、跳跃游戏" class="headerlink" title="*九、跳跃游戏"></a>*九、跳跃游戏</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909143444.png"></p>
<p><font color=red><strong>思路：</strong></font><strong>贪心算法</strong>   <font color=blue><strong>时间复杂度O(n)，空间复杂度O(1)。</strong></font></p>
<p>​		存在可到达的最大的位置maxend，判断当前位置是否小于maxend。</p>
<p>​		若小于，则说明存在步数可以到达此位置</p>
<p>​					判断此位置可跳跃到的位置是否大于maxend。</p>
<p>​					若大于，则更新maxend，反之继续遍历。</p>
<p>​		若大于，则说明当前位置不存在步数可以到达，直接返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxend</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; maxend) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxend = Math.max(maxend, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十、跳跃游戏2"><a href="#十、跳跃游戏2" class="headerlink" title="*十、跳跃游戏2"></a>*十、跳跃游戏2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909165449.png"></p>
<p><strong><font color=red>思路：</font>贪心算法   <font color=blue>时间复杂度O(n)，空间复杂度O(1)。</font></strong></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909170300.png">		</p>
<p>​		从<code>下标0</code>开始遍历，其能够走到的最远的距离是走到<code>下标2</code>，此时记录<code>max = 2，end = 2，step = 1</code>。遍历到<code>下标1</code>的时候，发现<code>下标1</code>最大能走到<code>下标4</code>，此时更新<code>max = 4</code>，但是不能更新<code>end</code>，因为上一步的<code>end</code>还没走完，需要走完上一步的<code>end</code>之后，才能确定下一步需要走到哪里。遍历到<code>下标2</code>的时候，发现<code>下标2</code>最大只能走到<code>下标3</code>，小于<code>max</code>，此时<code>end</code>已经走完，确定了<code>max = 4</code>，重新设置<code>end = 4</code>，<code>step ++</code>。此处就可以确定是使用<code>下标1</code>的时候，这步能够走到最远为<code>下标4</code>。依次遍历，由于我们当前代码设定<code>step</code>的自增是在起点时自增，而不是走完后自增，所以为了避免最后一步刚好是在数组的最后一个数时，导致程序又把最后一个数当成是起点，所以这里让数组的界限设置为<code>nums.length - 1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        max = Math.max(nums[i] + i, max);   <span class="comment">// 持续更新跳跃的最大点，结算时确定下次要跳的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i == end) &#123;   <span class="comment">// 已经遍历到了上一次起跳的最大位置的终点（结算）</span></span><br><span class="line">            end = max;   <span class="comment">// 设置下次需要跳到的位置的终点</span></span><br><span class="line">            step ++;     <span class="comment">// 跳动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十一、O-1-插入、删除、随机获取"><a href="#十一、O-1-插入、删除、随机获取" class="headerlink" title="*十一、O(1)插入、删除、随机获取"></a>*十一、O(1)插入、删除、随机获取</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230911152620.png"></p>
<p><font color=red><strong>思路</strong></font>：<font color=blue><strong>变长数组无法解决插入和删除时间复杂度为O(1)，哈希表无法解决获取随机数时间复杂度为O(1)。所以使用变长数组 + 哈希表</strong></font></p>
<p>操作插入时，首先判断<code>val</code>是否存在哈希表中，如果存在，则返回<code>false</code>，如果不存在，则插入<code>val</code>。操作如下：</p>
<p>​		1、在变长数组末尾加入<code>val</code></p>
<p>​		2、将加入后的<code>(val, index)</code>放入哈希表，返回<code>true</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.add(val);</span><br><span class="line">    map.put(val, nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作删除时，首先判断<code>val</code>是否存在哈希表中，如果不存在，则返回<code>false</code>，如果存在，则操作如下：</p>
<p>​		1、在哈希表中，获取要删除的值<code>val</code>的下标<code>index</code>。</p>
<p>​		2、将变长数组中的最后一个数<code>end</code>，放入下标为<code>index</code>中，并将这个数的<code>(end, index)</code>在哈希表中更新。</p>
<p>​		2、删除变长数组中的最后一个数<code>end</code>，删除哈希表中<code>key</code>为<code>val</code>的键值对。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.containsKey(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(val);   </span><br><span class="line">    nums.set(index, end);</span><br><span class="line">    map.put(end, index);</span><br><span class="line">    nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">    map.remove(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十二、除自身以外数组的乘积"><a href="#十二、除自身以外数组的乘积" class="headerlink" title="*十二、除自身以外数组的乘积"></a>*十二、除自身以外数组的乘积</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230912162504.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将当前数组每个节点的左侧乘积和右侧乘积单独算出来，然后一一对应相乘。下标0的左侧乘积为 1，下标n的右侧乘积为 1</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        answer[i] = answer[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];      <span class="comment">// 首先存放每个节点的左侧乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        answer[j] = answer[j] * R;</span><br><span class="line">        R = R * nums[j];                              <span class="comment">// 下一个节点的右侧乘积 = 当前节点 * 当前节点右侧乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十三、加油站"><a href="#十三、加油站" class="headerlink" title="*十三、加油站"></a>*十三、加油站</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230913185934.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue> <strong>无论从哪个点开始，只要总油量大于总耗油量（即剩余油量大于 0），就肯定可以跑完一圈，所以使用sum记录剩余油量，如果从当前点出发的总剩余油量（sum）小于上一步到达当前点的总剩余油量（sum），则从当前点出发无法到达下一步，则存储下一步的坐标表示当前点无法作为起点，下一步作为起点。依次循环，直到遍历结束</strong></font></p>
<p><code>sum</code>记录着每一步的剩余油量的总和，即使走到<code>下标4</code>，需要去判断其是否能走一圈，也需要用到前面三个点的剩余油量，<code>sum</code>又有记录，所以可以直接将<code>下标4</code>的剩余油量和<code>sum</code>相加。</p>
<p>例如：若<code>下标3</code>能够到达<code>下标4</code>，那么<code>for</code>中的<code>if</code>不会进入，<code>idx</code>还是保留着（从<code>下标2</code>开始走时，无法走到<code>下标3</code>，<code>idx</code>始终保留无法到达下一步坐标的当前点的下一步的坐标，这样才能确定是从哪一步开始可以到达下一步从而绕一圈的）<code>下标3</code>。如果当前剩余油量+之前剩余总油量（sum）小于0，则说明，无法绕一圈。反之，则可以绕一圈，且起点为<code>idx</code>（即使下标1无法到达下标2，下标2无法到达下标3，但是下标3可以到达下标4，且到达之后的剩余油量可以弥补之前的空缺，那么就可绕一圈，且起点为下标3）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(gas == <span class="literal">null</span> || cost == <span class="literal">null</span> || gas.length == <span class="number">0</span> || cost.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">        sum += gas[i] - cost[i];       <span class="comment">// 总的剩余油量</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; min) &#123;                <span class="comment">// 判断当前总剩余油量和上一次总剩余油量的大小，若小于，则说明当前点不能到达下一点</span></span><br><span class="line">            min = sum;                 <span class="comment">// 更新总的剩余油量</span></span><br><span class="line">            idx = i + <span class="number">1</span>;			   <span class="comment">// 保存当前点的下一点为idx，若循环不再进来，则说明可以从idx出发到达下一步</span></span><br><span class="line">        &#125;							   <span class="comment">// 当前循环进if，说明无法到达下一步，又能够到达下一步的不会进来，所以idx使用i+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &lt; <span class="number">0</span> ? -<span class="number">1</span> : idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十四、分发糖果"><a href="#十四、分发糖果" class="headerlink" title="**十四、分发糖果"></a>**十四、分发糖果</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230914200424.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p><strong>情况1：先升序，后降序。</strong>此时第一个人肯定会有一颗糖，记录pre &#x3D; 1，在升序部分，后面每一步都作pre +&#x3D; 1，记录升序的数量inc（到达最高点时，也会将最高点算到inc中，但是降序时，最高点也要算到降序部分，但是降序部分没法从最高点开始算起，只能遍历到最高点的后一个点时，才会知晓数组开始降序，所以降序会有特殊处理，后面会用降序的数量和其比较）。开始降序时，使用dec表示降序的数量（如果前一个值是最高点，后一个值开始降序，那么dec只是从后一个值开始算起降序的数量，其实最高点也要算是降序的一部分，当dec和inc相等时，说明降序部分肯定超过升序部分了，所以dec要加上1才能当作总的降序部分，如 1 2 3 4 3 2 1 0。升序部分是 1 2 3 4 inc &#x3D; 4，降序部分是 4 3 2 1 0，但是只有遍历到3时才知道降序开始，dec是从3开始算起 dec &#x3D; 4，但是实际是5，所以当dec &#x3D;&#x3D; inc时，dec需要累加），也可以看作是降序部分，总的应发的糖果数（因为降序是从高点往下，但是dec是从0开始的，所以无法满足dec的每一次累加的值，是降序每个小孩的应发的糖果，只能算是应发的总糖果）。如果dec &#x3D;&#x3D; inc时，降序部分超过了升序部分，dec应当累加。</p>
<p><strong>情况2：先降序，后升序。</strong>开始降序时，无法知晓后一步是否变成升序操作，所以降序的每一步都需要将pre重新置为1，若后一步变成升序，那么后一步的pre就是2，升序部分便可以看作是从这一步开始的。</p>
<p><strong>情况3：先升序，平序，后降序。</strong>由于平序部分没有大小关系，所以从第二个平序数开始，pre可以用最小的数1即可，并且升序数量inc也可以看作是1，然后再按照降序部分的操作计算dec的值即可，如 5 5 3，此时inc为1，dec最开始为1，刚好和inc相等，那么dec需要累加1，因为实际dec是2。</p>
<p><strong>情况4：先降序，平序，后升序。</strong>由于开始降序时，是从1开始计算的，所以降序的最低点就可以看作是1（只不过倒序了而已），平序部分只用给最小数1即可，即pre &#x3D; 1，然后再按照升序的逻辑计算，最后一个平序数当然就可以看作是升序数的起点。</p>
<p><strong>汇总：</strong>整合这4种情况，若数组只有一个数，则只需要返回1，若有两个数，则可以看作是以上四种情况的任何一种情况。使用ret  &#x3D; 1作为结果的初始值，从数组的第二个开始遍历，升序、平序时，ret &#x3D; ret + pre，降序时，ret &#x3D; ret + dec，最后返回ret即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">1</span>, dec = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt;= ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            dec = <span class="number">0</span>;</span><br><span class="line">            pre = ratings[i] == ratings[i - <span class="number">1</span>] ? <span class="number">1</span> : pre + <span class="number">1</span>;</span><br><span class="line">            ret += pre;</span><br><span class="line">            inc = pre;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dec++;</span><br><span class="line">            <span class="keyword">if</span> (dec == inc) &#123;</span><br><span class="line">                dec++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += dec;</span><br><span class="line">            pre = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十五、接雨水"><a href="#十五、接雨水" class="headerlink" title="**十五、接雨水"></a>**十五、接雨水</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230916145358.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p><strong>方法一：动态规划</strong>       <font color=blue><strong>时间复杂度O(n)    空间复杂度O(n)</strong></font></p>
<p>对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。</p>
<p>开始遍历，每到一步都可以得到当前点和最大值的数值差，此时可以看作该点能够接雨水的量。但是当达到最高点后，后面的点肯定相对于最高点来说是降序，因此这些点和最高点之间的差不能当成该点能够接雨水的量。所以我们既要从左往右遍历，也要从右往左遍历，这样，我们就可以得到最高点左侧的准确的接雨水量和最高点右侧的准确的接雨水量。</p>
<p>此时我们既可以根据最高点区分左右侧，然后相加可得到总的能够接雨水量，也可以根据左右分别遍历得到的接雨水量的交集来确定总的接雨水量。</p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] leftMax = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>; left &lt; n; left ++) &#123;</span><br><span class="line">        leftMax[left] = Math.max(leftMax[left - <span class="number">1</span>], height[left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] rightMax = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">2</span>; right &gt;= <span class="number">0</span>; right --) &#123;</span><br><span class="line">        rightMax[right] = Math.max(rightMax[right + <span class="number">1</span>], height[right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        res += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：双指针</strong>           <font color=blue><strong>时间复杂度O(n)    空间复杂度O(1)</strong></font></p>
<p>对于方法一中的左右两边分别遍历，得到总的接雨水量，这样会出现达到最高点之后，后面的操作都是浪费资源的，根本就不用去计算。此时可以优化成双指针，左右两个指针移动时，也记录移动过程中，分别得到的最大值（因为左边指针移动时，只能去根据右边的最大值去比对当前点能否接雨水，比如leftMax &#x3D; 2，rightMax &#x3D; 3，cur &#x3D; 1，此时就可以看作是cur可以接雨水。若rightMax &#x3D; 1，那么cur无法接雨水）左右两个指针总有一个会先走到最高点，走到最高点的指针停止不动，另外一个指针按照当前指针算出来的最大值减去当前点，得到当前点能够接的雨水量。直到两个指针会和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">        rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; rightMax) &#123;           <span class="comment">// 此时左边的指针将rightMax当成最高点</span></span><br><span class="line">            res += leftMax - height[left];</span><br><span class="line">            left ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 此时右边的指针将leftMax当成最高点</span></span><br><span class="line">            res += rightMax - height[right];</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：单调栈</strong>                   <font color=blue><strong>时间复杂度O(n)    空间复杂度O(n)</strong></font></p>
<p>维护一个单调递减栈，里面存储的是下标，满足从栈底到栈顶下标所对应的值单调递减。</p>
<p>栈顶元素为top，第二个元素为left。当height[i] &gt; height[top]，就说明top可以接雨水，该区域的宽度为 i - left - 1，高度为top下一个栈left的值和当前点 i 的值之间的最小值与top点值的差，即min(height[left], height[i]) − height[top]。</p>
<p>为了得到left，top需要出栈，top计算完所接雨水后，left变成新的top，然后 i 继续和此top比较，重复上一步操作。直到栈空或者 i 对应的值小于等于top的值。（为什么是小于等于呢，因为栈是单调递减的，小于等于就可以直接入栈，只有大于才用和栈中数据去比对）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> Math.min(height[i], height[left]) - height[top];</span><br><span class="line">            res += width * high;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十六、罗马数字转整数"><a href="#十六、罗马数字转整数" class="headerlink" title="十六、罗马数字转整数"></a>十六、罗马数字转整数</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230916163252.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>XIV &#x3D; X - I + V &#x3D; 10 - 1 + 5 &#x3D; 14</strong></font></p>
<p>将罗马字符和数字用map映射起来，如果当前的罗马字符对应的数字比下一个罗马字符对应的数字小，则说明要做减法，反之做加法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; map.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">            res -= value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十七、整数转罗马数字"><a href="#十七、整数转罗马数字" class="headerlink" title="*十七、整数转罗马数字"></a>*十七、整数转罗马数字</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230917131917.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>计算出每个数字在每个位上的表示形式，整理成一张硬编码表</strong></font></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230917132521.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String[] thousands = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">    String[] hundreds  = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    String[] tens      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    String[] ones      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        roman.append(thousands[num / <span class="number">1000</span>]);</span><br><span class="line">        roman.append(hundreds[num % <span class="number">1000</span> / <span class="number">100</span>]);</span><br><span class="line">        roman.append(tens[num % <span class="number">100</span> / <span class="number">10</span>]);</span><br><span class="line">        roman.append(ones[num % <span class="number">10</span>]);</span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十八、最长公共前缀"><a href="#十八、最长公共前缀" class="headerlink" title="十八、最长公共前缀"></a>十八、最长公共前缀</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230917140448.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>数组中的每个字符依次比较，每得到一个公共前缀，直接拿当前公共前缀和后一个字符比较即可，然后再更新公共前缀，比较途中公共前缀为空，则直接返回空字符。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strs.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">        prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Math.min(str1.length(), str2.length());</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十九、反转字符串中的单词"><a href="#十九、反转字符串中的单词" class="headerlink" title="*十九、反转字符串中的单词"></a>*十九、反转字符串中的单词</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230918144116.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>首先去除字符串头尾空格，后去除单词间多余空格，为了降低空间复杂度，那么直接对字符串进行更改，首先将字符串颠倒，然后再颠倒每个单词即可</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> trimSpaces(s);</span><br><span class="line">        reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);   <span class="comment">// 翻转字符串</span></span><br><span class="line">        reverseEachWord(sb);    <span class="comment">// 翻转每个单词</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">trimSpaces</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串间多余的空白字符去除</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;    <span class="comment">// 若sb中已经加入了空格，则多余的空格不用加入</span></span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(StringBuilder sb, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 循环至单词的末尾</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转单词   此时end指向空格或超过字符串长度</span></span><br><span class="line">            reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二十、N字形变换"><a href="#二十、N字形变换" class="headerlink" title="*二十、N字形变换"></a>*二十、N字形变换</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230918153309.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>遍历字符串，当从N字形头开始的时候，字符放置的位置是从第一行递增，到尾之后，开始递减</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StringBuilder&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        rows.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 初始化是反向，s遍历开始时，会变为正向递增。列结尾后会递减</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        rows.get(i).append(c);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">            flag = -flag;</span><br><span class="line">        &#125;</span><br><span class="line">        i += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(StringBuilder row : rows) &#123;</span><br><span class="line">        res.append(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二一、String中第一个匹配项下标"><a href="#二一、String中第一个匹配项下标" class="headerlink" title="二一、String中第一个匹配项下标"></a>二一、String中第一个匹配项下标</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230919184526.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue> <strong>若从0开始，到n - m为止的时候，还没有遍历到长字符串中有字符和短字符串中的头字符相等，那么就不用遍历了。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> needle.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) &#123;   <span class="comment">// 此处需要使用&lt;=，比如5-3，遍历前两个后，还需要遍历第三个才行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i, b = <span class="number">0</span>;      <span class="comment">// 此处使用a从i开始继续递增，如果递增到后面不想等了，a还是会等于后一步的i</span></span><br><span class="line">        <span class="keyword">while</span>(b &lt; m &amp;&amp; haystack.charAt(a) == needle.charAt(b)) &#123;</span><br><span class="line">            a ++;</span><br><span class="line">            b ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(b == m) &#123;       <span class="comment">// 说明b遍历完了，已经相等了，那么返回起始点i即可</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二二、文本对齐"><a href="#二二、文本对齐" class="headerlink" title="** 二二、文本对齐"></a>** 二二、文本对齐</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230921155638.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>首先确定每一行可以放置的单词的个数，这样可以得到这行的空格的个数，从而计算出每个单词之间的空格数</strong></font></p>
<p>空格要如何填充，可以分为一下三种情况：</p>
<p><strong>情形一：当前行是最后一行。</strong>则每个单词间空格个数为1个，行尾使用空格填充。</p>
<p><strong>情形二：当前行非最后一行，且只有一个单词。</strong>则单词左对齐，行尾使用空格填充。</p>
<p><strong>情形三：当前行非最后一行，且有多个单词。</strong>设当前行单词个数为<code>nums</code>，空格数为<code>spaces</code>，则每个单词之间的空格数应该为</p>
<p><code>avg = nums / (spaces - 1)</code>。其余数<code>extra</code>应该填充在当前行第一个单词后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">fullJustify</span><span class="params">(String[] words, <span class="type">int</span> maxWidth)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>, n = words.length;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> right; <span class="comment">// 当前行的第一个单词在 words 的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sumLen</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计这一行单词长度之和</span></span><br><span class="line">            <span class="comment">// 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格。</span></span><br><span class="line">            <span class="comment">// (right-left)可以看作是如果将right位的单词放置进来，需要的空格数，也可以看作是当前行的单词数</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; sumLen + words[right].length() + right - left &lt;= maxWidth) &#123;</span><br><span class="line">                sumLen += words[right++].length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格</span></span><br><span class="line">            <span class="keyword">if</span> (right == n) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> join(words, left, n, <span class="string">&quot; &quot;</span>);</span><br><span class="line">                sb.append(blank(maxWidth - sb.length()));</span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">numWords</span> <span class="operator">=</span> right - left;    <span class="comment">// 当前行的单词数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">numSpaces</span> <span class="operator">=</span> maxWidth - sumLen;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行只有一个单词：该单词左对齐，在行末填充剩余空格</span></span><br><span class="line">            <span class="keyword">if</span> (numWords == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(words[left]);</span><br><span class="line">                sb.append(blank(numSpaces));</span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行不只一个单词</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">avgSpaces</span> <span class="operator">=</span> numSpaces / (numWords - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">extraSpaces</span> <span class="operator">=</span> numSpaces % (numWords - <span class="number">1</span>);</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="comment">// 拼接额外加一个空格的单词</span></span><br><span class="line">            sb.append(join(words, left, left + extraSpaces + <span class="number">1</span>, blank(avgSpaces + <span class="number">1</span>))); </span><br><span class="line">            sb.append(blank(avgSpaces));</span><br><span class="line">            sb.append(join(words, left + extraSpaces + <span class="number">1</span>, right, blank(avgSpaces))); <span class="comment">// 拼接其余单词</span></span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// blank 返回长度为 n 的由空格组成的字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">blank</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sb.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串</span></span><br><span class="line">    <span class="keyword">public</span> StringBuffer <span class="title function_">join</span><span class="params">(String[] words, <span class="type">int</span> left, <span class="type">int</span> right, String sep)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(words[left]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt; right; ++i) &#123;</span><br><span class="line">            sb.append(sep);</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二三、验证回文字符串"><a href="#二三、验证回文字符串" class="headerlink" title="二三、验证回文字符串"></a>二三、验证回文字符串</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230921162837.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>若是标点符号、空格等特殊字符串，直接跳过即可</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) &#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left ++;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二四、判断子序列"><a href="#二四、判断子序列" class="headerlink" title="二四、判断子序列"></a>二四、判断子序列</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230922102946.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>s和t匹配上了，则同时右移，匹配不上，则t右移即可，以一方结束而终止循环，最后判断s的指针是否和s的长度相等</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sl</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">tl</span> <span class="operator">=</span> t.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp &lt; tl &amp;&amp; sp &lt; sl) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.charAt(tp) == s.charAt(sp)) &#123;</span><br><span class="line">            sp ++;</span><br><span class="line">        &#125;</span><br><span class="line">        tp ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sp == sl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二五、两数之和2"><a href="#二五、两数之和2" class="headerlink" title="*二五、两数之和2"></a>*二五、两数之和2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230922131259.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>二分法、双指针</strong></font></p>
<p><strong>方法一：二分法    时间复杂度O(nlogn)    空间复杂度O(1)</strong></p>
<p>首先循环数组，确定一个数 i，从 i + 1到 n - 1的范围中，使用二分法循环判断 mid，是否满足 nums[mid] &#x3D;&#x3D; target - nums[i]。相等则返回，小于则说明 mid 的值小于差值，差值出现在 mid 之后，所以更新 low 值位mid + 1，大于则更新 high 值为 mid - 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numbers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;   <span class="comment">// numbers只有两个数时，只用&lt;，无法进入while循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i + <span class="number">1</span>, mid + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：双指针   时间复杂度O(n)   空间复杂度O(1)</strong></p>
<p>first指针指向数组首，last指针指向数组尾，判断first + last 和 target 的大小。相等则返回，小于则first ++，大于则last –。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numbers.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>, last = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subv</span> <span class="operator">=</span> target - numbers[last];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fv</span> <span class="operator">=</span> numbers[first];</span><br><span class="line">        <span class="keyword">if</span>(subv == fv) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;first + <span class="number">1</span>, last + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(subv &gt; fv) &#123;</span><br><span class="line">            first ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二六、盛最多水的容器"><a href="#二六、盛最多水的容器" class="headerlink" title="*二六、盛最多水的容器"></a>*二六、盛最多水的容器</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230923143539.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>使用双指针，left指向头，right指向尾。left和right之间的距离总是在变小的，这时left和right的移动就要保证哪边小移动那边。</strong></font></p>
<p>盛水的长度 X &#x3D; right - left</p>
<p>盛水的高度 Y &#x3D; min(height[left], height[right])</p>
<p>盛水的容积 V &#x3D;  X * Y，在 X 总是变小的情况下，我们就得保证Y要变大，这样 V 才有可能变大，所以left、right指向的值，那边小，移动哪边指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> right - left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> height[right] - height[left];</span><br><span class="line">        <span class="keyword">if</span>(y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = Math.max(max, height[right] * x);</span><br><span class="line">            right --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, height[left] * x);</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二七、三数之和"><a href="#二七、三数之和" class="headerlink" title="*二七、三数之和"></a>*二七、三数之和</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230923170141.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将数组排序，确定第一个数后，剩下的两个数便可以根据它们的和去判断哪个指针要右移，哪个指针要左移。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>; first &lt; n; first ++) &#123;</span><br><span class="line">        <span class="comment">// 若后一个数与前一个数相同，则直接跳过当前循环</span></span><br><span class="line">        <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[first];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>; second &lt; n; second ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时说明third指向的值过大，third需要左移</span></span><br><span class="line">            <span class="keyword">while</span>(second &lt; third &amp;&amp; nums[third] + nums[second] &gt; target) &#123;</span><br><span class="line">                third --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明second的当前循环没有值满足条件，直接break，让first进行下一次遍历</span></span><br><span class="line">            <span class="keyword">if</span>(second == third) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[second] + nums[third] == target) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                list.add(nums[first]);</span><br><span class="line">                list.add(nums[second]);</span><br><span class="line">                list.add(nums[third]);</span><br><span class="line">                ans.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是nums[third] + nums[second] &lt; target的情况，说明second指向的值较小，则需要second右移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二八、长度最小子数组"><a href="#二八、长度最小子数组" class="headerlink" title="*二八、长度最小子数组"></a>*二八、长度最小子数组</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230924105508.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>当left和right指针指向的位置之间的值大于等于给定值之后，right继续向右的话，值肯定是大于的，这个时候就要left右移，去尽可能缩小这个子数组。如果缩小到小于给定值之后，right便可以向右。循环如此。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; n) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">            res = Math.min(res, right-left+<span class="number">1</span>);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        right ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二九、无重复字串的最长子串"><a href="#二九、无重复字串的最长子串" class="headerlink" title="*二九、无重复字串的最长子串"></a>*二九、无重复字串的最长子串</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230924140857.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>若没碰到重复字符，则right可以右移，若碰到了，则left右移，并且删掉left之前指向的值，直到删除了set中存在的让right重复的值。然后right继续右移，循环如此。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; n) &#123;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n &amp;&amp; !set.contains(s.charAt(right))) &#123;</span><br><span class="line">            set.add(s.charAt(right));</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, right - left);</span><br><span class="line">        left ++;</span><br><span class="line">        set.remove(s.charAt(left-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三十、最小覆盖子串"><a href="#三十、最小覆盖子串" class="headerlink" title="**三十、最小覆盖子串"></a>**三十、最小覆盖子串</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230927190655.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针 l 和 r 都从 s 字符的下标0开始遍历，r 初步遍历到包含 t 中所有字符位置为止，然后 l 右移，逐步缩小滑动窗口中的字符数量，若右移之后又不包含 t 中的所有字符了，那就 r 继续右移。循环如此，找出最小覆盖子串。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; tmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; smap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tLen</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen &lt; tLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tLen; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tc</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            tmap.put(tc, tmap.getOrDefault(tc, <span class="number">0</span>) + <span class="number">1</span>);    <span class="comment">// 首先将t中的所有字符的数量放到tmap中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, resL = <span class="number">0</span>, resR = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; sLen) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">sc</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">            <span class="keyword">if</span>(tmap.containsKey(sc)) &#123;    <span class="comment">// 判断当前r指向的字符是否在t中</span></span><br><span class="line">                smap.put(sc, smap.getOrDefault(sc, <span class="number">0</span>) + <span class="number">1</span>);   <span class="comment">// 若在，将当前字符存放在smap中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(check() &amp;&amp; l &lt;= r) &#123;    <span class="comment">// 检查通过说明l -&gt; r之间已经包含了t，smap和tmap中的内容完全相同</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(l);</span><br><span class="line">                <span class="keyword">if</span>(r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    resL = l;</span><br><span class="line">                    resR = l + len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmap.containsKey(c)) &#123;   <span class="comment">// 此时缩小窗口</span></span><br><span class="line">                    smap.put(c, smap.get(c) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l ++;   <span class="comment">// 窗口缩小</span></span><br><span class="line">            &#125;</span><br><span class="line">            r ++;    <span class="comment">// 窗口中字符不包含t，或窗口无法继续缩小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(resL, resR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前l -&gt; r之间的字符是否包含了t</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> tmap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iter.next();</span><br><span class="line">            <span class="type">Character</span> <span class="variable">key</span> <span class="operator">=</span> (Character) entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> (Integer) entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(smap.getOrDefault(key, <span class="number">0</span>) &lt; value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三一、有效的数独"><a href="#三一、有效的数独" class="headerlink" title="*三一、有效的数独"></a>*三一、有效的数独</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230928145758.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>使用三个数组分别来记录每一行，每一列，每个九宫格中的数的出现次数</strong></font></p>
<p>对于每一行中的值，使用一个数组<code>rows[9][9]</code>来表示，当前数放在这个数组的哪里，出现了几次。</p>
<p>对于每一列中的值，使用一个数组<code>columns[9][9]</code>来表示，当前数放在这个数组的哪里，出现了几次。</p>
<p>对于每一个九宫格的值，使用一个数组<code>subboxes[3][3][9]</code>来表示，当前数放在这个数组的哪里，出现了几次。</p>
<p>比如<code>borad[5][6] = 9</code>，那么这个数 5 ，放在<code>rows</code>中的第 5 行，第 9 - 1 列，出现了 1 次。放在<code>columns</code>中的第 6 行，第 9 - 1 列，出现了一次。如果<code>borad[5][n] = 9</code>，那么这个数继续放在第 5 行，第 9 - 1 列，出现了2次。同理<code>board[n][6] = 9</code>也是如此。如果有位置出现了超过 1 次，那么就直接返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] rows = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span>[][] columns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span>[][][] subboxes = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">            <span class="keyword">if</span>(c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                rows[i][index] ++;        <span class="comment">// 定住行，判断这一行中有没有数字重复</span></span><br><span class="line">                columns[j][index] ++;     <span class="comment">// 定住列，判断这一列中有没有数字重复</span></span><br><span class="line">                subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][index] ++;</span><br><span class="line">                <span class="keyword">if</span>(rows[i][index] &gt; <span class="number">1</span> || columns[j][index] &gt; <span class="number">1</span> || subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][index] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三二、螺旋矩阵"><a href="#三二、螺旋矩阵" class="headerlink" title="*三二、螺旋矩阵"></a>*三二、螺旋矩阵</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230930203450.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将矩阵看作有若干层，一层一层输出</strong></font></p>
<p>假设左上角位于<code>(top, left)</code>，右下角位于<code>(bottom, right)</code>，按照如下顺序遍历当前层元素：</p>
<p>1、从左往右遍历，由<code>(top, left)</code> 到 <code>(top, right)</code>。</p>
<p>2、从上往下遍历，由<code>(top + 1, right)</code> 到 <code>(bottom, right)</code>。</p>
<p>3、如果<code>left &lt; right，top &lt; bottom</code>。</p>
<p>​		从右往左遍历，由<code>(bottom, right - 1)</code> 到 <code>(bottom, left)</code>。</p>
<p>​		从下往上遍历，由<code>(bottom - 1, left)</code> 到 <code>(top + 1, left)</code>。</p>
<p><font color=red>**当只剩下最后一列遍历时，需要判断此时的left &lt; right，否则会多输出。当剩下最后一行遍历时，需要判断此时的top &lt; bottom， 否则也会多输出。因为行和列都会在前两个循环输出，若后两个循环不判断，则会造成数据重复输出。**</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; order = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = columns - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">colomn</span> <span class="operator">=</span> left; colomn &lt;= right; colomn ++) &#123;</span><br><span class="line">            order.add(matrix[top][colomn]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> top + <span class="number">1</span>; row &lt;= bottom; row ++) &#123;</span><br><span class="line">            order.add(matrix[row][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">colomn</span> <span class="operator">=</span> right - <span class="number">1</span>; colomn &gt;= left; colomn --) &#123;</span><br><span class="line">                order.add(matrix[bottom][colomn]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> bottom - <span class="number">1</span>; row &gt; top; row --) &#123;</span><br><span class="line">                order.add(matrix[row][left]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">        top ++;</span><br><span class="line">        bottom --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三三、旋转图像"><a href="#三三、旋转图像" class="headerlink" title="*三三、旋转图像"></a>*三三、旋转图像</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231001183904.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>直接旋转。或者先水平轴对折，然后以左顶角和右底角连线为轴对折。</strong></font></p>
<p><font color=blue><strong>方法一：</strong></font><strong>直接旋转</strong></p>
<p>我们可以发现，<strong>对于矩阵中的第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。</strong></p>
<p>因此，对于矩阵中的元素<code>matrix[row][col]</code>，在旋转后，它的新位置为<code>matrix[col][n-row-1]</code>。新的行等于原来的列，新的列等于n减去原来的行减去1。<br>$$<br>\begin{cases}<br>   row &#x3D; col \<br>   col &#x3D; n - row - 1<br>  \end{cases}<br>$$<br>由此，我们可以得出矩形的四个方位的数据，旋转前后的位置关系如下：</p>
<p><strong>1旋转到3，行列变化为：</strong><code>matrix[row][col]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[col][n-row-1]</code></p>
<p><strong>3旋转到9，行列变化为：</strong><code>matrix[col][n-row-1]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[n-row-1][n-col-1]</code></p>
<p><strong>9旋转到7，行列变化为：</strong> <code>matrix[n-row-1][n-col-1]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[n-col-1][n-(n-row-1)-1]</code>  &#x3D;&#x3D;&#x3D;&gt;   <code>matrix[n-col-1][row]</code> </p>
<p><strong>7旋转到1，行列变化为：</strong> <code>matrix[n-col-1][row]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[row][n-(n-col-1)-1]</code>  &#x3D;&#x3D;&#x3D;&gt;   <code>matrix[row][col]</code> </p>
<p>对于我们实际需要遍历的行数和列数，我们可以推理出，若 n 是偶数矩阵，则行和列遍历到 n&#x2F;2 即可。若 n 是奇数矩阵，则行遍历到n&#x2F;2，列遍历到(n+1)&#x2F;2。如下图：</p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231001195011.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; j ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=blue><strong>方法二：</strong></font><strong>先水平轴对折，然后以左顶角和右底角连线为轴对折</strong></p>
<p><strong>水平轴对折，行列变化为：</strong><code>matrix[row][col]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[n-row-1][col]</code></p>
<p><strong>反斜轴对折，行列变化为：</strong><code>matrix[n-row-1][col]</code>  &#x3D;&#x3D;&#x3D;&gt;  <code>matrix[col][n-row-1]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="comment">// 水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - i - <span class="number">1</span>][j];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三四、矩阵置零"><a href="#三四、矩阵置零" class="headerlink" title="*三四、矩阵置零"></a>*三四、矩阵置零</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231002195709.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>首先记录第一行和第一列是否存在 0，对于非第一行和第一列为 0 的元素，可以将这个数所在的行和列的第一个数都置为 0，然后从第二行第二列开始遍历，判断遍历到的行和列的第一个数是否为 0，若为 0，则将当前行和列全部置为 0。最后再判断是否需要将第一行和第一列置为 0。</strong></font></p>
<p><strong>1、</strong>记录第一行和第一列是否本来就存在 0；</p>
<p><strong>2、</strong>判断除第一行第一列外，是否存在 0，若存在，就将当前行和列的第一个数（在第一行或第一列上）置为 0；</p>
<p><strong>3、</strong>根据第一行和第一列的 0（包括后期赋值的0）将非第一行和第一列的值全部变成 0；</p>
<p><strong>4、</strong>最后根据第一步的记录，判断第一行和第一列是否需要置为0；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flagCol</span> <span class="operator">=</span> <span class="literal">false</span>, flagRow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            flagCol = <span class="literal">true</span>;     <span class="comment">// 第一列存在0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            flagRow = <span class="literal">true</span>;     <span class="comment">// 第一行存在0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断除第一行第一列外，是否存在0，若存在，就将当前行和列的第一个数置为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据第一行和第一列的0（包括后期赋值的0）将非第一行和第一列的值全部变成0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后判断是否需要将第一行和第一列置为0</span></span><br><span class="line">    <span class="keyword">if</span>(flagRow) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flagCol) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三五、生命游戏"><a href="#三五、生命游戏" class="headerlink" title="*三五、生命游戏"></a>*三五、生命游戏</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231003200021.png"></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231003200121.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>题目限定的条件都是根据相邻活细胞的数量来判断当前细胞是死是活。因此，对于活细胞变成死细胞后，我们可以使用额外的数据来表示当前细胞的状态，以便于后面可以准确的拿到细胞之前的状态。对于活细胞变成死细胞，可以将状态变成 -1，这样有相邻数据要去判断自己是否存活时，可以直接用 -1 的绝对值来查看它的相邻的细胞之前的状态。</strong></font></p>
<p><strong>1、</strong>两层嵌套遍历<code>&#123;-1,0,1&#125;</code>，可以快速得到某一点的周围 3 * 3 点的坐标，然后根据它们的值去判断它们之前的状态是否为活细胞。</p>
<p><strong>2、</strong>根据活细胞的数量，将当前细胞的状态设置成容易识别的数字，比如 -1 就代表之前活细胞，现在死细胞；2 代表之前死细胞，现在活细胞。方便之后当前细胞作为别的细胞的相邻细胞的时候，能够准确的判断其之前的状态，从而去计算 liveNear 的值。</p>
<p><strong>3、</strong>将细胞的状态设置完后，重新遍历，根据之前设置的值，重新将细胞的状态更新正常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] near = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">liveNear</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!(near[i] == <span class="number">0</span> &amp;&amp; near[j] == <span class="number">0</span>)) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> row + near[i];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> col + near[j];</span><br><span class="line">                        <span class="comment">// Math.abs(board[r][c]) == 1 可以替换成 board[r][c] == 1 || board[r][c] == 3</span></span><br><span class="line">                        <span class="keyword">if</span>((r &gt;= <span class="number">0</span> &amp;&amp; r &lt; rows) &amp;&amp; (c &gt;= <span class="number">0</span> &amp;&amp; c &lt; cols) &amp;&amp; Math.abs(board[r][c]) == <span class="number">1</span>) &#123;</span><br><span class="line">                            liveNear ++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(board[row][col] == <span class="number">1</span> &amp;&amp; (liveNear &gt; <span class="number">3</span> || liveNear &lt; <span class="number">2</span>)) &#123;</span><br><span class="line">                board[row][col] = -<span class="number">1</span>;     <span class="comment">// 这里也可以用别的值   如: board[row][col] = 3</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[row][col] == <span class="number">0</span> &amp;&amp; (liveNear == <span class="number">3</span>)) &#123;</span><br><span class="line">                board[row][col] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][col] == <span class="number">2</span>) &#123;</span><br><span class="line">                board[row][col] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[row][col] == -<span class="number">1</span>) &#123;</span><br><span class="line">                board[row][col] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三六、赎金信"><a href="#三六、赎金信" class="headerlink" title="三六、赎金信"></a>三六、赎金信</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231003203458.png"></p>
<p><font color = red><strong>思路：</strong></font><font color=blue><strong>magazine长度小于ransomNote，则直接返回false。判断ransomNote中使用到的字符的个数，在magazine中是否全部出现，个数是否能对上，不能对上，则返回false</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ransomNote.length() &gt; magazine.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">        cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">        cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三七、同构字符串"><a href="#三七、同构字符串" class="headerlink" title="三七、同构字符串"></a>三七、同构字符串</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231004192103.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将s中出现的字符和t中出现的字符先映射起来，若之后s中又碰到相同的字符，但是t中出现的字符和映射关系中s对应的字符不相同，则返回false。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    Map&lt;Character, Character&gt; s2t = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Character&gt; t2s = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="type">char</span> <span class="variable">y</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>((s2t.containsKey(x) &amp;&amp; s2t.get(x) != y) || (t2s.containsKey(y) &amp;&amp; t2s.get(y) != x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s2t.put(x, y);</span><br><span class="line">        t2s.put(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三八、单词规律"><a href="#三八、单词规律" class="headerlink" title="三八、单词规律"></a>三八、单词规律</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20231004194413.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>将pattern出现的字符和s中的单词相互映射起来，若后面pattern中碰到相同的字符，但是s中出现的单词和映射关系中pattern对应的单词不相同，则返回false。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String str)</span> &#123;</span><br><span class="line">    Map&lt;String, Character&gt; str2ch = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Character&gt;();</span><br><span class="line">    Map&lt;Character, String&gt; ch2str = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    String[] strs = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(m != strs.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sh</span> <span class="operator">=</span> strs[i];</span><br><span class="line">        <span class="keyword">if</span> (str2ch.containsKey(sh) &amp;&amp; str2ch.get(sh) != ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch2str.containsKey(ch) &amp;&amp; !sh.equals(ch2str.get(ch))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str2ch.put(sh, ch);</span><br><span class="line">        ch2str.put(ch, sh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String str)</span> &#123;</span><br><span class="line">    Map&lt;String, Character&gt; str2ch = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Character&gt;();</span><br><span class="line">    Map&lt;Character, String&gt; ch2str = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; pattern.length(); ++p) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> pattern.charAt(p);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m &amp;&amp; str.charAt(j) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> str.substring(i, j);</span><br><span class="line">        <span class="keyword">if</span> (str2ch.containsKey(tmp) &amp;&amp; str2ch.get(tmp) != ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch2str.containsKey(ch) &amp;&amp; !tmp.equals(ch2str.get(ch))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str2ch.put(tmp, ch);</span><br><span class="line">        ch2str.put(ch, tmp);</span><br><span class="line">        i = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &gt;= m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div>

<!-- post-guide -->

    <div class="post-guide">
        <div class="item left">
            
        </div>
        <div class="item right">
            
        </div>
    </div>


<!-- comment - giscus -->


<!-- comment - valine -->


<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©<span id="footerYear-start"></span>-<span id="footerYear-end"></span>
	<a href="/">jiakuan.chen</a> 
	
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>


<script type="text/javascript">
	document.getElementById('footerYear-start').innerHTML = new Date().getFullYear() + '';
</script>

<script type="text/javascript">
	document.getElementById('footerYear-end').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>