<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		LeetCode做题笔记 | 
	 
	BIGKEL BLOB
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/bigkel.png">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "kw520.github.io";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>


	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.5.1/dist/Valine.min.js"></script>

	
	

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">BIGKEL BLOB</a>

	<ul id="menu">
    

    

    

    
  
    
      <li class="menu-item">
        <a href='https://github.com/kw520' class="menu-item-link" target="_blank">
          <i class="fa fa-github fa-2x"></i>
        </a>
      </li>
    
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="file active">
									<a href="/2023/09/05/LeetCode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/">
                     
										    LeetCode做题笔记
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">
	LeetCode做题笔记
</h1>

<!-- meta -->
<div class="article-meta">
	

	<span>jiakuan.chen</span>
	<span>2023-09-05 18:56:11</span>

  <div id="article-categories">
    
		  <span>Categories：</span>
      
    

    
		    <span>Tags：</span>
        
    
  </div>

</div>

<!-- content -->
<div id="article-content">
	<h1 id="一、合并两个有序数组"><a href="#一、合并两个有序数组" class="headerlink" title="一、合并两个有序数组"></a>一、<strong>合并两个有序数组</strong></h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/clipboard.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>从原始nums1和nums2的末尾开始比较，不比nums2小的数往nums1的后面放，若一方遍历完，则另一方继续遍历直到结束。</strong></font></p>
<p>三个指针，分别为	 int one &#x3D; m - 1;</p>
<p>​    	    						int two &#x3D; n - 1;</p>
<p>​    	    						int tail &#x3D; m + n - 1;</p>
<p>若one &#x3D;&#x3D; -1，则nums1[tail] &#x3D; nums2[two]，且two–，tail–；</p>
<p>反之若two &#x3D;&#x3D; -1，则nums1[tail] &#x3D; nums1[one]，且one–，tail–；</p>
<p>反之若nums1[one] &gt;&#x3D; nums2[two]，则nums1[tail] &#x3D; nums1[one]，且one–，tail–；</p>
<p>反之，则nums1[tail] &#x3D;  nums2[two]，且two–，tail–；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(one &gt; -<span class="number">1</span> || two &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(one == -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums2[two];</span><br><span class="line">            two --;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(two == -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums1[one];</span><br><span class="line">            one --;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[one] &gt;= nums2[two]) &#123;</span><br><span class="line">            cur = nums1[one];</span><br><span class="line">            one --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[two];</span><br><span class="line">            two --;</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail] = cur;</span><br><span class="line">        tail --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二、移除元素"><a href="#二、移除元素" class="headerlink" title="二、移除元素"></a><strong>二、移除元素</strong></h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/remove.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p>​		<strong>1、双指针，都从头开始，R指针若不等于val，则赋值给L后，L和R同时右移，若等于，则L不动，R右移寻找不等于val的值赋值给L</strong></p>
<p>​		<font color=blue>**2、双指针，L指向头，R指向尾，L &lt; R，若L指针不等于val，则右移，若等于val，则R指针值赋值给L指针，R指针左移，一直循环。**</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、删除有序数组中的重复项"><a href="#三、删除有序数组中的重复项" class="headerlink" title="三、删除有序数组中的重复项"></a>三、删除有序数组中的重复项</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230905200311.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针p指向第一个数，指针q指向第二个数，如果两个值相等，则q++。如果不相等，当q - p &gt; 1时（避免0，1，2，3，4这种极端情况，表示当p和q不相邻时，才用调换值，避免自己和自己调换），调换q和p+1的值，且p++， q++。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[q] != nums[p]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q - p &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                nums[p + <span class="number">1</span>] = nums[q];</span><br><span class="line">            &#125;</span><br><span class="line">            p ++;</span><br><span class="line">        &#125;</span><br><span class="line">        q ++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四、有序数组中只能重复两次"><a href="#四、有序数组中只能重复两次" class="headerlink" title="*四、有序数组中只能重复两次"></a>*四、有序数组中只能重复两次</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906181755.png"></p>
<p><font color=red><strong>思路：</strong></font><strong>指针slow、fast都指向下标为2的位置</strong></p>
<p><font color=blue><strong>若fast &#x3D;&#x3D; slow[n-2]，由于slow[n]之前已经是整理好后的，并且数组有序，那么slow[n-1]不可能比slow[n-2]小，也不可能比fast大，所以此时必然有fast &#x3D;&#x3D; slow[n-2] &#x3D;&#x3D; slow[n-1]，则需要fast右移找到不等于slow[n-2]的值赋值给slow[n]（若fast找到的值和slow当前值相等，则可以不用赋值），然后slow和fast同时右移。</strong></font></p>
<p><font color=blue>**若fast !&#x3D; slow[n-2]，则说明slow[n]之前排好序的slow[n-2] &lt; slow[n-1]，那么此时fast的值可以给slow[n]**</font></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906190249.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != nums[slow -<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            slow ++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、多数元素"><a href="#五、多数元素" class="headerlink" title="五、多数元素"></a>五、多数元素</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906203706.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p>​		<strong>1、排序，多数元素一定占据n&#x2F;2的位置。</strong></p>
<p>​		<font color=blue><strong>2、排序，p、q指针从0开始，若q &#x3D;&#x3D; p，则q向右遍历，若q !&#x3D; p，则q-1-p+1为当前数的个数，若此个数大于n&#x2F;2，则返回nums[p]，反之则p &#x3D; q，继续向后遍历，直到q &gt;&#x3D; n为止</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[p] == nums[q]) &#123;</span><br><span class="line">            q ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(q - p &gt; more)&#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六、轮转数组"><a href="#六、轮转数组" class="headerlink" title="*六、轮转数组"></a>*六、轮转数组</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230907184201.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>实际轮转次数 k &#x3D; k – 整数*n，比如n &#x3D; 5，轮转6次，那么实际次数为1，n &#x3D; 5，轮转2次，实际次数为2。将nums全部反转，然后根据实际轮转次数分割，[0, k - 1] 和 [k, n - 1]再各自反转。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    swap(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    swap(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    swap(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        nums[start] = nums[start] ^ nums[end];</span><br><span class="line">        nums[end] = nums[start] ^ nums[end];</span><br><span class="line">        nums[start] = nums[start] ^ nums[end];</span><br><span class="line">        start ++;</span><br><span class="line">        end --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七、买卖股票最佳时机"><a href="#七、买卖股票最佳时机" class="headerlink" title="七、买卖股票最佳时机"></a>七、买卖股票最佳时机</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230907203725.png"></p>
<p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针p和q分别指向0和1，记录最大利润max &#x3D; 0，q向后移动，若 q - p &lt; 0，则说明 q 点买进的利润一定大于当前 p 点买进的利润，所以 p 点重新定位，p &#x3D; q。若 q - p &gt; 0，则判断利润是否比之前的利润 max 大，大则覆盖。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; prices.length) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> prices[q] - prices[p];</span><br><span class="line">        <span class="keyword">if</span>(money &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = money &gt; max ? money : max;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        q ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八、买卖股票最佳时机2"><a href="#八、买卖股票最佳时机2" class="headerlink" title="*八、买卖股票最佳时机2"></a>*八、买卖股票最佳时机2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909101503.png"></p>
<p><font color=red><strong>思路：</strong></font></p>
<p><font color=red><strong>方法一：</strong></font><strong>动态规划</strong>    <font color=blue><strong>时间复杂度O(n)，空间复杂度O(n)</strong></font></p>
<p>​		每天手里股票的状态有两种，***dp[ i , 0 ]<em><strong>表示第 <em><strong>i</strong></em> 天未持有股票，</strong></em>dp[ i, 1 ]***表示第 <em><strong>i</strong></em> 天持有股票。</p>
<p>​		<em><strong>dp[ i , 0 ]<em><strong>的时候，可以看作是 <em><strong>i - 1</strong></em> 天已经卖出了股票，</strong></em>i</strong></em> 天还没有买进，即<em><strong>dp[ i - 1 , 0 ]<em><strong>。或者是 <em><strong>i - 1</strong></em> 天买进了股票，</strong></em>i</strong></em> 天卖出，即***dp[ i - 1 , 1 ] + price[ i ]***。所以 <em><strong>i</strong></em> 天最大的利润可以可以列出如下转换方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i,<span class="number">0</span>] = max&#123;dp[i-<span class="number">1</span>,<span class="number">0</span>], dp[i-<span class="number">1</span>,<span class="number">1</span>]+price[i]&#125;</span><br></pre></td></tr></table></figure>

<pre><code>     ***dp[ i , 1 ]***的时候，可以看作是 ***i - 1*** 天买入了股票，***i*** 天还没有卖出，即***dp[ i - 1 , 1]***。或者是 ***i - 1*** 天卖出了股票，***i*** 天买入，即***dp[ i - 1 , 0 ] - price[ i ]***。所以 ***i*** 天最大的利润可以列出如下转换方程：
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i,<span class="number">1</span>] = max&#123;dp[i-<span class="number">1</span>,<span class="number">1</span>], dp[i-<span class="number">1</span>,<span class="number">0</span>]-price[i]&#125;</span><br></pre></td></tr></table></figure>

<p>​		到最后一天的时候，卖出股票肯定要比买入股票利润高，所以只用返回<em><strong>dp[ n , 0]<em><strong>即可。(空间优化) 由于当天的最大利润只与前一天有关，并且每天只有0、1两种状态，那么可以只用</strong></em>dp0</strong></em>表示当天未持有股票状态，<em><strong>dp1</strong></em>表示当天持有股票状态，每过一天用最新值覆盖<em><strong>dp0、dp1</strong></em>即可。那么到了最后一天的最大利润可以用<em><strong>dp0</strong></em>表示即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp0 = Math.max(dp0, dp1+prices[i]);</span><br><span class="line">        dp1 = Math.max(dp1, dp0-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p><font color=red><strong>方法二：</strong></font><strong>贪心算法</strong>    <font color=blue><strong>时间复杂度O(n)，空间复杂度O(1)</strong></font></p>
<p>​		买入股票的最大利润，其实就是每相邻两天利润差大于0的和。比如1，4，3，12这一组数，我们只要避开两个产生负数的数，即可保证利润最大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max += Math.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="九、跳跃游戏"><a href="#九、跳跃游戏" class="headerlink" title="*九、跳跃游戏"></a>*九、跳跃游戏</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909143444.png"></p>
<p><font color=red><strong>思路：</strong></font><strong>贪心算法</strong>   <font color=blue><strong>时间复杂度O(n)，空间复杂度O(1)。</strong></font></p>
<p>​		存在可到达的最大的位置maxend，判断当前位置是否小于maxend。</p>
<p>​		若小于，则说明存在步数可以到达此位置</p>
<p>​					判断此位置可跳跃到的位置是否大于maxend。</p>
<p>​					若大于，则更新maxend，反之继续遍历。</p>
<p>​		若大于，则说明当前位置不存在步数可以到达，直接返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxend</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; maxend) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxend = Math.max(maxend, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十、跳跃游戏2"><a href="#十、跳跃游戏2" class="headerlink" title="*十、跳跃游戏2"></a>*十、跳跃游戏2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909165449.png"></p>
<p><font color=red><strong>思路：</strong></font><strong>贪心算法</strong>   <font color=blue><strong>时间复杂度O(n)，空间复杂度O(1)。</strong></font></p>
<p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909170300.png">		</p>
<p>​		从下标0开始遍历，其能够走到的最远的距离是走到下标2，此时记录max &#x3D; 2，end &#x3D; 2，step &#x3D; 1。遍历到下标1的时候，发现下标1最大能走到下标4，此时更新max &#x3D; 4，但是不能更新end，因为上一步的end还没走完，需要走完上一步的end之后，才能确定下一步需要走到哪里。遍历到下标2的时候，发现下标2最大只能走到下标3，小于max，此时end已经走完，确定了max &#x3D; 4，重新设置end &#x3D; 4，step ++。此处就可以确定使用下标1的时候，这步能够走到最远为4。依次遍历，由于我们当前代码设定step的自增是在起步时自增，而不是走完后自增，所以为了避免最后一步刚好是在数组的最后一个数时，导致程序又把最后一个数当成是起点，所以这里让数组的界限设置为nums.length - 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        max = Math.max(nums[i] + i, max);   <span class="comment">// 持续更新跳跃的最大点，结算时确定下次要跳的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i == end) &#123;   <span class="comment">// 已经遍历到了上一次起跳的最大位置的终点（结算）</span></span><br><span class="line">            end = max;   <span class="comment">// 设置下次需要跳到的位置的终点</span></span><br><span class="line">            step ++;     <span class="comment">// 跳动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div>

<!-- post-guide -->

    <div class="post-guide">
        <div class="item left">
            
        </div>
        <div class="item right">
            
        </div>
    </div>


<!-- comment - giscus -->


<!-- comment - valine -->


<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©<span id="footerYear-start"></span>-<span id="footerYear-end"></span>
	<a href="/">jiakuan.chen</a> 
	
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>


<script type="text/javascript">
	document.getElementById('footerYear-start').innerHTML = new Date().getFullYear() + '';
</script>

<script type="text/javascript">
	document.getElementById('footerYear-end').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>