<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BIGKEL BLOB</title>
  
  
  <link href="https://github.com/kw520/kw520.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/kw520/kw520.github.io/"/>
  <updated>2023-09-14T12:51:32.608Z</updated>
  <id>https://github.com/kw520/kw520.github.io/</id>
  
  <author>
    <name>jiakuan.chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/kw520/kw520.github.io/2023/09/05/LeetCode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/kw520/kw520.github.io/2023/09/05/LeetCode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-05T10:56:11.783Z</published>
    <updated>2023-09-14T12:51:32.608Z</updated>
    
    <content type="html"><![CDATA[<h1>一、<strong>合并两个有序数组</strong></h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/clipboard.png" alt=""></p><p><font color=red><strong>思路：</strong></font><font color=blue><strong>从原始nums1和nums2的末尾开始比较，不比nums2小的数往nums1的后面放，若一方遍历完，则另一方继续遍历直到结束。</strong></font></p><p>三个指针，分别为 int one = m - 1;</p><p>​        int two = n - 1;</p><p>​        int tail = m + n - 1;</p><p>若one == -1，则nums1[tail] = nums2[two]，且two–，tail–；</p><p>反之若two == -1，则nums1[tail] = nums1[one]，且one–，tail–；</p><p>反之若nums1[one] &gt;= nums2[two]，则nums1[tail] = nums1[one]，且one–，tail–；</p><p>反之，则nums1[tail] =  nums2[two]，且two–，tail–；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(one &gt; -<span class="number">1</span> || two &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(one == -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums2[two];</span><br><span class="line">            two --;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(two == -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums1[one];</span><br><span class="line">            one --;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[one] &gt;= nums2[two]) &#123;</span><br><span class="line">            cur = nums1[one];</span><br><span class="line">            one --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[two];</span><br><span class="line">            two --;</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail] = cur;</span><br><span class="line">        tail --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><strong>二、移除元素</strong></h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/remove.png" alt=""></p><p><font color=red><strong>思路：</strong></font></p><p>​<strong>方法一、双指针，都从头开始，R指针若不等于val，则赋值给L后，L和R同时右移，若等于，则L不动，R右移寻找不等于val的值赋值给L</strong></p><p>​<font color=blue><strong>方法二、双指针，L指向头，R指向尾，L &lt; R，若L指针不等于val，则右移，若等于val，则R指针值赋值给L指针，R指针左移，一直循环。</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>三、删除有序数组中的重复项</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230905200311.png" alt=""></p><p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针p指向第一个数，指针q指向第二个数，如果两个值相等，则q++。如果不相等，当q - p &gt; 1时（避免0，1，2，3，4这种极端情况，表示当p和q不相邻时，才用调换值，避免自己和自己调换），调换q和p+1的值，且p++， q++。</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[q] != nums[p]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q - p &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                nums[p + <span class="number">1</span>] = nums[q];</span><br><span class="line">            &#125;</span><br><span class="line">            p ++;</span><br><span class="line">        &#125;</span><br><span class="line">        q ++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>*四、有序数组中只能重复两次</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906181755.png" alt=""></p><p><font color=red><strong>思路：</strong></font><strong>指针slow、fast都指向下标为2的位置</strong></p><p>​<font color=blue><strong>若fast == slow[n-2]，由于slow[n]之前已经是整理好后的，并且数组有序，那么slow[n-1]不可能比slow[n-2]小，也不可能比fast大，所以此时必然有fast == slow[n-2] == slow[n-1]，则需要fast右移找到不等于slow[n-2]的值赋值给slow[n]（若fast找到的值和slow当前值相等，则可以不用赋值），然后slow和fast同时右移。</strong></font></p><p>​<font color=blue><strong>若fast != slow[n-2]，则说明slow[n]之前排好序的slow[n-2] &lt; slow[n-1]，那么此时fast的值可以给slow[n]</strong></font></p><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906190249.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != nums[slow -<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            slow ++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>五、多数元素</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230906203706.png" alt=""></p><p><font color=red><strong>思路：</strong></font></p><p>​<strong>方法一、排序，多数元素一定占据n/2的位置。</strong></p><p>​<font color=blue><strong>方法二、排序，p、q指针从0开始，若q == p，则q向右遍历，若q != p，则q-1-p+1为当前数的个数，若此个数大于n/2，则返回nums[p]，反之则p = q，继续向后遍历，直到q &gt;= n为止</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[p] == nums[q]) &#123;</span><br><span class="line">            q ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(q - p &gt; more)&#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>*六、轮转数组</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230907184201.png" alt=""></p><p><font color=red><strong>思路：</strong></font><font color=blue><strong>实际轮转次数 k = k – 整数*n，比如n = 5，轮转6次，那么实际次数为1，n = 5，轮转2次，实际次数为2。将nums全部反转，然后根据实际轮转次数分割，[0, k - 1] 和 [k, n - 1]再各自反转。</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    swap(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    swap(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    swap(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        nums[start] = nums[start] ^ nums[end];</span><br><span class="line">        nums[end] = nums[start] ^ nums[end];</span><br><span class="line">        nums[start] = nums[start] ^ nums[end];</span><br><span class="line">        start ++;</span><br><span class="line">        end --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>七、买卖股票最佳时机</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230907203725.png" alt=""></p><p><font color=red><strong>思路：</strong></font><font color=blue><strong>指针p和q分别指向0和1，记录最大利润max = 0，q向后移动，若 q - p &lt; 0，则说明 q 点买进的利润一定大于当前 p 点买进的利润，所以 p 点重新定位，p = q。若 q - p &gt; 0，则判断利润是否比之前的利润 max 大，大则覆盖。</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; prices.length) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> prices[q] - prices[p];</span><br><span class="line">        <span class="keyword">if</span>(money &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = money &gt; max ? money : max;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        q ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>*八、买卖股票最佳时机2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909101503.png" alt=""></p><p><font color=red><strong>思路：</strong></font></p><p><font color=red><strong>方法一：</strong></font><strong>动态规划</strong>    <font color=blue><strong>时间复杂度O(n)，空间复杂度O(n)</strong></font></p><p>​每天手里股票的状态有两种，<code>dp[i,0]</code>表示第 <code>i</code> 天未持有股票，<code>dp[i,1]</code>表示第 <code>i</code> 天持有股票。</p><p>​<code>dp[i,0]</code>的时候，可以看作是 <code>i-1</code> 天已经卖出了股票，<code>i</code> 天还没有买进，即<code>dp[i-1,0]</code>。或者是 <code>i-1</code> 天买进了股票，<code>i</code> 天卖出，即<code>dp[i-1,1] + price[i]</code>。所以 <code>i</code> 天最大的利润可以可以列出如下转换方程：</p><p><strong>dp[i,0] = max{dp[i-1,0], dp[i-1,1]+price[i]}</strong></p><p>​<code>dp[i,1]</code>的时候，可以看作是 <code>i-1</code> 天买入了股票，<code>i</code> 天还没有卖出，即<code>dp[i-1,1]</code>。或者是 <code>i-1</code> 天卖出了股票，<code>i</code> 天买入，即<code>dp[i-1,0] - price[i]</code>。所以 <code>i</code> 天最大的利润可以列出如下转换方程：</p><p><strong>dp[i,1] = max{dp[i-1,1], dp[i-1,0]-price[i]}</strong></p><p>​到最后一天的时候，卖出股票肯定要比买入股票利润高，所以只用返回<code>dp[n,0]</code>即可。(空间优化) 由于当天的最大利润只与前一天有关，并且每天只有0、1两种状态，那么可以只用<code>dp0</code>表示当天未持有股票状态，<code>dp1</code>表示当天持有股票状态，每过一天用最新值覆盖<code>dp0、dp1</code>即可。那么到了最后一天的最大利润可以用<code>dp0</code>表示即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp0 = Math.max(dp0, dp1+prices[i]);</span><br><span class="line">        dp1 = Math.max(dp1, dp0-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p><font color=red><strong>方法二：</strong></font><strong>贪心算法</strong>    <font color=blue><strong>时间复杂度O(n)，空间复杂度O(1)</strong></font></p><p>​买入股票的最大利润，其实就是每相邻两天利润差大于0的和。比如1，4，3，12这一组数，我们只要避开两个产生负数的数，即可保证利润最大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max += Math.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>*九、跳跃游戏</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909143444.png" alt=""></p><p><font color=red><strong>思路：</strong></font><strong>贪心算法</strong>   <font color=blue><strong>时间复杂度O(n)，空间复杂度O(1)。</strong></font></p><p>​存在可到达的最大的位置maxend，判断当前位置是否小于maxend。</p><p>​若小于，则说明存在步数可以到达此位置</p><p>​判断此位置可跳跃到的位置是否大于maxend。</p><p>​若大于，则更新maxend，反之继续遍历。</p><p>​若大于，则说明当前位置不存在步数可以到达，直接返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxend</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; maxend) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxend = Math.max(maxend, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>*十、跳跃游戏2</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909165449.png" alt=""></p><p><strong><font color=red>思路：</font>贪心算法   <font color=blue>时间复杂度O(n)，空间复杂度O(1)。</font></strong></p><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230909170300.png" alt=""></p><p>​从<code>下标0</code>开始遍历，其能够走到的最远的距离是走到<code>下标2</code>，此时记录<code>max = 2，end = 2，step = 1</code>。遍历到<code>下标1</code>的时候，发现<code>下标1</code>最大能走到<code>下标4</code>，此时更新<code>max = 4</code>，但是不能更新<code>end</code>，因为上一步的<code>end</code>还没走完，需要走完上一步的<code>end</code>之后，才能确定下一步需要走到哪里。遍历到<code>下标2</code>的时候，发现<code>下标2</code>最大只能走到<code>下标3</code>，小于<code>max</code>，此时<code>end</code>已经走完，确定了<code>max = 4</code>，重新设置<code>end = 4</code>，<code>step ++</code>。此处就可以确定是使用<code>下标1</code>的时候，这步能够走到最远为<code>下标4</code>。依次遍历，由于我们当前代码设定<code>step</code>的自增是在起点时自增，而不是走完后自增，所以为了避免最后一步刚好是在数组的最后一个数时，导致程序又把最后一个数当成是起点，所以这里让数组的界限设置为<code>nums.length - 1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        max = Math.max(nums[i] + i, max);   <span class="comment">// 持续更新跳跃的最大点，结算时确定下次要跳的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i == end) &#123;   <span class="comment">// 已经遍历到了上一次起跳的最大位置的终点（结算）</span></span><br><span class="line">            end = max;   <span class="comment">// 设置下次需要跳到的位置的终点</span></span><br><span class="line">            step ++;     <span class="comment">// 跳动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>*十一、O(1)插入、删除、随机获取</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230911152620.png" alt=""></p><p><font color=red><strong>思路</strong></font>：<font color=blue><strong>变长数组无法解决插入和删除时间复杂度为O(1)，哈希表无法解决获取随机数时间复杂度为O(1)。所以使用变长数组 + 哈希表</strong></font></p><p>操作插入时，首先判断<code>val</code>是否存在哈希表中，如果存在，则返回<code>false</code>，如果不存在，则插入<code>val</code>。操作如下：</p><p>​1、在变长数组末尾加入<code>val</code></p><p>​2、将加入后的<code>(val, index)</code>放入哈希表，返回<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.add(val);</span><br><span class="line">    map.put(val, nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作删除时，首先判断<code>val</code>是否存在哈希表中，如果不存在，则返回<code>false</code>，如果存在，则操作如下：</p><p>​1、在哈希表中，获取要删除的值<code>val</code>的下标<code>index</code>。</p><p>​2、将变长数组中的最后一个数<code>end</code>，放入下标为<code>index</code>中，并将这个数的<code>(end, index)</code>在哈希表中更新。</p><p>​2、删除变长数组中的最后一个数<code>end</code>，删除哈希表中<code>key</code>为<code>val</code>的键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.containsKey(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(val);   </span><br><span class="line">    nums.set(index, end);</span><br><span class="line">    map.put(end, index);</span><br><span class="line">    nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">    map.remove(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>*十二、除自身以外数组的乘积</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230912162504.png" alt=""></p><p><font color=red><strong>思路：</strong></font><font color=blue><strong>将当前数组每个节点的左侧乘积和右侧乘积单独算出来，然后一一对应相乘。下标0的左侧乘积为 1，下标n的右侧乘积为 1</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        answer[i] = answer[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];      <span class="comment">// 首先存放每个节点的左侧乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        answer[j] = answer[j] * R;</span><br><span class="line">        R = R * nums[j];                              <span class="comment">// 下一个节点的右侧乘积 = 当前节点 * 当前节点右侧乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>*十三、加油站</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230913185934.png" alt=""></p><p><font color=red><strong>思路：</strong></font><font color=blue> <strong>无论从哪个点开始，只要总油量大于总耗油量（即剩余油量大于 0），就肯定可以跑完一圈，所以使用sum记录剩余油量，如果从当前点出发的总剩余油量（sum）小于上一步到达当前点的总剩余油量（sum），则从当前点出发无法到达下一步，则存储下一步的坐标表示当前点无法作为起点，下一步作为起点。依次循环，直到遍历结束</strong></font></p><p><code>sum</code>记录着每一步的剩余油量的总和，即使走到<code>下标4</code>，需要去判断其是否能走一圈，也需要用到前面三个点的剩余油量，<code>sum</code>又有记录，所以可以直接将<code>下标4</code>的剩余油量和<code>sum</code>相加。</p><p>例如：若<code>下标3</code>能够到达<code>下标4</code>，那么<code>for</code>中的<code>if</code>不会进入，<code>idx</code>还是保留着（从<code>下标2</code>开始走时，无法走到<code>下标3</code>，<code>idx</code>始终保留无法到达下一步坐标的当前点的下一步的坐标，这样才能确定是从哪一步开始可以到达下一步从而绕一圈的）<code>下标3</code>。如果当前剩余油量+之前剩余总油量（sum）小于0，则说明，无法绕一圈。反之，则可以绕一圈，且起点为<code>idx</code>（即使下标1无法到达下标2，下标2无法到达下标3，但是下标3可以到达下标4，且到达之后的剩余油量可以弥补之前的空缺，那么就可绕一圈，且起点为下标3）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(gas == <span class="literal">null</span> || cost == <span class="literal">null</span> || gas.length == <span class="number">0</span> || cost.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">        sum += gas[i] - cost[i];       <span class="comment">// 总的剩余油量</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; min) &#123;                <span class="comment">// 判断当前总剩余油量和上一次总剩余油量的大小，若小于，则说明当前点不能到达下一点</span></span><br><span class="line">            min = sum;                 <span class="comment">// 更新总的剩余油量</span></span><br><span class="line">            idx = i + <span class="number">1</span>;   <span class="comment">// 保存当前点的下一点为idx，若循环不再进来，则说明可以从idx出发到达下一步</span></span><br><span class="line">        &#125;   <span class="comment">// 当前循环进if，说明无法到达下一步，又能够到达下一步的不会进来，所以idx使用i+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &lt; <span class="number">0</span> ? -<span class="number">1</span> : idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>**十四、分发糖果</h1><p><img src="https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/20230914200424.png" alt=""></p><p><font color=red><strong>思路：</strong></font></p><p>**情况1：先升序，后降序。**此时第一个人肯定会有一颗糖，记录pre = 1，在升序部分，后面每一步都作pre += 1，记录升序的数量inc（到达最高点时，也会将最高点算到inc中，但是降序时，最高点也要算到降序部分，但是降序部分没法从最高点开始算起，只能遍历到最高点的后一个点时，才会知晓数组开始降序，所以降序会有特殊处理，后面会用降序的数量和其比较）。开始降序时，使用dec表示降序的数量（如果前一个值是最高点，后一个值开始降序，那么dec只是从后一个值开始算起降序的数量，其实最高点也要算是降序的一部分，当dec和inc相等时，说明降序部分肯定超过升序部分了，所以dec要加上1才能当作总的降序部分，如 1 2 3 4 3 2 1 0。升序部分是 1 2 3 4 inc = 4，降序部分是 4 3 2 1 0，但是只有遍历到3时才知道降序开始，dec是从3开始算起 dec = 4，但是实际是5，所以当dec == inc时，dec需要累加），也可以看作是降序部分，总的应发的糖果数（因为降序是从高点往下，但是dec是从0开始的，所以无法满足dec的每一次累加的值，是降序每个小孩的应发的糖果，只能算是应发的总糖果）。如果dec == inc时，降序部分超过了升序部分，dec应当累加。</p><p>**情况2：先降序，后升序。**开始降序时，无法知晓后一步是否变成升序操作，所以降序的每一步都需要将pre重新置为1，若后一步变成升序，那么后一步的pre就是2，升序部分便可以看作是从这一步开始的。</p><p>**情况3：先升序，平序，后降序。**由于平序部分没有大小关系，所以从第二个平序数开始，pre可以用最小的数1即可，并且升序数量inc也可以看作是1，然后再按照降序部分的操作计算dec的值即可，如 5 5 3，此时inc为1，dec最开始为1，刚好和inc相等，那么dec需要累加1，因为实际dec是2。</p><p>**情况4：先降序，平序，后升序。**由于开始降序时，是从1开始计算的，所以降序的最低点就可以看作是1（只不过倒序了而已），平序部分只用给最小数1即可，即pre = 1，然后再按照升序的逻辑计算，最后一个平序数当然就可以看作是升序数的起点。</p><p>**汇总：**整合这4种情况，若数组只有一个数，则只需要返回1，若有两个数，则可以看作是以上四种情况的任何一种情况。使用ret  = 1作为结果的初始值，从数组的第二个开始遍历，升序、平序时，ret = ret + pre，降序时，ret = ret + dec，最后返回ret即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">1</span>, dec = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt;= ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            dec = <span class="number">0</span>;</span><br><span class="line">            pre = ratings[i] == ratings[i - <span class="number">1</span>] ? <span class="number">1</span> : pre + <span class="number">1</span>;</span><br><span class="line">            ret += pre;</span><br><span class="line">            inc = pre;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dec++;</span><br><span class="line">            <span class="keyword">if</span> (dec == inc) &#123;</span><br><span class="line">                dec++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += dec;</span><br><span class="line">            pre = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、&lt;strong&gt;合并两个有序数组&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kw520/bigkel-imgs/main/imgs/clipboard.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
