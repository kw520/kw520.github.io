{"meta":{"title":"BIGKEL BLOB","subtitle":"","description":"","author":"jiakuan.chen","url":"https://github.com/kw520/kw520.github.io","root":"/"},"pages":[{"title":"About","date":"2023-09-09T10:09:56.459Z","updated":"2023-09-09T10:09:56.459Z","comments":true,"path":"about/index.html","permalink":"https://github.com/kw520/kw520.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2023-09-09T10:09:56.476Z","updated":"2023-09-09T10:09:56.476Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/kw520/kw520.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2023-09-09T10:09:56.502Z","updated":"2023-09-09T10:09:56.502Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/kw520/kw520.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"LeetCode做题笔记","date":"2023-09-05T10:56:11.783Z","updated":"2023-09-14T12:51:32.608Z","comments":true,"path":"2023/09/05/LeetCode做题笔记/","link":"","permalink":"https://github.com/kw520/kw520.github.io/2023/09/05/LeetCode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、合并两个有序数组 思路：从原始nums1和nums2的末尾开始比较，不比nums2小的数往nums1的后面放，若一方遍历完，则另一方继续遍历直到结束。 三个指针，分别为 int one = m - 1; ​ int two = n - 1; ​ int tail = m + n - 1; 若one == -1，则nums1[tail] = nums2[two]，且two–，tail–； 反之若two == -1，则nums1[tail] = nums1[one]，且one–，tail–； 反之若nums1[one] &gt;= nums2[two]，则nums1[tail] = nums1[one]，且one–，tail–； 反之，则nums1[tail] = nums2[two]，且two–，tail–； 1234567891011121314151617181920212223public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int one = m - 1; int two = n - 1; int tail = m + n - 1; while(one &gt; -1 || two &gt; -1) &#123; int cur = 0; if(one == -1) &#123; cur = nums2[two]; two --; &#125; else if(two == -1) &#123; cur = nums1[one]; one --; &#125; else if(nums1[one] &gt;= nums2[two]) &#123; cur = nums1[one]; one --; &#125; else &#123; cur = nums2[two]; two --; &#125; nums1[tail] = cur; tail --; &#125;&#125; 二、移除元素 思路： ​ 方法一、双指针，都从头开始，R指针若不等于val，则赋值给L后，L和R同时右移，若等于，则L不动，R右移寻找不等于val的值赋值给L ​ 方法二、双指针，L指向头，R指向尾，L &lt; R，若L指针不等于val，则右移，若等于val，则R指针值赋值给L指针，R指针左移，一直循环。 12345678910111213public int removeElement(int[] nums, int val) &#123; int left = 0; int right = nums.length -1; while (left &lt;= right) &#123; if (nums[left] == val) &#123; nums[left] = nums[right]; right--; &#125; else &#123; left++; &#125; &#125; return left;&#125; 三、删除有序数组中的重复项 思路：指针p指向第一个数，指针q指向第二个数，如果两个值相等，则q++。如果不相等，当q - p &gt; 1时（避免0，1，2，3，4这种极端情况，表示当p和q不相邻时，才用调换值，避免自己和自己调换），调换q和p+1的值，且p++， q++。 1234567891011121314public int removeDuplicates(int[] nums) &#123; int p = 0; int q = 1; while(q &lt; nums.length) &#123; if(nums[q] != nums[p]) &#123; if(q - p &gt; 1) &#123; nums[p + 1] = nums[q]; &#125; p ++; &#125; q ++; &#125; return p + 1;&#125; *四、有序数组中只能重复两次 思路：指针slow、fast都指向下标为2的位置 ​ 若fast == slow[n-2]，由于slow[n]之前已经是整理好后的，并且数组有序，那么slow[n-1]不可能比slow[n-2]小，也不可能比fast大，所以此时必然有fast == slow[n-2] == slow[n-1]，则需要fast右移找到不等于slow[n-2]的值赋值给slow[n]（若fast找到的值和slow当前值相等，则可以不用赋值），然后slow和fast同时右移。 ​ 若fast != slow[n-2]，则说明slow[n]之前排好序的slow[n-2] &lt; slow[n-1]，那么此时fast的值可以给slow[n] 123456789101112131415161718public int removeDuplicates(int[] nums) &#123; int n = nums.length; if(n &lt; 3) &#123; return n; &#125; int slow = 2; int fast = 2; while(fast &lt; n) &#123; if(nums[fast] != nums[slow -2]) &#123; if(nums[fast] != nums[slow]) &#123; nums[slow] = nums[fast]; &#125; slow ++; &#125; fast ++; &#125; return slow;&#125; 五、多数元素 思路： ​ 方法一、排序，多数元素一定占据n/2的位置。 ​ 方法二、排序，p、q指针从0开始，若q == p，则q向右遍历，若q != p，则q-1-p+1为当前数的个数，若此个数大于n/2，则返回nums[p]，反之则p = q，继续向后遍历，直到q &gt;= n为止 1234567891011121314151617public int majorityElement(int[] nums) &#123; Arrays.sort(nums); int n = nums.length; int more = n / 2; int p = 0; int q = 0; while(q &lt; n) &#123; if(nums[p] == nums[q]) &#123; q ++; &#125; else if(q - p &gt; more)&#123; break; &#125; else &#123; p = q; &#125; &#125; return nums[p];&#125; *六、轮转数组 思路：实际轮转次数 k = k – 整数*n，比如n = 5，轮转6次，那么实际次数为1，n = 5，轮转2次，实际次数为2。将nums全部反转，然后根据实际轮转次数分割，[0, k - 1] 和 [k, n - 1]再各自反转。 12345678910111213141516public void rotate(int[] nums, int k) &#123; k = k % nums.length; swap(nums, 0, nums.length - 1); swap(nums, 0, k - 1); swap(nums, k, nums.length - 1);&#125;public void swap(int[] nums, int start, int end) &#123; while(start &lt; end) &#123; nums[start] = nums[start] ^ nums[end]; nums[end] = nums[start] ^ nums[end]; nums[start] = nums[start] ^ nums[end]; start ++; end --; &#125;&#125; 七、买卖股票最佳时机 思路：指针p和q分别指向0和1，记录最大利润max = 0，q向后移动，若 q - p &lt; 0，则说明 q 点买进的利润一定大于当前 p 点买进的利润，所以 p 点重新定位，p = q。若 q - p &gt; 0，则判断利润是否比之前的利润 max 大，大则覆盖。 123456789101112131415public int maxProfit(int[] prices) &#123; int max = 0; int p = 0; int q = 1; while(q &lt; prices.length) &#123; int money = prices[q] - prices[p]; if(money &gt; 0) &#123; max = money &gt; max ? money : max; &#125; else &#123; p = q; &#125; q ++; &#125; return max;&#125; *八、买卖股票最佳时机2 思路： 方法一：动态规划 时间复杂度O(n)，空间复杂度O(n) ​ 每天手里股票的状态有两种，dp[i,0]表示第 i 天未持有股票，dp[i,1]表示第 i 天持有股票。 ​ dp[i,0]的时候，可以看作是 i-1 天已经卖出了股票，i 天还没有买进，即dp[i-1,0]。或者是 i-1 天买进了股票，i 天卖出，即dp[i-1,1] + price[i]。所以 i 天最大的利润可以可以列出如下转换方程： dp[i,0] = max{dp[i-1,0], dp[i-1,1]+price[i]} ​ dp[i,1]的时候，可以看作是 i-1 天买入了股票，i 天还没有卖出，即dp[i-1,1]。或者是 i-1 天卖出了股票，i 天买入，即dp[i-1,0] - price[i]。所以 i 天最大的利润可以列出如下转换方程： dp[i,1] = max{dp[i-1,1], dp[i-1,0]-price[i]} ​ 到最后一天的时候，卖出股票肯定要比买入股票利润高，所以只用返回dp[n,0]即可。(空间优化) 由于当天的最大利润只与前一天有关，并且每天只有0、1两种状态，那么可以只用dp0表示当天未持有股票状态，dp1表示当天持有股票状态，每过一天用最新值覆盖dp0、dp1即可。那么到了最后一天的最大利润可以用dp0表示即可。 12345678910public int maxProfit(int[] prices) &#123; int n = prices.length; int dp0 = 0; int dp1 = -prices[0]; for(int i = 1; i &lt; n; i++) &#123; dp0 = Math.max(dp0, dp1+prices[i]); dp1 = Math.max(dp1, dp0-prices[i]); &#125; return dp0;&#125; ​ 方法二：贪心算法 时间复杂度O(n)，空间复杂度O(1) ​ 买入股票的最大利润，其实就是每相邻两天利润差大于0的和。比如1，4，3，12这一组数，我们只要避开两个产生负数的数，即可保证利润最大。 12345678public int maxProfit(int[] prices) &#123; int n = prices.length; int max = 0; for(int i = 1; i &lt; n; i++) &#123; max += Math.max(0, prices[i] - prices[i - 1]); &#125; return max;&#125; *九、跳跃游戏 思路：贪心算法 时间复杂度O(n)，空间复杂度O(1)。 ​ 存在可到达的最大的位置maxend，判断当前位置是否小于maxend。 ​ 若小于，则说明存在步数可以到达此位置 ​ 判断此位置可跳跃到的位置是否大于maxend。 ​ 若大于，则更新maxend，反之继续遍历。 ​ 若大于，则说明当前位置不存在步数可以到达，直接返回false。 12345678910public boolean canJump(int[] nums) &#123; int maxend = 0; for(int i = 0; i &lt; nums.length; i++) &#123; if(i &gt; maxend) &#123; return false; &#125; maxend = Math.max(maxend, nums[i] + i); &#125; return true;&#125; *十、跳跃游戏2 思路：贪心算法 时间复杂度O(n)，空间复杂度O(1)。 ​ 从下标0开始遍历，其能够走到的最远的距离是走到下标2，此时记录max = 2，end = 2，step = 1。遍历到下标1的时候，发现下标1最大能走到下标4，此时更新max = 4，但是不能更新end，因为上一步的end还没走完，需要走完上一步的end之后，才能确定下一步需要走到哪里。遍历到下标2的时候，发现下标2最大只能走到下标3，小于max，此时end已经走完，确定了max = 4，重新设置end = 4，step ++。此处就可以确定是使用下标1的时候，这步能够走到最远为下标4。依次遍历，由于我们当前代码设定step的自增是在起点时自增，而不是走完后自增，所以为了避免最后一步刚好是在数组的最后一个数时，导致程序又把最后一个数当成是起点，所以这里让数组的界限设置为nums.length - 1。 12345678910111213public int jump(int[] nums) &#123; int max = 0; int end = 0; int step = 0; for(int i = 0; i &lt; nums.length - 1; i++) &#123; max = Math.max(nums[i] + i, max); // 持续更新跳跃的最大点，结算时确定下次要跳的位置 if(i == end) &#123; // 已经遍历到了上一次起跳的最大位置的终点（结算） end = max; // 设置下次需要跳到的位置的终点 step ++; // 跳动 &#125; &#125; return step;&#125; *十一、O(1)插入、删除、随机获取 思路：变长数组无法解决插入和删除时间复杂度为O(1)，哈希表无法解决获取随机数时间复杂度为O(1)。所以使用变长数组 + 哈希表 操作插入时，首先判断val是否存在哈希表中，如果存在，则返回false，如果不存在，则插入val。操作如下： ​ 1、在变长数组末尾加入val ​ 2、将加入后的(val, index)放入哈希表，返回true 12345678public boolean insert(int val) &#123; if(map.containsKey(val)) &#123; return false; &#125; nums.add(val); map.put(val, nums.size() - 1); return true;&#125; 操作删除时，首先判断val是否存在哈希表中，如果不存在，则返回false，如果存在，则操作如下： ​ 1、在哈希表中，获取要删除的值val的下标index。 ​ 2、将变长数组中的最后一个数end，放入下标为index中，并将这个数的(end, index)在哈希表中更新。 ​ 2、删除变长数组中的最后一个数end，删除哈希表中key为val的键值对。 123456789101112public boolean remove(int val) &#123; if(!map.containsKey(val)) &#123; return false; &#125; int end = nums.get(nums.size() - 1); int index = map.get(val); nums.set(index, end); map.put(end, index); nums.remove(nums.size() - 1); map.remove(val); return true;&#125; *十二、除自身以外数组的乘积 思路：将当前数组每个节点的左侧乘积和右侧乘积单独算出来，然后一一对应相乘。下标0的左侧乘积为 1，下标n的右侧乘积为 1 1234567891011121314public int[] productExceptSelf(int[] nums) &#123; int length = nums.length; int[] answer = new int[length]; answer[0] = 1; for(int i = 1; i &lt; length; i++) &#123; answer[i] = answer[i - 1] * nums[i - 1]; // 首先存放每个节点的左侧乘积 &#125; int R = 1; for(int j = length - 1; j &gt;= 0; j--) &#123; answer[j] = answer[j] * R; R = R * nums[j]; // 下一个节点的右侧乘积 = 当前节点 * 当前节点右侧乘积 &#125; return answer;&#125; *十三、加油站 思路： 无论从哪个点开始，只要总油量大于总耗油量（即剩余油量大于 0），就肯定可以跑完一圈，所以使用sum记录剩余油量，如果从当前点出发的总剩余油量（sum）小于上一步到达当前点的总剩余油量（sum），则从当前点出发无法到达下一步，则存储下一步的坐标表示当前点无法作为起点，下一步作为起点。依次循环，直到遍历结束 sum记录着每一步的剩余油量的总和，即使走到下标4，需要去判断其是否能走一圈，也需要用到前面三个点的剩余油量，sum又有记录，所以可以直接将下标4的剩余油量和sum相加。 例如：若下标3能够到达下标4，那么for中的if不会进入，idx还是保留着（从下标2开始走时，无法走到下标3，idx始终保留无法到达下一步坐标的当前点的下一步的坐标，这样才能确定是从哪一步开始可以到达下一步从而绕一圈的）下标3。如果当前剩余油量+之前剩余总油量（sum）小于0，则说明，无法绕一圈。反之，则可以绕一圈，且起点为idx（即使下标1无法到达下标2，下标2无法到达下标3，但是下标3可以到达下标4，且到达之后的剩余油量可以弥补之前的空缺，那么就可绕一圈，且起点为下标3）。 1234567891011121314151617public int canCompleteCircuit(int[] gas, int[] cost) &#123; if(gas == null || cost == null || gas.length == 0 || cost.length == 0) &#123; return 0; &#125; int n = gas.length; int sum = 0; int min = 0; int idx = 0; for (int i = 0;i &lt; n; i++) &#123; sum += gas[i] - cost[i]; // 总的剩余油量 if(sum &lt; min) &#123; // 判断当前总剩余油量和上一次总剩余油量的大小，若小于，则说明当前点不能到达下一点 min = sum; // 更新总的剩余油量 idx = i + 1; // 保存当前点的下一点为idx，若循环不再进来，则说明可以从idx出发到达下一步 &#125; // 当前循环进if，说明无法到达下一步，又能够到达下一步的不会进来，所以idx使用i+1 &#125; return sum &lt; 0 ? -1 : idx;&#125; **十四、分发糖果 思路： **情况1：先升序，后降序。**此时第一个人肯定会有一颗糖，记录pre = 1，在升序部分，后面每一步都作pre += 1，记录升序的数量inc（到达最高点时，也会将最高点算到inc中，但是降序时，最高点也要算到降序部分，但是降序部分没法从最高点开始算起，只能遍历到最高点的后一个点时，才会知晓数组开始降序，所以降序会有特殊处理，后面会用降序的数量和其比较）。开始降序时，使用dec表示降序的数量（如果前一个值是最高点，后一个值开始降序，那么dec只是从后一个值开始算起降序的数量，其实最高点也要算是降序的一部分，当dec和inc相等时，说明降序部分肯定超过升序部分了，所以dec要加上1才能当作总的降序部分，如 1 2 3 4 3 2 1 0。升序部分是 1 2 3 4 inc = 4，降序部分是 4 3 2 1 0，但是只有遍历到3时才知道降序开始，dec是从3开始算起 dec = 4，但是实际是5，所以当dec == inc时，dec需要累加），也可以看作是降序部分，总的应发的糖果数（因为降序是从高点往下，但是dec是从0开始的，所以无法满足dec的每一次累加的值，是降序每个小孩的应发的糖果，只能算是应发的总糖果）。如果dec == inc时，降序部分超过了升序部分，dec应当累加。 **情况2：先降序，后升序。**开始降序时，无法知晓后一步是否变成升序操作，所以降序的每一步都需要将pre重新置为1，若后一步变成升序，那么后一步的pre就是2，升序部分便可以看作是从这一步开始的。 **情况3：先升序，平序，后降序。**由于平序部分没有大小关系，所以从第二个平序数开始，pre可以用最小的数1即可，并且升序数量inc也可以看作是1，然后再按照降序部分的操作计算dec的值即可，如 5 5 3，此时inc为1，dec最开始为1，刚好和inc相等，那么dec需要累加1，因为实际dec是2。 **情况4：先降序，平序，后升序。**由于开始降序时，是从1开始计算的，所以降序的最低点就可以看作是1（只不过倒序了而已），平序部分只用给最小数1即可，即pre = 1，然后再按照升序的逻辑计算，最后一个平序数当然就可以看作是升序数的起点。 **汇总：**整合这4种情况，若数组只有一个数，则只需要返回1，若有两个数，则可以看作是以上四种情况的任何一种情况。使用ret = 1作为结果的初始值，从数组的第二个开始遍历，升序、平序时，ret = ret + pre，降序时，ret = ret + dec，最后返回ret即可。 123456789101112131415161718192021public int candy(int[] ratings) &#123; int n = ratings.length; int ret = 1; int inc = 1, dec = 0, pre = 1; for (int i = 1; i &lt; n; i++) &#123; if (ratings[i] &gt;= ratings[i - 1]) &#123; dec = 0; pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1; ret += pre; inc = pre; &#125; else &#123; dec++; if (dec == inc) &#123; dec++; &#125; ret += dec; pre = 1; &#125; &#125; return ret;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}