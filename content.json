{"meta":{"title":"BIGKEL BLOB","subtitle":"","description":"","author":"jiakuan.chen","url":"https://github.com/kw520/kw520.github.io","root":"/"},"pages":[{"title":"Categories","date":"2023-09-09T10:09:56.476Z","updated":"2023-09-09T10:09:56.476Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/kw520/kw520.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2023-09-09T10:09:56.459Z","updated":"2023-09-09T10:09:56.459Z","comments":true,"path":"about/index.html","permalink":"https://github.com/kw520/kw520.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2023-09-09T10:09:56.502Z","updated":"2023-09-09T10:09:56.502Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/kw520/kw520.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"面试总结","date":"2023-10-18T06:52:10.174Z","updated":"2023-10-23T10:48:03.246Z","comments":true,"path":"2023/10/18/面试总结/","link":"","permalink":"https://github.com/kw520/kw520.github.io/2023/10/18/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"一、Spring","categories":[],"tags":[]},{"title":"","slug":"leetcode做题笔记","date":"2023-09-05T10:56:11.783Z","updated":"2023-11-07T02:58:25.365Z","comments":true,"path":"2023/09/05/leetcode做题笔记/","link":"","permalink":"https://github.com/kw520/kw520.github.io/2023/09/05/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、合并两个有序数组 思路：从原始nums1和nums2的末尾开始比较，不比nums2小的数往nums1的后面放，若一方遍历完，则另一方继续遍历直到结束。 三个指针，分别为 int one &#x3D; m - 1; ​ int two &#x3D; n - 1; ​ int tail &#x3D; m + n - 1; 若one &#x3D;&#x3D; -1，则nums1[tail] &#x3D; nums2[two]，且two–，tail–； 反之若two &#x3D;&#x3D; -1，则nums1[tail] &#x3D; nums1[one]，且one–，tail–； 反之若nums1[one] &gt;&#x3D; nums2[two]，则nums1[tail] &#x3D; nums1[one]，且one–，tail–； 反之，则nums1[tail] &#x3D; nums2[two]，且two–，tail–； 1234567891011121314151617181920212223public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int one = m - 1; int two = n - 1; int tail = m + n - 1; while(one &gt; -1 || two &gt; -1) &#123; int cur = 0; if(one == -1) &#123; cur = nums2[two]; two --; &#125; else if(two == -1) &#123; cur = nums1[one]; one --; &#125; else if(nums1[one] &gt;= nums2[two]) &#123; cur = nums1[one]; one --; &#125; else &#123; cur = nums2[two]; two --; &#125; nums1[tail] = cur; tail --; &#125;&#125; 二、移除元素 思路： ​ 方法一、双指针，都从头开始，R指针若不等于val，则赋值给L后，L和R同时右移，若等于，则L不动，R右移寻找不等于val的值赋值给L ​ **方法二、双指针，L指向头，R指向尾，L &lt; R，若L指针不等于val，则右移，若等于val，则R指针值赋值给L指针，R指针左移，一直循环。** 12345678910111213public int removeElement(int[] nums, int val) &#123; int left = 0; int right = nums.length -1; while (left &lt;= right) &#123; if (nums[left] == val) &#123; nums[left] = nums[right]; right--; &#125; else &#123; left++; &#125; &#125; return left;&#125; 三、删除有序数组中的重复项 思路：指针p指向第一个数，指针q指向第二个数，如果两个值相等，则q++。如果不相等，当q - p &gt; 1时（避免0，1，2，3，4这种极端情况，表示当p和q不相邻时，才用调换值，避免自己和自己调换），调换q和p+1的值，且p++， q++。 1234567891011121314public int removeDuplicates(int[] nums) &#123; int p = 0; int q = 1; while(q &lt; nums.length) &#123; if(nums[q] != nums[p]) &#123; if(q - p &gt; 1) &#123; nums[p + 1] = nums[q]; &#125; p ++; &#125; q ++; &#125; return p + 1;&#125; *四、有序数组中只能重复两次 思路：指针slow、fast都指向下标为2的位置 ​ 若fast &#x3D;&#x3D; slow[n-2]，由于slow[n]之前已经是整理好后的，并且数组有序，那么slow[n-1]不可能比slow[n-2]小，也不可能比fast大，所以此时必然有fast &#x3D;&#x3D; slow[n-2] &#x3D;&#x3D; slow[n-1]，则需要fast右移找到不等于slow[n-2]的值赋值给slow[n]（若fast找到的值和slow当前值相等，则可以不用赋值），然后slow和fast同时右移。 ​ **若fast !&#x3D; slow[n-2]，则说明slow[n]之前排好序的slow[n-2] &lt; slow[n-1]，那么此时fast的值可以给slow[n]** 123456789101112131415161718public int removeDuplicates(int[] nums) &#123; int n = nums.length; if(n &lt; 3) &#123; return n; &#125; int slow = 2; int fast = 2; while(fast &lt; n) &#123; if(nums[fast] != nums[slow -2]) &#123; if(nums[fast] != nums[slow]) &#123; nums[slow] = nums[fast]; &#125; slow ++; &#125; fast ++; &#125; return slow;&#125; 五、多数元素 思路： ​ 方法一、排序，多数元素一定占据n&#x2F;2的位置。 ​ 方法二、排序，p、q指针从0开始，若q &#x3D;&#x3D; p，则q向右遍历，若q !&#x3D; p，则q-1-p+1为当前数的个数，若此个数大于n&#x2F;2，则返回nums[p]，反之则p &#x3D; q，继续向后遍历，直到q &gt;&#x3D; n为止 1234567891011121314151617public int majorityElement(int[] nums) &#123; Arrays.sort(nums); int n = nums.length; int more = n / 2; int p = 0; int q = 0; while(q &lt; n) &#123; if(nums[p] == nums[q]) &#123; q ++; &#125; else if(q - p &gt; more)&#123; break; &#125; else &#123; p = q; &#125; &#125; return nums[p];&#125; *六、轮转数组 思路：实际轮转次数 k &#x3D; k – 整数*n，比如n &#x3D; 5，轮转6次，那么实际次数为1，n &#x3D; 5，轮转2次，实际次数为2。将nums全部反转，然后根据实际轮转次数分割，[0, k - 1] 和 [k, n - 1]再各自反转。 12345678910111213141516public void rotate(int[] nums, int k) &#123; k = k % nums.length; swap(nums, 0, nums.length - 1); swap(nums, 0, k - 1); swap(nums, k, nums.length - 1);&#125;public void swap(int[] nums, int start, int end) &#123; while(start &lt; end) &#123; nums[start] = nums[start] ^ nums[end]; nums[end] = nums[start] ^ nums[end]; nums[start] = nums[start] ^ nums[end]; start ++; end --; &#125;&#125; 七、买卖股票最佳时机 思路：指针p和q分别指向0和1，记录最大利润max &#x3D; 0，q向后移动，若 q - p &lt; 0，则后面的数字在和q求差时一定比和p求差时大，说明 q 点买进的利润一定大于当前 p 点买进的利润，所以 p 点重新定位，p &#x3D; q。若 q - p &gt; 0，则判断利润是否比之前的利润 max 大，大则覆盖。 123456789101112131415public int maxProfit(int[] prices) &#123; int max = 0; int p = 0; int q = 1; while(q &lt; prices.length) &#123; int money = prices[q] - prices[p]; if(money &gt; 0) &#123; max = money &gt; max ? money : max; &#125; else &#123; p = q; &#125; q ++; &#125; return max;&#125; *八、买卖股票最佳时机2 思路： 方法一：动态规划 时间复杂度O(n)，空间复杂度O(n) ​ 每天手里股票的状态有两种，dp[i,0]表示第 i 天未持有股票，dp[i,1]表示第 i 天持有股票。 ​ dp[i,0]的时候，可以看作是 i-1 天已经卖出了股票，i 天还没有买进，即dp[i-1,0]。或者是 i-1 天买进了股票，i 天卖出，即dp[i-1,1] + price[i]。所以 i 天最大的利润可以可以列出如下转换方程： dp[i,0] &#x3D; max{dp[i-1,0], dp[i-1,1]+price[i]} ​ dp[i,1]的时候，可以看作是 i-1 天买入了股票，i 天还没有卖出，即dp[i-1,1]。或者是 i-1 天卖出了股票，i 天买入，即dp[i-1,0] - price[i]。所以 i 天最大的利润可以列出如下转换方程： dp[i,1] &#x3D; max{dp[i-1,1], dp[i-1,0]-price[i]} ​ 到最后一天的时候，卖出股票肯定要比买入股票利润高，所以只用返回dp[n,0]即可。(空间优化) 由于当天的最大利润只与前一天有关，并且每天只有0、1两种状态，那么可以只用dp0表示当天未持有股票状态，dp1表示当天持有股票状态，每过一天用最新值覆盖dp0、dp1即可。那么到了最后一天的最大利润可以用dp0表示即可。 12345678910public int maxProfit(int[] prices) &#123; int n = prices.length; int dp0 = 0; int dp1 = -prices[0]; for(int i = 1; i &lt; n; i++) &#123; dp0 = Math.max(dp0, dp1+prices[i]); dp1 = Math.max(dp1, dp0-prices[i]); &#125; return dp0;&#125; ​ 方法二：贪心算法 时间复杂度O(n)，空间复杂度O(1) ​ 买入股票的最大利润，其实就是每相邻两天利润差大于0的和。比如1，4，3，12这一组数，我们只要避开两个产生负数的数，即可保证利润最大。 12345678public int maxProfit(int[] prices) &#123; int n = prices.length; int max = 0; for(int i = 1; i &lt; n; i++) &#123; max += Math.max(0, prices[i] - prices[i - 1]); &#125; return max;&#125; *九、跳跃游戏 思路：贪心算法 时间复杂度O(n)，空间复杂度O(1)。 ​ 存在可到达的最大的位置maxend，判断当前位置是否小于maxend。 ​ 若小于，则说明存在步数可以到达此位置 ​ 判断此位置可跳跃到的位置是否大于maxend。 ​ 若大于，则更新maxend，反之继续遍历。 ​ 若大于，则说明当前位置不存在步数可以到达，直接返回false。 12345678910public boolean canJump(int[] nums) &#123; int maxend = 0; for(int i = 0; i &lt; nums.length; i++) &#123; if(i &gt; maxend) &#123; return false; &#125; maxend = Math.max(maxend, nums[i] + i); &#125; return true;&#125; *十、跳跃游戏2 思路：贪心算法 时间复杂度O(n)，空间复杂度O(1)。 ​ 从下标0开始遍历，其能够走到的最远的距离是走到下标2，此时记录max = 2，end = 2，step = 1。遍历到下标1的时候，发现下标1最大能走到下标4，此时更新max = 4，但是不能更新end，因为上一步的end还没走完，需要走完上一步的end之后，才能确定下一步需要走到哪里。遍历到下标2的时候，发现下标2最大只能走到下标3，小于max，此时end已经走完，确定了max = 4，重新设置end = 4，step ++。此处就可以确定是使用下标1的时候，这步能够走到最远为下标4。依次遍历，由于我们当前代码设定step的自增是在起点时自增，而不是走完后自增，所以为了避免最后一步刚好是在数组的最后一个数时，导致程序又把最后一个数当成是起点，所以这里让数组的界限设置为nums.length - 1。 12345678910111213public int jump(int[] nums) &#123; int max = 0; int end = 0; int step = 0; for(int i = 0; i &lt; nums.length - 1; i++) &#123; max = Math.max(nums[i] + i, max); // 持续更新跳跃的最大点，结算时确定下次要跳的位置 if(i == end) &#123; // 已经遍历到了上一次起跳的最大位置的终点（结算） end = max; // 设置下次需要跳到的位置的终点 step ++; // 跳动 &#125; &#125; return step;&#125; *十一、O(1)插入、删除、随机获取 思路：变长数组可以在 O(1) 的时间内完成获取随机元素操作，但是由于无法在 O(1) 的时间内判断元素是否存在，因此不能在 O(1) 的时间内完成插入和删除操作。哈希表可以在 O(1) 的时间内完成插入和删除操作，但是由于无法根据下标定位到特定元素，因此不能在 O(1) 的时间内完成获取随机元素操作。为了满足插入、删除和获取随机元素操作的时间复杂度都是 O(1)，需要将变长数组和哈希表结合，变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标。所以使用变长数组 + 哈希表 操作插入时，首先判断val是否存在哈希表中，如果存在，则返回false，如果不存在，则插入val。操作如下： ​ 1、在变长数组末尾加入val ​ 2、将加入后的(val, index)放入哈希表，返回true 12345678public boolean insert(int val) &#123; if(map.containsKey(val)) &#123; return false; &#125; nums.add(val); map.put(val, nums.size() - 1); return true;&#125; 操作删除时，首先判断val是否存在哈希表中，如果不存在，则返回false，如果存在，则操作如下： ​ 1、在哈希表中，获取要删除的值val的下标index。 ​ 2、将变长数组中的最后一个数end，放入下标为index中，并将这个数的(end, index)在哈希表中更新。 ​ 2、删除变长数组中的最后一个数end，删除哈希表中key为val的键值对。 123456789101112public boolean remove(int val) &#123; if(!map.containsKey(val)) &#123; return false; &#125; int end = nums.get(nums.size() - 1); int index = map.get(val); nums.set(index, end); map.put(end, index); nums.remove(nums.size() - 1); map.remove(val); return true;&#125; *十二、除自身以外数组的乘积 思路：将当前数组每个节点的左侧乘积和右侧乘积单独算出来，然后一一对应相乘。下标0的左侧乘积为 1，下标n的右侧乘积为 1 1234567891011121314public int[] productExceptSelf(int[] nums) &#123; int length = nums.length; int[] answer = new int[length]; answer[0] = 1; for(int i = 1; i &lt; length; i++) &#123; answer[i] = answer[i - 1] * nums[i - 1]; // 首先存放每个节点的左侧乘积 &#125; int R = 1; for(int j = length - 1; j &gt;= 0; j--) &#123; answer[j] = answer[j] * R; R = R * nums[j]; // 下一个节点的右侧乘积 = 当前节点 * 当前节点右侧乘积 &#125; return answer;&#125; *十三、加油站 思路： 无论从哪个点开始，只要总油量大于总耗油量（即剩余油量大于 0），就肯定可以跑完一圈，所以使用sum记录剩余油量，如果从当前点出发的总剩余油量（sum）小于上一步到达当前点的总剩余油量（sum），则从当前点出发无法到达下一步，则存储下一步的坐标表示当前点无法作为起点，下一步作为起点。依次循环，直到遍历结束 sum记录着每一步的剩余油量的总和，即使走到下标4，需要去判断其是否能走一圈，也需要用到前面三个点的剩余油量，sum又有记录，所以可以直接将下标4的剩余油量和sum相加。 例如：若下标3能够到达下标4，那么for中的if不会进入，idx还是保留着（从下标2开始走时，无法走到下标3，idx始终保留无法到达下一步坐标的当前点的下一步的坐标，这样才能确定是从哪一步开始可以到达下一步从而绕一圈的）下标3。如果当前剩余油量+之前剩余总油量（sum）小于0，则说明，无法绕一圈。反之，则可以绕一圈，且起点为idx（即使下标1无法到达下标2，下标2无法到达下标3，但是下标3可以到达下标4，且到达之后的剩余油量可以弥补之前的空缺，那么就可绕一圈，且起点为下标3）。 1234567891011121314151617public int canCompleteCircuit(int[] gas, int[] cost) &#123; if(gas == null || cost == null || gas.length == 0 || cost.length == 0) &#123; return 0; &#125; int n = gas.length; int sum = 0; int min = 0; int idx = 0; for (int i = 0;i &lt; n; i++) &#123; sum += gas[i] - cost[i]; // 总的剩余油量 if(sum &lt; min) &#123; // 判断当前总剩余油量和上一次总剩余油量的大小，若小于，则说明当前点不能到达下一点 min = sum; // 更新总的剩余油量 idx = i + 1; // 保存当前点的下一点为idx，若循环不再进来，则说明可以从idx出发到达下一步 &#125; // 当前循环进if，说明无法到达下一步，又能够到达下一步的不会进来，所以idx使用i+1 &#125; return sum &lt; 0 ? -1 : idx;&#125; **十四、分发糖果 思路： 情况1：先升序，后降序。此时第一个人肯定会有一颗糖，记录pre &#x3D; 1，在升序部分，后面每一步都作pre +&#x3D; 1，记录升序的数量inc（到达最高点时，也会将最高点算到inc中，但是降序时，最高点也要算到降序部分，但是降序部分没法从最高点开始算起，只能遍历到最高点的后一个点时，才会知晓数组开始降序，所以降序会有特殊处理，后面会用降序的数量和其比较）。开始降序时，使用dec表示降序的数量（如果前一个值是最高点，后一个值开始降序，那么dec只是从后一个值开始算起降序的数量，其实最高点也要算是降序的一部分，当dec和inc相等时，说明降序部分肯定超过升序部分了，所以dec要加上1才能当作总的降序部分，如 1 2 3 4 3 2 1 0。升序部分是 1 2 3 4 inc &#x3D; 4，降序部分是 4 3 2 1 0，但是只有遍历到3时才知道降序开始，dec是从3开始算起 dec &#x3D; 4，但是实际是5，所以当dec &#x3D;&#x3D; inc时，dec需要累加），也可以看作是降序部分，总的应发的糖果数（因为降序是从高点往下，但是dec是从0开始的，所以无法满足dec的每一次累加的值，是降序每个小孩的应发的糖果，只能算是应发的总糖果）。如果dec &#x3D;&#x3D; inc时，降序部分超过了升序部分，dec应当累加。 情况2：先降序，后升序。开始降序时，无法知晓后一步是否变成升序操作，所以降序的每一步都需要将pre重新置为1，若后一步变成升序，那么后一步的pre就是2，升序部分便可以看作是从这一步开始的。 情况3：先升序，平序，后降序。由于平序部分没有大小关系，所以从第二个平序数开始，pre可以用最小的数1即可，并且升序数量inc也可以看作是1，然后再按照降序部分的操作计算dec的值即可，如 5 5 3，此时inc为1，dec最开始为1，刚好和inc相等，那么dec需要累加1，因为实际dec是2。 情况4：先降序，平序，后升序。由于开始降序时，是从1开始计算的，所以降序的最低点就可以看作是1（只不过倒序了而已），平序部分只用给最小数1即可，即pre &#x3D; 1，然后再按照升序的逻辑计算，最后一个平序数当然就可以看作是升序数的起点。 汇总：整合这4种情况，若数组只有一个数，则只需要返回1，若有两个数，则可以看作是以上四种情况的任何一种情况。使用ret &#x3D; 1作为结果的初始值，从数组的第二个开始遍历，升序、平序时，ret &#x3D; ret + pre，降序时，ret &#x3D; ret + dec，最后返回ret即可。 123456789101112131415161718192021public int candy(int[] ratings) &#123; int n = ratings.length; int ret = 1; int inc = 1, dec = 0, pre = 1; for (int i = 1; i &lt; n; i++) &#123; if (ratings[i] &gt;= ratings[i - 1]) &#123; dec = 0; pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1; ret += pre; inc = pre; &#125; else &#123; dec++; if (dec == inc) &#123; dec++; &#125; ret += dec; pre = 1; &#125; &#125; return ret;&#125; **十五、接雨水 思路： 方法一：动态规划 时间复杂度O(n) 空间复杂度O(n) 对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。 开始遍历，每到一步都可以得到当前点和最大值的数值差，此时可以看作该点能够接雨水的量。但是当达到最高点后，后面的点肯定相对于最高点来说是降序，因此这些点和最高点之间的差不能当成该点能够接雨水的量。所以我们既要从左往右遍历，也要从右往左遍历，这样，我们就可以得到最高点左侧的准确的接雨水量和最高点右侧的准确的接雨水量。 此时我们既可以根据最高点区分左右侧，然后相加可得到总的能够接雨水量，也可以根据左右分别遍历得到的接雨水量的交集来确定总的接雨水量。 12345678910111213141516171819202122public int trap(int[] height) &#123; int n = height.length; if(n == 0) &#123; return n; &#125; int[] leftMax = new int[n]; leftMax[0] = height[0]; for(int left = 1; left &lt; n; left ++) &#123; leftMax[left] = Math.max(leftMax[left - 1], height[left]); &#125; int[] rightMax = new int[n]; rightMax[n - 1] = height[n - 1]; for(int right = n - 2; right &gt;= 0; right --) &#123; rightMax[right] = Math.max(rightMax[right + 1], height[right]); &#125; int res = 0; for(int i = 0; i &lt; n; i ++) &#123; res += Math.min(leftMax[i], rightMax[i]) - height[i]; &#125; return res;&#125; 方法二：双指针 时间复杂度O(n) 空间复杂度O(1) 对于方法一中的左右两边分别遍历，得到总的接雨水量，这样会出现达到最高点之后，后面的操作都是浪费资源的，根本就不用去计算。此时可以优化成双指针，左右两个指针移动时，也记录移动过程中，分别得到的最大值（因为左边指针移动时，只能去根据右边的最大值去比对当前点能否接雨水，比如leftMax &#x3D; 2，rightMax &#x3D; 3，cur &#x3D; 1，此时就可以看作是cur可以接雨水。若rightMax &#x3D; 1，那么cur无法接雨水）左右两个指针总有一个会先走到最高点，走到最高点的指针停止不动，另外一个指针按照当前指针算出来的最大值减去当前点，得到当前点能够接的雨水量。直到两个指针会和。 123456789101112131415161718public int trap(int[] height) &#123; int n = height.length; int res = 0; int leftMax = 0, left = 0; int rightMax = 0, right = n - 1; while(left &lt; right) &#123; leftMax = Math.max(leftMax, height[left]); rightMax = Math.max(rightMax, height[right]); if(height[left] &lt; rightMax) &#123; // 此时左边的指针将rightMax当成最高点 res += leftMax - height[left]; left ++; &#125; else &#123; // 此时右边的指针将leftMax当成最高点 res += rightMax - height[right]; right --; &#125; &#125; return res;&#125; 方法三：单调栈 时间复杂度O(n) 空间复杂度O(n) 维护一个单调递减栈，里面存储的是下标，满足从栈底到栈顶下标所对应的值单调递减。 栈顶元素为top，第二个元素为left。当height[i] &gt; height[top]，就说明top可以接雨水，该区域的宽度为 i - left - 1，高度为top下一个栈left的值和当前点 i 的值之间的最小值与top点值的差，即min(height[left], height[i]) − height[top]。 为了得到left，top需要出栈，top计算完所接雨水后，left变成新的top，然后 i 继续和此top比较，重复上一步操作。直到栈空或者 i 对应的值小于等于top的值。（为什么是小于等于呢，因为栈是单调递减的，小于等于就可以直接入栈，只有大于才用和栈中数据去比对） 12345678910111213141516171819public int trap(int[] height) &#123; int n = height.length; int res = 0; Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;(); for(int i = 0; i &lt; n; i ++) &#123; while(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123; int top = stack.pop(); if(stack.isEmpty()) &#123; break; &#125; int left = stack.peek(); int width = i - left - 1; int high = Math.min(height[i], height[left]) - height[top]; res += width * high; &#125; stack.push(i); &#125; return res;&#125; 十六、罗马数字转整数 思路：XIV &#x3D; X - I + V &#x3D; 10 - 1 + 5 &#x3D; 14 将罗马字符和数字用map映射起来，如果当前的罗马字符对应的数字比下一个罗马字符对应的数字小，则说明要做减法，反之做加法。 12345678910111213141516171819202122public int romanToInt(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap(); map.put(&#x27;I&#x27;, 1); map.put(&#x27;V&#x27;, 5); map.put(&#x27;X&#x27;, 10); map.put(&#x27;L&#x27;, 50); map.put(&#x27;C&#x27;, 100); map.put(&#x27;D&#x27;, 500); map.put(&#x27;M&#x27;, 1000); int n = s.length(); int res = 0; for(int i = 0; i &lt; n; i++) &#123; Integer value = map.get(s.charAt(i)); if(i &lt; n - 1 &amp;&amp; value &lt; map.get(s.charAt(i + 1))) &#123; res -= value; &#125; else &#123; res += value; &#125; &#125; return res;&#125; *十七、整数转罗马数字 思路：计算出每个数字在每个位上的表示形式，整理成一张硬编码表 123456789101112131415class Solution &#123; String[] thousands = &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;; String[] hundreds = &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;; String[] tens = &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;; String[] ones = &#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;; public String intToRoman(int num) &#123; StringBuffer roman = new StringBuffer(); roman.append(thousands[num / 1000]); roman.append(hundreds[num % 1000 / 100]); roman.append(tens[num % 100 / 10]); roman.append(ones[num % 10]); return roman.toString(); &#125;&#125; 十八、最长公共前缀 思路：数组中的每个字符依次比较，每得到一个公共前缀，直接拿当前公共前缀和后一个字符比较即可，然后再更新公共前缀，比较途中公共前缀为空，则直接返回空字符。 1234567891011121314151617181920212223public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return &quot;&quot;; &#125; String prefix = strs[0]; int count = strs.length; for (int i = 1; i &lt; count; i++) &#123; prefix = longestCommonPrefix(prefix, strs[i]); if (prefix.length() == 0) &#123; break; &#125; &#125; return prefix;&#125;public String longestCommonPrefix(String str1, String str2) &#123; int length = Math.min(str1.length(), str2.length()); int index = 0; while (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123; index++; &#125; return str1.substring(0, index);&#125; *十九、反转字符串中的单词 思路：首先去除字符串头尾空格，后去除单词间多余空格，为了降低空间复杂度，那么直接对字符串进行更改，首先将字符串颠倒，然后再颠倒每个单词即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public String reverseWords(String s) &#123; StringBuilder sb = trimSpaces(s); reverse(sb, 0, sb.length() - 1); // 翻转字符串 reverseEachWord(sb); // 翻转每个单词 return sb.toString(); &#125; public StringBuilder trimSpaces(String s) &#123; int left = 0, right = s.length() - 1; // 去掉字符串开头的空白字符 while (left &lt;= right &amp;&amp; s.charAt(left) == &#x27; &#x27;) &#123; ++left; &#125; // 去掉字符串末尾的空白字符 while (left &lt;= right &amp;&amp; s.charAt(right) == &#x27; &#x27;) &#123; --right; &#125; // 将字符串间多余的空白字符去除 StringBuilder sb = new StringBuilder(); while (left &lt;= right) &#123; char c = s.charAt(left); if (c != &#x27; &#x27;) &#123; sb.append(c); &#125; else if (sb.charAt(sb.length() - 1) != &#x27; &#x27;) &#123; // 若sb中已经加入了空格，则多余的空格不用加入 sb.append(c); &#125; ++left; &#125; return sb; &#125; public void reverse(StringBuilder sb, int left, int right) &#123; while (left &lt; right) &#123; char tmp = sb.charAt(left); sb.setCharAt(left++, sb.charAt(right)); sb.setCharAt(right--, tmp); &#125; &#125; public void reverseEachWord(StringBuilder sb) &#123; int n = sb.length(); int start = 0, end = 0; while (start &lt; n) &#123; // 循环至单词的末尾 while (end &lt; n &amp;&amp; sb.charAt(end) != &#x27; &#x27;) &#123; ++end; &#125; // 翻转单词 此时end指向空格或超过字符串长度 reverse(sb, start, end - 1); // 更新start，去找下一个单词 start = end + 1; ++end; &#125; &#125;&#125; *二十、N字形变换 思路：遍历字符串，当从N字形头开始的时候，字符放置的位置是从第一行递增，到尾之后，开始递减 1234567891011121314151617181920212223public String convert(String s, int numRows) &#123; if(numRows &lt; 2) &#123; return s; &#125; List&lt;StringBuilder&gt; rows = new ArrayList&lt;StringBuilder&gt;(); for(int i = 0; i &lt; numRows; i++) &#123; rows.add(new StringBuilder()); &#125; int i = 0; int flag = -1; // 初始化是反向，s遍历开始时，会变为正向递增。列结尾后会递减 for(char c : s.toCharArray()) &#123; rows.get(i).append(c); if(i == 0 || i == numRows - 1) &#123; flag = -flag; &#125; i += flag; &#125; StringBuilder res = new StringBuilder(); for(StringBuilder row : rows) &#123; res.append(row); &#125; return res.toString();&#125; 二一、String中第一个匹配项下标 思路： 若从0开始，到n - m为止的时候，还没有遍历到长字符串中有字符和短字符串中的头字符相等，那么就不用遍历了。 12345678910111213141516public int strStr(String haystack, String needle) &#123; int n = haystack.length(); int m = needle.length(); for(int i = 0; i &lt;= n - m; i++) &#123; // 此处需要使用&lt;=，比如5-3，遍历前两个后，还需要遍历第三个才行 int a = i, b = 0; // 此处使用a从i开始继续递增，如果递增到后面不想等了，a还是会等于后一步的i while(b &lt; m &amp;&amp; haystack.charAt(a) == needle.charAt(b)) &#123; a ++; b ++; &#125; if(b == m) &#123; // 说明b遍历完了，已经相等了，那么返回起始点i即可 return i; &#125; &#125; return -1;&#125; ** 二二、文本对齐 思路：首先确定每一行可以放置的单词的个数，这样可以得到这行的空格的个数，从而计算出每个单词之间的空格数 空格要如何填充，可以分为一下三种情况： 情形一：当前行是最后一行。则每个单词间空格个数为1个，行尾使用空格填充。 情形二：当前行非最后一行，且只有一个单词。则单词左对齐，行尾使用空格填充。 情形三：当前行非最后一行，且有多个单词。设当前行单词个数为nums，空格数为spaces，则每个单词之间的空格数应该为 avg = nums / (spaces - 1)。其余数extra应该填充在当前行第一个单词后面。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public List&lt;String&gt; fullJustify(String[] words, int maxWidth) &#123; List&lt;String&gt; ans = new ArrayList&lt;String&gt;(); int right = 0, n = words.length; while (true) &#123; int left = right; // 当前行的第一个单词在 words 的位置 int sumLen = 0; // 统计这一行单词长度之和 // 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格。 // (right-left)可以看作是如果将right位的单词放置进来，需要的空格数，也可以看作是当前行的单词数 while (right &lt; n &amp;&amp; sumLen + words[right].length() + right - left &lt;= maxWidth) &#123; sumLen += words[right++].length(); &#125; // 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格 if (right == n) &#123; StringBuffer sb = join(words, left, n, &quot; &quot;); sb.append(blank(maxWidth - sb.length())); ans.add(sb.toString()); return ans; &#125; int numWords = right - left; // 当前行的单词数 int numSpaces = maxWidth - sumLen; // 当前行只有一个单词：该单词左对齐，在行末填充剩余空格 if (numWords == 1) &#123; StringBuffer sb = new StringBuffer(words[left]); sb.append(blank(numSpaces)); ans.add(sb.toString()); continue; &#125; // 当前行不只一个单词 int avgSpaces = numSpaces / (numWords - 1); int extraSpaces = numSpaces % (numWords - 1); StringBuffer sb = new StringBuffer(); // 拼接额外加一个空格的单词 sb.append(join(words, left, left + extraSpaces + 1, blank(avgSpaces + 1))); sb.append(blank(avgSpaces)); sb.append(join(words, left + extraSpaces + 1, right, blank(avgSpaces))); // 拼接其余单词 ans.add(sb.toString()); &#125; &#125; // blank 返回长度为 n 的由空格组成的字符串 public String blank(int n) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; n; ++i) &#123; sb.append(&#x27; &#x27;); &#125; return sb.toString(); &#125; // join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串 public StringBuffer join(String[] words, int left, int right, String sep) &#123; StringBuffer sb = new StringBuffer(words[left]); for (int i = left + 1; i &lt; right; ++i) &#123; sb.append(sep); sb.append(words[i]); &#125; return sb; &#125;&#125; 二三、验证回文字符串 思路：若是标点符号、空格等特殊字符串，直接跳过即可 12345678910111213141516171819public boolean isPalindrome(String s) &#123; int left = 0, right = s.length() - 1; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) &#123; left ++; &#125; while(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) &#123; right --; &#125; if(left &lt; right) &#123; if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123; return false; &#125; left ++; right --; &#125; &#125; return true;&#125; 二四、判断子序列 思路：s和t匹配上了，则同时右移，匹配不上，则t右移即可，以一方结束而终止循环，最后判断s的指针是否和s的长度相等 12345678910111213public boolean isSubsequence(String s, String t) &#123; int sl = s.length(); int tl = t.length(); int tp = 0; int sp = 0; while(tp &lt; tl &amp;&amp; sp &lt; sl) &#123; if(t.charAt(tp) == s.charAt(sp)) &#123; sp ++; &#125; tp ++; &#125; return sp == sl;&#125; *二五、两数之和2 思路：二分法、双指针 方法一：二分法 时间复杂度O(nlogn) 空间复杂度O(1) 首先循环数组，确定一个数 i，从 i + 1到 n - 1的范围中，使用二分法循环判断 mid，是否满足 nums[mid] &#x3D;&#x3D; target - nums[i]。相等则返回，小于则说明 mid 的值小于差值，差值出现在 mid 之后，所以更新 low 值位mid + 1，大于则更新 high 值为 mid - 1。 123456789101112131415161718public int[] twoSum(int[] numbers, int target) &#123; int n = numbers.length; for(int i = 0; i &lt; n; i ++) &#123; int low = i + 1; int high = n - 1; while(low &lt;= high) &#123; // numbers只有两个数时，只用&lt;，无法进入while循环 int mid = (high - low) / 2 + low; if(numbers[mid] == target - numbers[i]) &#123; return new int[]&#123;i + 1, mid + 1&#125;; &#125; else if(numbers[mid] &gt; target - numbers[i]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; &#125; return new int[]&#123;-1, -1&#125;;&#125; 方法二：双指针 时间复杂度O(n) 空间复杂度O(1) first指针指向数组首，last指针指向数组尾，判断first + last 和 target 的大小。相等则返回，小于则first ++，大于则last –。 12345678910111213141516public int[] twoSum(int[] numbers, int target) &#123; int n = numbers.length; int first = 0, last = n - 1; while(first &lt; last) &#123; int subv = target - numbers[last]; int fv = numbers[first]; if(subv == fv) &#123; return new int[]&#123;first + 1, last + 1&#125;; &#125; else if(subv &gt; fv) &#123; first ++; &#125; else &#123; last --; &#125; &#125; return new int[]&#123;-1, -1&#125;;&#125; *二六、盛最多水的容器 思路：使用双指针，left指向头，right指向尾。left和right之间的距离总是在变小的，这时left和right的移动就要保证哪边小移动那边。 盛水的长度 X &#x3D; right - left 盛水的高度 Y &#x3D; min(height[left], height[right]) 盛水的容积 V &#x3D; X * Y，在 X 总是变小的情况下，我们就得保证Y要变大，这样 V 才有可能变大，所以left、right指向的值，那边小，移动哪边指针。 1234567891011121314151617public int maxArea(int[] height) &#123; int left = 0; int right = height.length - 1; int max = 0; while(left &lt; right) &#123; int x = right - left; int y = height[right] - height[left]; if(y &lt; 0) &#123; max = Math.max(max, height[right] * x); right --; &#125; else &#123; max = Math.max(max, height[left] * x); left ++; &#125; &#125; return max;&#125; *二七、三数之和 思路：将数组排序，确定第一个数后，剩下的两个数便可以根据它们的和去判断哪个指针要右移，哪个指针要左移。 1234567891011121314151617181920212223242526272829303132333435public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; int n = nums.length; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int first = 0; first &lt; n; first ++) &#123; // 若后一个数与前一个数相同，则直接跳过当前循环 if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) &#123; continue; &#125; int third = n - 1; int target = -nums[first]; for(int second = first + 1; second &lt; n; second ++) &#123; if(second &gt; first + 1 &amp;&amp; nums[second] == nums[second-1]) &#123; continue; &#125; // 此时说明third指向的值过大，third需要左移 while(second &lt; third &amp;&amp; nums[third] + nums[second] &gt; target) &#123; third --; &#125; // 说明second的当前循环没有值满足条件，直接break，让first进行下一次遍历 if(second == third) &#123; break; &#125; if(nums[second] + nums[third] == target) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[first]); list.add(nums[second]); list.add(nums[third]); ans.add(list); &#125; // 如果是nums[third] + nums[second] &lt; target的情况，说明second指向的值较小，则需要second右移 &#125; &#125; return ans;&#125; *二八、长度最小子数组 思路：当left和right指针指向的位置之间的值大于等于给定值之后，right继续向右的话，值肯定是大于的，这个时候就要left右移，去尽可能缩小这个子数组。如果缩小到小于给定值之后，right便可以向右。循环如此。 12345678910111213141516public int minSubArrayLen(int target, int[] nums) &#123; int n = nums.length; int left = 0, right = 0; int res = Integer.MAX_VALUE; int sum = 0; while(right &lt; n) &#123; sum += nums[right]; while(sum &gt;= target) &#123; res = Math.min(res, right-left+1); sum -= nums[left]; left ++; &#125; right ++; &#125; return res == Integer.MAX_VALUE ? 0 : res;&#125; *二九、无重复字串的最长子串 思路：若没碰到重复字符，则right可以右移，若碰到了，则left右移，并且删掉left之前指向的值，直到删除了set中存在的让right重复的值。然后right继续右移，循环如此。 123456789101112131415public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); int left = 0, right = 0, res = 0; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); while(left &lt; n) &#123; while(right &lt; n &amp;&amp; !set.contains(s.charAt(right))) &#123; set.add(s.charAt(right)); right ++; &#125; res = Math.max(res, right - left); left ++; set.remove(s.charAt(left-1)); &#125; return res;&#125; **三十、最小覆盖子串 思路：指针 l 和 r 都从 s 字符的下标0开始遍历，r 初步遍历到包含 t 中所有字符位置为止，然后 l 右移，逐步缩小滑动窗口中的字符数量，若右移之后又不包含 t 中的所有字符了，那就 r 继续右移。循环如此，找出最小覆盖子串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; Map&lt;Character, Integer&gt; tmap = new HashMap&lt;Character, Integer&gt;(); Map&lt;Character, Integer&gt; smap = new HashMap&lt;Character, Integer&gt;(); public String minWindow(String s, String t) &#123; int tLen = t.length(); int sLen = s.length(); if(sLen &lt; tLen) &#123; return &quot;&quot;; &#125; for(int i = 0; i &lt; tLen; i++) &#123; char tc = t.charAt(i); tmap.put(tc, tmap.getOrDefault(tc, 0) + 1); // 首先将t中的所有字符的数量放到tmap中 &#125; int l = 0, r = 0, resL = 0, resR = 0; int len = Integer.MAX_VALUE; while(r &lt; sLen) &#123; char sc = s.charAt(r); if(tmap.containsKey(sc)) &#123; // 判断当前r指向的字符是否在t中 smap.put(sc, smap.getOrDefault(sc, 0) + 1); // 若在，将当前字符存放在smap中 &#125; while(check() &amp;&amp; l &lt;= r) &#123; // 检查通过说明l -&gt; r之间已经包含了t，smap和tmap中的内容完全相同 char c = s.charAt(l); if(r - l + 1 &lt; len) &#123; len = r - l + 1; resL = l; resR = l + len; &#125; if(tmap.containsKey(c)) &#123; // 此时缩小窗口 smap.put(c, smap.get(c) - 1); &#125; l ++; // 窗口缩小 &#125; r ++; // 窗口中字符不包含t，或窗口无法继续缩小 &#125; return s.substring(resL, resR); &#125; // 检查当前l -&gt; r之间的字符是否包含了t public Boolean check() &#123; Iterator iter = tmap.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Character key = (Character) entry.getKey(); Integer value = (Integer) entry.getValue(); if(smap.getOrDefault(key, 0) &lt; value) &#123; return false; &#125; &#125; return true; &#125;&#125; *三一、有效的数独 思路：使用三个数组分别来记录每一行，每一列，每个九宫格中的数的出现次数 对于每一行中的值，使用一个数组rows[9][9]来表示，当前数放在这个数组的哪里，出现了几次。 对于每一列中的值，使用一个数组columns[9][9]来表示，当前数放在这个数组的哪里，出现了几次。 对于每一个九宫格的值，使用一个数组subboxes[3][3][9]来表示，当前数放在这个数组的哪里，出现了几次。 比如borad[5][6] = 9，那么这个数 5 ，放在rows中的第 5 行，第 9 - 1 列，出现了 1 次。放在columns中的第 6 行，第 9 - 1 列，出现了一次。如果borad[5][n] = 9，那么这个数继续放在第 5 行，第 9 - 1 列，出现了2次。同理board[n][6] = 9也是如此。如果有位置出现了超过 1 次，那么就直接返回false。 1234567891011121314151617181920public boolean isValidSudoku(char[][] board) &#123; int[][] rows = new int[9][9]; int[][] columns = new int[9][9]; int[][][] subboxes = new int[3][3][9]; for(int i = 0; i &lt; 9; i ++) &#123; for(int j = 0; j &lt; 9; j++) &#123; char c = board[i][j]; if(c != &#x27;.&#x27;) &#123; int index = c - &#x27;0&#x27; - 1; rows[i][index] ++; // 定住行，判断这一行中有没有数字重复 columns[j][index] ++; // 定住列，判断这一列中有没有数字重复 subboxes[i/3][j/3][index] ++; if(rows[i][index] &gt; 1 || columns[j][index] &gt; 1 || subboxes[i/3][j/3][index] &gt; 1) &#123; return false; &#125; &#125; &#125; &#125; return true;&#125; *三二、螺旋矩阵 思路：将矩阵看作有若干层，一层一层输出 假设左上角位于(top, left)，右下角位于(bottom, right)，按照如下顺序遍历当前层元素： 1、从左往右遍历，由(top, left) 到 (top, right)。 2、从上往下遍历，由(top + 1, right) 到 (bottom, right)。 3、如果left &lt; right，top &lt; bottom。 ​ 从右往左遍历，由(bottom, right - 1) 到 (bottom, left)。 ​ 从下往上遍历，由(bottom - 1, left) 到 (top + 1, left)。 **当只剩下最后一列遍历时，需要判断此时的left &lt; right，否则会多输出。当剩下最后一行遍历时，需要判断此时的top &lt; bottom， 否则也会多输出。因为行和列都会在前两个循环输出，若后两个循环不判断，则会造成数据重复输出。** 1234567891011121314151617181920212223242526272829public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; order = new ArrayList&lt;&gt;(); if(matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return order; &#125; int rows = matrix.length, columns = matrix[0].length; int left = 0, right = columns - 1, top = 0, bottom = rows - 1; while(left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for(int colomn = left; colomn &lt;= right; colomn ++) &#123; order.add(matrix[top][colomn]); &#125; for(int row = top + 1; row &lt;= bottom; row ++) &#123; order.add(matrix[row][right]); &#125; if(left &lt; right &amp;&amp; top &lt; bottom) &#123; for(int colomn = right - 1; colomn &gt;= left; colomn --) &#123; order.add(matrix[bottom][colomn]); &#125; for(int row = bottom - 1; row &gt; top; row --) &#123; order.add(matrix[row][left]); &#125; &#125; left ++; right --; top ++; bottom --; &#125; return order;&#125; *三三、旋转图像 思路：直接旋转。或者先水平轴对折，然后以左顶角和右底角连线为轴对折。 方法一：直接旋转 我们可以发现，对于矩阵中的第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。 因此，对于矩阵中的元素matrix[row][col]，在旋转后，它的新位置为matrix[col][n-row-1]。新的行等于原来的列，新的列等于n减去原来的行减去1。$$\\begin{cases} row &#x3D; col \\ col &#x3D; n - row - 1 \\end{cases}$$由此，我们可以得出矩形的四个方位的数据，旋转前后的位置关系如下： 1旋转到3，行列变化为：matrix[row][col] &#x3D;&#x3D;&#x3D;&gt; matrix[col][n-row-1] 3旋转到9，行列变化为：matrix[col][n-row-1] &#x3D;&#x3D;&#x3D;&gt; matrix[n-row-1][n-col-1] 9旋转到7，行列变化为： matrix[n-row-1][n-col-1] &#x3D;&#x3D;&#x3D;&gt; matrix[n-col-1][n-(n-row-1)-1] &#x3D;&#x3D;&#x3D;&gt; matrix[n-col-1][row] 7旋转到1，行列变化为： matrix[n-col-1][row] &#x3D;&#x3D;&#x3D;&gt; matrix[row][n-(n-col-1)-1] &#x3D;&#x3D;&#x3D;&gt; matrix[row][col] 对于我们实际需要遍历的行数和列数，我们可以推理出，若 n 是偶数矩阵，则行和列遍历到 n&#x2F;2 即可。若 n 是奇数矩阵，则行遍历到n&#x2F;2，列遍历到(n+1)&#x2F;2。如下图： 123456789101112public void rotate(int[][] matrix) &#123; int n = matrix.length; for(int i = 0; i &lt; n / 2; i ++) &#123; for(int j = 0; j &lt; (n + 1) / 2; j ++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][i]; matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; matrix[j][n - i - 1] = temp; &#125; &#125;&#125; 方法二：先水平轴对折，然后以左顶角和右底角连线为轴对折 水平轴对折，行列变化为：matrix[row][col] &#x3D;&#x3D;&#x3D;&gt; matrix[n-row-1][col] 反斜轴对折，行列变化为：matrix[n-row-1][col] &#x3D;&#x3D;&#x3D;&gt; matrix[col][n-row-1] 12345678910111213141516171819public void rotate(int[][] matrix) &#123; int n = matrix.length; // 水平翻转 for (int i = 0; i &lt; n / 2; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[n - i - 1][j]; matrix[n - i - 1][j] = temp; &#125; &#125; // 主对角线翻转 for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125;&#125; *三四、矩阵置零 思路：首先记录第一行和第一列是否存在 0，对于非第一行和第一列为 0 的元素，可以将这个数所在的行和列的第一个数都置为 0，然后从第二行第二列开始遍历，判断遍历到的行和列的第一个数是否为 0，若为 0，则将当前行和列全部置为 0。最后再判断是否需要将第一行和第一列置为 0。 1、记录第一行和第一列是否本来就存在 0； 2、判断除第一行第一列外，是否存在 0，若存在，就将当前行和列的第一个数（在第一行或第一列上）置为 0； 3、根据第一行和第一列的 0（包括后期赋值的0）将非第一行和第一列的值全部变成 0； 4、最后根据第一步的记录，判断第一行和第一列是否需要置为0； 12345678910111213141516171819202122232425262728293031323334353637383940414243public void setZeroes(int[][] matrix) &#123; int m = matrix.length, n = matrix[0].length; boolean flagCol = false, flagRow = false; for(int i = 0; i &lt; m; i ++) &#123; if(matrix[i][0] == 0) &#123; flagCol = true; // 第一列存在0 &#125; &#125; for(int j = 0; j &lt; n; j ++) &#123; if(matrix[0][j] == 0) &#123; flagRow = true; // 第一行存在0 &#125; &#125; // 判断除第一行第一列外，是否存在0，若存在，就将当前行和列的第一个数置为0 for(int i = 1; i &lt; m; i ++) &#123; for(int j = 1; j &lt; n; j ++) &#123; if(matrix[i][j] == 0) &#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; // 根据第一行和第一列的0（包括后期赋值的0）将非第一行和第一列的值全部变成0 for(int i = 1; i &lt; m; i ++) &#123; for(int j = 1; j &lt; n; j ++) &#123; if(matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; // 最后判断是否需要将第一行和第一列置为0 if(flagRow) &#123; for(int j = 0; j &lt; n; j ++) &#123; matrix[0][j] = 0; &#125; &#125; if(flagCol) &#123; for(int i = 0; i &lt; m; i ++) &#123; matrix[i][0] = 0; &#125; &#125;&#125; *三五、生命游戏 思路：题目限定的条件都是根据相邻活细胞的数量来判断当前细胞是死是活。因此，对于活细胞变成死细胞后，我们可以使用额外的数据来表示当前细胞的状态，以便于后面可以准确的拿到细胞之前的状态。对于活细胞变成死细胞，可以将状态变成 -1，这样有相邻数据要去判断自己是否存活时，可以直接用 -1 的绝对值来查看它的相邻的细胞之前的状态。 1、两层嵌套遍历&#123;-1,0,1&#125;，可以快速得到某一点的周围 3 * 3 点的坐标，然后根据它们的值去判断它们之前的状态是否为活细胞。 2、根据活细胞的数量，将当前细胞的状态设置成容易识别的数字，比如 -1 就代表之前活细胞，现在死细胞；2 代表之前死细胞，现在活细胞。方便之后当前细胞作为别的细胞的相邻细胞的时候，能够准确的判断其之前的状态，从而去计算 liveNear 的值。 3、将细胞的状态设置完后，重新遍历，根据之前设置的值，重新将细胞的状态更新正常。 123456789101112131415161718192021222324252627282930313233343536373839public void gameOfLife(int[][] board) &#123; int[] near = new int[]&#123;-1,0,1&#125;; int rows = board.length; int cols = board[0].length; for(int row = 0; row &lt; rows; row ++) &#123; for(int col = 0; col &lt; cols; col ++) &#123; int liveNear = 0; for(int i = 0; i &lt; 3; i ++) &#123; for(int j = 0; j &lt; 3; j ++) &#123; if(!(near[i] == 0 &amp;&amp; near[j] == 0)) &#123; int r = row + near[i]; int c = col + near[j]; // Math.abs(board[r][c]) == 1 可以替换成 board[r][c] == 1 || board[r][c] == 3 if((r &gt;= 0 &amp;&amp; r &lt; rows) &amp;&amp; (c &gt;= 0 &amp;&amp; c &lt; cols) &amp;&amp; Math.abs(board[r][c]) == 1) &#123; liveNear ++; &#125; &#125; &#125; &#125; if(board[row][col] == 1 &amp;&amp; (liveNear &gt; 3 || liveNear &lt; 2)) &#123; board[row][col] = -1; // 这里也可以用别的值 如: board[row][col] = 3 &#125; if(board[row][col] == 0 &amp;&amp; (liveNear == 3)) &#123; board[row][col] = 2; &#125; &#125; &#125; for(int row = 0; row &lt; rows; row ++) &#123; for(int col = 0; col &lt; cols; col ++) &#123; if(board[row][col] == 2) &#123; board[row][col] = 1; &#125; if(board[row][col] == -1) &#123; board[row][col] = 0; &#125; &#125; &#125;&#125; 三六、赎金信 思路：magazine长度小于ransomNote，则直接返回false。判断ransomNote中使用到的字符的个数，在magazine中是否全部出现，个数是否能对上，不能对上，则返回false 12345678910111213141516public boolean canConstruct(String ransomNote, String magazine) &#123; if (ransomNote.length() &gt; magazine.length()) &#123; return false; &#125; int[] cnt = new int[26]; for (char c : magazine.toCharArray()) &#123; cnt[c - &#x27;a&#x27;]++; &#125; for (char c : ransomNote.toCharArray()) &#123; cnt[c - &#x27;a&#x27;]--; if(cnt[c - &#x27;a&#x27;] &lt; 0) &#123; return false; &#125; &#125; return true;&#125; 三七、同构字符串 思路：将s中出现的字符和t中出现的字符先映射起来，若之后s中又碰到相同的字符，但是t中出现的字符和映射关系中s对应的字符不相同，则返回false。 123456789101112131415public boolean isIsomorphic(String s, String t) &#123; Map&lt;Character, Character&gt; s2t = new HashMap&lt;&gt;(); Map&lt;Character, Character&gt; t2s = new HashMap&lt;&gt;(); int len = s.length(); for(int i = 0; i &lt; len; i ++) &#123; char x = s.charAt(i); char y = t.charAt(i); if((s2t.containsKey(x) &amp;&amp; s2t.get(x) != y) || (t2s.containsKey(y) &amp;&amp; t2s.get(y) != x)) &#123; return false; &#125; s2t.put(x, y); t2s.put(y, x); &#125; return true;&#125; 三八、单词规律 思路：将pattern出现的字符和s中的单词相互映射起来，若后面pattern中碰到相同的字符，但是s中出现的单词和映射关系中pattern对应的单词不相同，则返回false。 12345678910111213141516171819202122public boolean wordPattern(String pattern, String str) &#123; Map&lt;String, Character&gt; str2ch = new HashMap&lt;String, Character&gt;(); Map&lt;Character, String&gt; ch2str = new HashMap&lt;Character, String&gt;(); int m = pattern.length(); String[] strs = str.split(&quot; &quot;); if(m != strs.length) &#123; return false; &#125; for(int i = 0; i &lt; m; i ++) &#123; char ch = pattern.charAt(i); String sh = strs[i]; if (str2ch.containsKey(sh) &amp;&amp; str2ch.get(sh) != ch) &#123; return false; &#125; if (ch2str.containsKey(ch) &amp;&amp; !sh.equals(ch2str.get(ch))) &#123; return false; &#125; str2ch.put(sh, ch); ch2str.put(ch, sh); &#125; return true;&#125; 123456789101112131415161718192021222324252627public boolean wordPattern(String pattern, String str) &#123; Map&lt;String, Character&gt; str2ch = new HashMap&lt;String, Character&gt;(); Map&lt;Character, String&gt; ch2str = new HashMap&lt;Character, String&gt;(); int m = str.length(); int i = 0; for (int p = 0; p &lt; pattern.length(); ++p) &#123; char ch = pattern.charAt(p); if (i &gt;= m) &#123; return false; &#125; int j = i; while (j &lt; m &amp;&amp; str.charAt(j) != &#x27; &#x27;) &#123; j++; &#125; String tmp = str.substring(i, j); if (str2ch.containsKey(tmp) &amp;&amp; str2ch.get(tmp) != ch) &#123; return false; &#125; if (ch2str.containsKey(ch) &amp;&amp; !tmp.equals(ch2str.get(ch))) &#123; return false; &#125; str2ch.put(tmp, ch); ch2str.put(ch, tmp); i = j + 1; &#125; return i &gt;= m;&#125; 三九、有效的字母异位词 思路：判断 s 和 t 中的每个字符的个数是否相等即可。 12345678910111213141516public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) &#123; return false; &#125; int[] cnt = new int[26]; for (char c : s.toCharArray()) &#123; cnt[c - &#x27;a&#x27;]++; &#125; for (char c : t.toCharArray()) &#123; cnt[c - &#x27;a&#x27;]--; if(cnt[c - &#x27;a&#x27;] &lt; 0) &#123; return false; &#125; &#125; return true;&#125; *四十、字母异位词分组 思路：将每个单词进行字符排序后作为key，同为异位词的单词，key肯定是相同的。也可以将每个单词中，按照 “字符 + 字符出现的次数” 进行拼接作为key，同为异位词的单词，key肯定也相同。 方法一：将每个单词进行字符排序后，作为key。 123456789101112public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strs) &#123; char[] array = str.toCharArray(); Arrays.sort(array); String key = new String(array); List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;()); list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());&#125; 方法二：将每个单词按照 “字符 + 字符出现的次数” 进行拼接作为key。 1234567891011121314151617181920212223public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strs) &#123; int[] counts = new int[26]; int length = str.length(); for (int i = 0; i &lt; length; i++) &#123; counts[str.charAt(i) - &#x27;a&#x27;]++; &#125; // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键 StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 26; i++) &#123; if (counts[i] != 0) &#123; sb.append((char) (&#x27;a&#x27; + i)); sb.append(counts[i]); &#125; &#125; String key = sb.toString(); List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;()); list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());&#125; 四一、两数之和 思路：存在一个map，我们遍历某个数的时候，判断map中是否存在这个数的另一对，存在直接返回，不存在便用map储存这个数以及其下标 12345678910public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt;= nums.length; i++) &#123; if(map.containsKey(target - nums[i])) &#123; return new int[]&#123;map.get(target - nums[i]), i&#125;; &#125; map.put(nums[i], i); &#125; return new int[0];&#125; 四二、快乐数 思路： 方法一：用哈希集合检测循环 时间复杂度 O(logn) 空间复杂度 O(logn) 对于一个整数来说，其变化有如下几种情况： 根据探索，会有如下三种情况： 1、一个数经过变化，最终会变成 1 。 2、一个数经过变化，最终会形成循环。 3、一个数经过变化，会变得无限大。 对于第三种情况是否真的存在，我们进行如下思考： 对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除第三种选择。 1234567891011121314151617181920class Solution &#123; private int getNext(int n) &#123; int totalSum = 0; while(n &gt; 0) &#123; int d = n % 10; n = n / 10; totalSum += d * d; &#125; return totalSum; &#125; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; seen = new HashSet&lt;&gt;(); while(n != 1 &amp;&amp; !seen.contains(n)) &#123; seen.add(n); n = getNext(n); &#125; return n == 1; &#125;&#125; 方法二：快慢指针 时间复杂度 O(logn) 空间复杂度 O(1) 对于非快乐数的变化，可以发现最终数据的变化形成了一个环，这里可以采用弗洛伊德循环查找算法，这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。 如果 n 是一个快乐数，即没有循环，那么快跑者会比慢跑者先到达 1 。 如果 n 不是一个快乐数，那么快跑者会先比慢跑者到达数字 1 。 123456789101112131415161718192021class Solution &#123; public int getNext(int n) &#123; int totalSum = 0; while (n &gt; 0) &#123; int d = n % 10; n = n / 10; totalSum += d * d; &#125; return totalSum; &#125; public boolean isHappy(int n) &#123; int slowRunner = n; int fastRunner = getNext(n); while (fastRunner != 1 &amp;&amp; slowRunner != fastRunner) &#123; slowRunner = getNext(slowRunner); fastRunner = getNext(getNext(fastRunner)); &#125; return fastRunner == 1; &#125;&#125; 方法三：数字 时间复杂度 O(logn) 空间复杂度 O(1) 下一个值可能比自己大的最大数字是什么？根据我们之前的分析，我们知道它必须低于 243。因此，我们知道任何循环都必须包含小于 243 的数字，用这么小的数字，编写一个能找到所有周期的强力程序并不困难。 如果这样做，您会发现只有一个循环：4→16→37→58→89→145→42→20→4。所有其他数字都在进入这个循环的链上，或者在进入1 的链上。 因此，我们可以硬编码一个包含这些数字的散列集，如果我们达到其中一个数字，那么我们就知道在循环中。 123456789101112131415161718192021class Solution &#123; private static Set&lt;Integer&gt; cycleMembers = new HashSet&lt;&gt;(Arrays.asList(4, 16, 37, 58, 89, 145, 42, 20)); public int getNext(int n) &#123; int totalSum = 0; while (n &gt; 0) &#123; int d = n % 10; n = n / 10; totalSum += d * d; &#125; return totalSum; &#125; public boolean isHappy(int n) &#123; while (n != 1 &amp;&amp; !cycleMembers.contains(n)) &#123; n = getNext(n); &#125; return n == 1; &#125;&#125; 四三、存在重复元素2 思路：哈希表，滑动窗口 方法一：哈希表 时间复杂度 O(n) 空间复杂度 O(n) 使用一个map，其key为数组中的数，value为这些数的下标。若遍历到的当前的数，不存在于map中，则将当前数和其下标都存放在map中，若存在于map中，则将map中与当前值相同的键值对取出来，判断它们两个的下标差是否小于等于k。 1234567891011public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i ++) &#123; int num = nums[i]; if(map.containsKey(num) &amp;&amp; i - map.get(num) &lt;= k) &#123; return true; &#125; map.put(nums[i], i); &#125; return false;&#125; 方法二：滑动窗口 时间复杂度 O(n) 空间复杂度 O(k) 维护一个滑动窗口，使窗口中的每个数的下标差的绝对值不超过k，那就说明这个窗口的长度要维护在k+1以内。由于下标是从0开始的，那么只有当i &lt;= k时，窗口的长度才维持在了k+1以内。当i &gt; k时，就可以从滑动窗口的头部移除元素i - k - 1，将新的元素加入到滑动窗口，此时只用判断新加入的元素是否已经存在在滑动窗口里即可。 12345678910111213public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums.length; i ++) &#123; if(i &gt; k) &#123; set.remove(nums[i - k - 1]); &#125; int num = nums[i]; if(!set.add(num)) &#123; return true; &#125; &#125; return false;&#125; *四四、最长连续序列 思路：哈希表 时间复杂度 O(n) 空间复杂度 O(n) 遍历数组，判断当前数 num 之前的数 num– 是否存在于数组中。 若存在，则说明不能从当前这个数开始计算序列。 若不存在，则判断 num ++ 是否存在于数组中； ​ 若不存在，则说明当前这个数不存在任何连续数； ​ 若存在，则说明可以从当前这个数开始计算序列。 12345678910111213141516171819public int longestConsecutive(int[] nums) &#123; Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;(); for (int num : nums) &#123; num_set.add(num); // 也可不用单独去重，只不过去重可以省去很多不必要的对比判断操作。 &#125; int longestStreak = 0; for(int num : num_set) &#123; if(!num_set.contains(num - 1)) &#123; int currentNum = num; int currentStreak = 1; while(num_set.contains(currentNum + 1)) &#123; currentNum ++; currentStreak ++; &#125; longestStreak = Math.max(longestStreak, currentStreak); &#125; &#125; return longestStreak;&#125; 四五、汇总区间 思路：判断后一个数和前一个数之间的差是否为 1 即可。 1234567891011121314151617181920public List&lt;String&gt; summaryRanges(int[] nums) &#123; int n = nums.length; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int i = 0; while(i &lt; n) &#123; int low = i; i ++; while(i &lt; n &amp;&amp; nums[i] - nums[i - 1] == 1) &#123; i ++; &#125; int high = i - 1; StringBuilder sb = new StringBuilder(Integer.toString(nums[low])); if(low &lt; high) &#123; sb.append(&quot;-&gt;&quot;); sb.append(Integer.toString(nums[high])); &#125; res.add(sb.toString()); &#125; return res;&#125; *四六、合并区间 思路：将二维数组根据第一个数进行升序排列，这样就只用将后一个二维数组的两个数和前一个二维数组的第二个数比对即可。 123456789101112131415161718192021public int[][] merge(int[][] intervals) &#123; // 根据第一个元素排序二维数组 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] one, int[] two) &#123; return one[0] - two[0]; &#125; &#125;); List&lt;int[]&gt; merged = new ArrayList&lt;int[]&gt;(); for(int i = 0; i &lt; intervals.length;) &#123; int r = intervals[i][1]; int j = i + 1; // 将当前数组的右侧元素r和下一个数组的左侧元素ll对比，若ll &lt;= r，说明存在重叠 while(j &lt; intervals.length &amp;&amp; intervals[j][0] &lt;= r) &#123; r = Math.max(r, intervals[j][1]); // 取出两个数组右侧元素作比对，大的作为新的右侧元素 j ++; &#125; merged.add(new int[]&#123;intervals[i][0], r&#125;); // 由于二维数组根据左侧元素有序，所以新的左侧元素不用作处理 i = j; // j跳出循环的时候要么数组遍历完毕，要么新的数组不存在重叠，所以j可以直接赋值给i &#125; return merged.toArray(new int[merged.size()][]);&#125; 1234567891011121314151617181920212223public int[][] merge(int[][] intervals) &#123; if (intervals.length == 0) &#123; return new int[0][2]; &#125; // 根据第一个元素排序二维数组 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[0] - interval2[0]; &#125; &#125;); List&lt;int[]&gt; merged = new ArrayList&lt;int[]&gt;(); for (int i = 0; i &lt; intervals.length; ++i) &#123; int L = intervals[i][0], R = intervals[i][1]; // 若merged为空，或者当前数组的左侧值比merged中最后一个数组的右侧值还要大，说明不存在重叠 if (merged.size() == 0 || merged.get(merged.size() - 1)[1] &lt; L) &#123; merged.add(new int[]&#123;L, R&#125;); &#125; else &#123; // 存在重叠，将当前数组的右侧值和merged中最后一个数组的右侧值进行比较，更新merged中最后一个数组的右侧值 merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R); &#125; &#125; return merged.toArray(new int[merged.size()][]);&#125; *四七、插入区间 思路：判断插入区间和每个数组之间的关系，是否有重叠出现。 待插入的区间为[left, right]，遍历每个数组，遍历到[ll, rr]时： 如果 ll &gt; right，说明待插入数组在当前数组的左侧，此时应该先将待插入数组放入集合，然后再放入当前数组。 如果 rr &lt; left，说明待插入数组在当前数组的右侧，此时应该先将当前数组放入集合，然后再去判断待插入数组和下一个数组的关系。 如果上面的条件都不满足，则说明存在重叠区域，将当前数组和待插入数组合并成新的待插入数组，left取两者最小，right取两者最大。 123456789101112131415161718192021222324252627public int[][] insert(int[][] intervals, int[] newInterval) &#123; int left = newInterval[0]; int right = newInterval[1]; boolean placed = false; List&lt;int[]&gt; ansList = new ArrayList&lt;int[]&gt;(); for (int[] interval : intervals) &#123; if (interval[0] &gt; right) &#123; // 当前数组在插入区间的右侧且无交集 if (!placed) &#123; ansList.add(new int[]&#123;left, right&#125;); placed = true; &#125; ansList.add(interval); &#125; else if (interval[1] &lt; left) &#123; // 当前数组在插入区间的左侧且无交集 ansList.add(interval); &#125; else &#123; // 当前数组与插入区间有交集，计算它们的并集变成新的插入区间 left = Math.min(left, interval[0]); right = Math.max(right, interval[1]); &#125; &#125; if (!placed) &#123; // 若原数组为空，或插入区间在最右侧，可以用此值来判断，是否需要往集合中加入待插入区间 ansList.add(new int[]&#123;left, right&#125;); &#125; return ansList.toArray(new int[ansList.size()][2]);&#125; *四八、用最少的箭引爆气球 思路：将数组根据右侧元素进行排序后，将第一个数组的右侧数作为第一箭，当遍历到其他数组时，存在当前数组的左侧元素大于第一箭，则说明需要第二箭去引爆当前遍历到的区间，从而将当前数组的右侧数作为第二箭，然后再去判断别的数组区间的左侧数是否大于第二箭，以此类推。 123456789101112131415161718192021222324252627282930313233public int findMinArrowShots(int[][] points) &#123; int n = points.length; if(n == 0) &#123; return 0; &#125; // 用此方式排序会导致int溢出，从而使得计算结果有误 // int[][] points = &#123;&#123;-2147483646,-2147483645&#125;,&#123;2147483646,2147483647&#125;&#125;; // Arrays.sort(points, new Comparator&lt;int[]&gt;() &#123; // public int compare(int[] one, int[] two) &#123; // return one[1] - two[1]; // &#125; // &#125;); Arrays.sort(points, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] one, int[] two) &#123; if(one[1] &gt; two[1]) &#123; return 1; &#125; else if(one[1] &lt; two[1]) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; &#125;); int res = 1; int pos = points[0][1]; // 将右边界最小的第一个区间的有边界作为第一箭 for(int[] point : points) &#123; if(point[0] &gt; pos) &#123; // 如果存在另外一个区间的左边界要比当前第一箭的位置大，则需要第二箭 res ++; pos = point[1]; &#125; &#125; return res;&#125; 四九、有效的括号 思路：遍历括号朝右时，将当前字符存储再index处，然后index自增。当碰到括号朝左时，就可以将index自减后，去判断这个位置存储的字符是否和当前字符成对。成对则继续遍历，不成对则直接返回false。 123456789101112131415161718192021222324252627282930313233public boolean isValid(String s) &#123; char[] stack = new char[s.length()]; int index = 0; for (int i = 0;i &lt; s.length();i++) &#123; switch (s.charAt(i)) &#123; case &#x27;(&#x27;: stack[index++] = s.charAt(i); continue; case &#x27;[&#x27;: stack[index++] = s.charAt(i); continue; case &#x27;&#123;&#x27;: stack[index++] = s.charAt(i); continue; case &#x27;)&#x27;: if (index == 0 || stack[--index] != &#x27;(&#x27;) return false; continue; case &#x27;]&#x27;: if (index == 0 || stack[--index] != &#x27;[&#x27;) return false; continue; case &#x27;&#125;&#x27;: if (index == 0 || stack[--index] != &#x27;&#123;&#x27;) return false; continue; &#125; &#125; if (index == 0) return true; else return false;&#125; *五十、简化路径 思路：维护一个双端队列，若碰到 .. 时，则弹出队列的最后一个，若碰到字符时，往队列中添加此字符。最后从双端队列的头部一一获取字符进行拼接。 1234567891011121314151617181920212223public String simplifyPath(String path) &#123; String[] names = path.split(&quot;/&quot;); Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;(); for(String name : names) &#123; if(&quot;..&quot;.equals(name)) &#123; if(!stack.isEmpty()) &#123; stack.pollLast(); &#125; &#125; else if(name.length() &gt; 0 &amp;&amp; !&quot;.&quot;.equals(name)) &#123; stack.offerLast(name); &#125; &#125; StringBuilder sb = new StringBuilder(); if(stack.isEmpty()) &#123; sb.append(&quot;/&quot;); &#125; else &#123; while(!stack.isEmpty()) &#123; sb.append(&quot;/&quot;); sb.append(stack.pollFirst()); &#125; &#125; return sb.toString();&#125; *五一、最小栈 思路：维护一个最小栈，当往正常栈中push一个值的时候，也往最小栈中push一个当前栈中的最小值。这样获取最小值的时候，只用获取最小栈中的最顶端元素即可。 按照上面思路，只需要设计一个数据结构，是的每个元素val与其相应的最小值min时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。 1、当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中； 2、当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出； 3、在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。 12345678910111213141516171819202122232425262728class MinStack &#123; private Deque&lt;Integer&gt; stack; private Deque&lt;Integer&gt; minStack; public MinStack() &#123; stack = new LinkedList&lt;Integer&gt;(); minStack = new LinkedList&lt;Integer&gt;(); minStack.push(Integer.MAX_VALUE); &#125; public void push(int val) &#123; stack.push(val); minStack.push(Math.min(minStack.peek(), val)); &#125; public void pop() &#123; stack.pop(); minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125; *五二、逆波兰表达式 思路：可以利用栈，碰到数字便放入栈，当碰到运算符时，依次取出栈顶的两个数进行运算，然后再入栈。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int evalRPN(String[] tokens) &#123; Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;(); int n = tokens.length; for (int i = 0; i &lt; n; i++) &#123; String token = tokens[i]; if (isNumber(token)) &#123; stack.push(Integer.parseInt(token)); &#125; else &#123; int num2 = stack.pop(); int num1 = stack.pop(); switch (token) &#123; case &quot;+&quot;: stack.push(num1 + num2); break; case &quot;-&quot;: stack.push(num1 - num2); break; case &quot;*&quot;: stack.push(num1 * num2); break; case &quot;/&quot;: stack.push(num1 / num2); break; default: &#125; &#125; &#125; return stack.pop(); &#125; public boolean isNumber(String token) &#123; return !(&quot;+&quot;.equals(token) || &quot;-&quot;.equals(token) || &quot;*&quot;.equals(token) || &quot;/&quot;.equals(token)); &#125;&#125; 也可以倒着遍历数组，若碰到运算符，则将索引递减后，重新调用当前方法，若碰到数字，则返回当前数字，然后索引递减。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; int index; public int evalRPN(String[] tokens) &#123; index = tokens.length - 1; return getNext(tokens); &#125; //从后往前的递归 private int getNext(String[] tokens)&#123; int tmp; switch (tokens[index]) &#123; case &quot;+&quot; -&gt; &#123; index--; return getNext(tokens) + getNext(tokens); &#125; case &quot;-&quot; -&gt; &#123; index--; tmp = getNext(tokens); return getNext(tokens) - tmp; &#125; case &quot;*&quot; -&gt; &#123; index--; tmp = getNext(tokens); return getNext(tokens) * tmp; &#125; case &quot;/&quot; -&gt; &#123; index--; tmp = getNext(tokens); return getNext(tokens) / tmp; &#125; default -&gt; &#123; return Integer.parseInt(tokens[index--]); &#125; &#125; &#125;&#125; **五三、基本计算器 思路： 1、维护一个存放正负符号的栈。最开始的时候，我们需要给一个默认符号，这个默认符号给正，并将其放入栈中。 2、当碰到运算符 + 时，我们从栈中直接取出最顶端的数作为符号即可。 3、当碰到运算符 - 时，我们从栈中取出最顶端的数，并且将这个数正负反转，然后再作为符号。 4、当碰到 ( 时，我们需要将当前正在使用的符号放入栈中，因为括号中是一个整体，括号里面运算时，也需要从栈最顶端取出符号，所以我们需要在碰到 ( 时，将当前正在使用的符号放入栈中，以方便括号内运算时使用。 5、当碰到 ) 时，说明括号已经运算完成，此时需要将栈顶元素弹出，以免这个括号运算的符号影响到后面的运算。 12345678910111213141516171819202122232425262728293031323334public int calculate(String s) &#123; int n = s.length(); Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); stack.push(1); int sign = 1; int i = 0; int res = 0; while(i &lt; n) &#123; char c = s.charAt(i); if(c == &#x27; &#x27;) &#123; i ++; &#125; else if(c == &#x27;+&#x27;) &#123; sign = stack.peek(); i ++; &#125; else if(c == &#x27;-&#x27;) &#123; sign = -stack.peek(); i ++; &#125; else if (c == &#x27;(&#x27;) &#123; stack.push(sign); i++; &#125; else if (c == &#x27;)&#x27;) &#123; stack.pop(); i++; &#125; else &#123; int num = 0; while(i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123; num = num * 10 + s.charAt(i) - &#x27;0&#x27;; i ++; &#125; res += sign * num; &#125; &#125; return res;&#125; *五四、两数相加 思路：对于两个单位数的和，它们相加之后的余数，可以作为当前位的数，它们相加之后的除数，可以作为进位数。 12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(-1); ListNode pre = head; int t = 0; while(l1 != null || l2 != null || t != 0) &#123; if(l1 != null) &#123; t += l1.val; l1 = l1.next; &#125; if(l2 != null) &#123; t += l2.val; l2 = l2.next; &#125; pre.next = new ListNode(t%10); pre = pre.next; t /= 10; &#125; return head.next;&#125; 五五、合并两个有序链表 12345678910111213141516public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; ListNode head = new ListNode(-1); ListNode pre = head; while(list1 != null &amp;&amp; list2 != null) &#123; if(list1.val &lt; list2.val) &#123; pre.next = list1; list1 = list1.next; &#125; else &#123; pre.next = list2; list2 = list2.next; &#125; pre = pre.next; &#125; pre.next = list1 == null ? list2 : list1; return head.next;&#125; *五六、反转链表2 思路：可以一个一个逐步反转 使用三个指针 pre，cur，temp 来记录反转的过程中需要的变量，它们的意义如下： pre：永远指向待反转区域的第一个节点的前一个节点。 cur：永远指向待反转区域的第一个节点 temp：永远指向 cur 的后一个节点，循环过程中，cur.next 会一直变化。 操作步骤： 将 temp 节点拿出来，放在 pre 和 cur 的中间。 先将 cur 的下一个节点记录为 temp ； 把 cur 的下一个节点指向 temp 的下一个节点； 把 temp 的下一个节点指向 pre 的下一个节点； 把 pre 的下一个节点指向 temp。 1234567891011121314151617public ListNode reverseBetween(ListNode head, int left, int right) &#123; ListNode res = new ListNode(-1); res.next = head; ListNode pre = res; for(int i = 0; i &lt; left - 1; i ++) &#123; pre = pre.next; &#125; ListNode cur = pre.next; ListNode temp; for(int i = 0; i &lt; right - left; i ++) &#123; temp = cur.next; cur.next = temp.next; // cur的下一个节点变成temp的下一个节点 temp.next = pre.next; // temp肯定是要变成紧跟在pre之后的，pre原来的下一个节点要变成temp的下一个节点 pre.next = temp; // temp节点肯定是要变成紧跟在pre之后的 &#125; return res.next;&#125; **五七、k个一组反转链表 思路：可以直接在链表上，对 k 个节点进行反转。也可以将 k 个节点单独拿出来成为一个链表，反转后再拼接回去。 方法一：直接在链表上对 k 个节点进行反转 1234567891011121314151617181920212223public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode hair = new ListNode(0, head); ListNode pre = hair; while(head != null) &#123; // 查看剩余节点是否有k个 ListNode tail = pre; for(int i = 0; i &lt; k; i ++) &#123; tail = tail.next; if(tail == null) &#123; return hair.next; &#125; &#125; for(int i = 0; i &lt; k - 1; i ++) &#123; ListNode temp = head.next; head.next = temp.next; temp.next = pre.next; pre.next = temp; &#125; pre = head; head = head.next; &#125; return hair.next;&#125; 方法二：将 k 个节点单独拿出来成为一个链表，反转后再拼接回去 1234567891011121314151617181920212223242526272829303132class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode dummy = new ListNode(0, head); ListNode pre = dummy, end = dummy; while(end.next != null) &#123; for(int i = 0; i &lt; k; i++) &#123; end = end.next; if(end == null) &#123; return dummy.next; &#125; &#125; ListNode start = pre.next; ListNode next = end.next; end.next = null; // 找到 k 个节点的链表之后，截断 pre.next = reverse(start); // 反转之后，将当前的头节点和pre连接 start.next = next; // 反转之后，将最后的节点和next进行连接 pre = start; // 更新pre为反转之后链表的最后一个节点 end = pre; // 更新end为pre，此时start，end，pre在同一个节点上 &#125; return dummy.next; &#125; public ListNode reverse(ListNode node) &#123; ListNode pre = null, p = node; while(p != null) &#123; ListNode t = p.next; p.next = pre; // 将p的下一个变成pre，进行反转 pre = p; // 把当前的p变成pre p = t; // 把之前p的下一个变成p &#125; return pre; // pre指向的是原链表的最后一个节点，也就是反转之后的头节点 &#125;&#125; *五八、删除链表的倒数第n个节点 思路：计算出总长度 L ，需要删除的节点就是第 L - n + 1 个。也可以将链表中的节点放在栈中，弹出的第 n 个节点就是需要删除的节点。 方法一：删除第 L - n + 1 个节点 123456789101112131415161718192021class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode hair = new ListNode(0, head); int length = getLength(head); ListNode cur = hair; for(int i = 1; i &lt; length - n + 1; i ++) &#123; cur = cur.next; // 遍历完成之后，cur就是待删除节点的前一个节点 &#125; cur.next = cur.next.next; return hair.next; &#125; public int getLength(ListNode head) &#123; int length = 0; while(head != null) &#123; head = head.next; length ++; &#125; return length; &#125;&#125; 方法二：使用栈，弹出第 n 个节点 12345678910111213141516public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode hair = new ListNode(0, head); ListNode cur = hair; Deque&lt;ListNode&gt; stack = new LinkedList&lt;&gt;(); // 也需要将自定义的前结点放进去，避免链表只有一个节点所导致的stack.peek()取出的前节点为null的情况 while(cur != null) &#123; stack.push(cur); cur = cur.next; &#125; for(int i = 0; i &lt; n; i ++) &#123; stack.pop(); &#125; ListNode pre = stack.peek(); // 此时需要删除的节点已经弹出，再取出的节点就是删除节点的前结点 pre.next = pre.next.next; return hair.next;&#125; *五九、删除排序链表中的重复项2 思路：存在一个节点cur，当cur.next和cur.next.next相等的时候，可以将cur.next删除，即循环让cur.next &#x3D; cur.next.next，依次判断当前cur.next的值是否和之前cur.next的值相等，然后此时再重复上述操作再次将cur.next删除即可。 若cur.next.val == cur.next.next.val，获取当前cur.next.val为val。由于后面会将cur.next.next赋值给cur.next（这一步是删除当前cur.next）。所以我们每一步都去判断cur.next.val是否和val相等，依次来达到删除一个之后，其后面的数据是否又和当前要删除的相等。 1234567891011121314151617public ListNode deleteDuplicates(ListNode head) &#123; ListNode hair = new ListNode(0, head); ListNode cur = hair; while(cur.next != null &amp;&amp; cur.next.next != null) &#123; if(cur.next.val == cur.next.next.val) &#123; int val = cur.next.val; // 此时已经存在两个节点相同，所以要从第一个相同的节点开始删除，并将后面的节点替补过来 // 所以我们只需要判断cur.next的val是否一直和val相等即可 while(cur.next != null &amp;&amp; cur.next.val == val) &#123; cur.next = cur.next.next; // 后面节点依次往前替补 &#125; &#125; else &#123; cur = cur.next; &#125; &#125; return hair.next;&#125; *六十、旋转链表 思路：可以先将整个链表变成环，然后在找到对应的节点位置，从后断开即可。 1234567891011121314151617181920212223public ListNode rotateRight(ListNode head, int k) &#123; if (k == 0 || head == null || head.next == null) &#123; return head; &#125; ListNode lengthNode = head; int length = 1; while(lengthNode.next != null) &#123; length ++; lengthNode = lengthNode.next; &#125; // eg：旋转1次，此时lengthNode在原链表最后节点处，此时lengthNode需要走到length-k%length截断 int add = length - k % length; if(add == length) &#123; return head; &#125; lengthNode.next = head; while(add -- &gt; 0) &#123; lengthNode = lengthNode.next; &#125; ListNode res = lengthNode.next; lengthNode.next = null; return res;&#125; *六一、分割链表 思路：准备两个链表，一个存放比x小的，另一个存放剩下的。然后再把两个链表拼接起来即可。 12345678910111213141516171819public ListNode partition(ListNode head, int x) &#123; ListNode small = new ListNode(0); ListNode smallHead = small; ListNode large = new ListNode(0); ListNode largeHead = large; while(head != null) &#123; if(head.val &lt; x) &#123; small.next = head; small = small.next; &#125; else &#123; large.next = head; large = large.next; &#125; head = head.next; &#125; large.next = null; small.next = largeHead.next; return smallHead.next;&#125; *六二、LRU缓存 思路：将节点更新到链表头部可以先将节点删除，然后将节点插入到头部。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class LRUCache &#123; class DLinkedNode &#123; int key; int value; DLinkedNode prev; DLinkedNode next; public DLinkedNode() &#123;&#125; public DLinkedNode(int _key, int _value) &#123;key = _key; value = _value;&#125; &#125; private Map&lt;Integer, DLinkedNode&gt; cache = new HashMap&lt;&gt;(); private int size; private int capacity; private DLinkedNode head, tail; public LRUCache(int capacity) &#123; this.size = 0; this.capacity = capacity; head = new DLinkedNode(); tail = new DLinkedNode(); head.next = tail; tail.prev = head; &#125; public int get(int key) &#123; DLinkedNode node = cache.get(key); if(node == null) &#123; return -1; &#125; moveToHead(node); return node.value; &#125; public void put(int key, int value) &#123; DLinkedNode node = cache.get(key); if(node == null) &#123; DLinkedNode newNode = new DLinkedNode(key, value); // 加入到map cache.put(key, newNode); // 添加到双向链表的头部 addToHead(newNode); size ++; if(size &gt; capacity) &#123; // 超出容量，删除链表的尾部 DLinkedNode tail = removeTail(); // map中删除 cache.remove(tail.key); size --; &#125; &#125; else &#123; // 更改值，并移动到头部 node.value = value; moveToHead(node); &#125; &#125; public void addToHead(DLinkedNode node) &#123; node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; &#125; public void removeNode(DLinkedNode node) &#123; node.prev.next = node.next; node.next.prev = node.prev; &#125; public void moveToHead(DLinkedNode node) &#123; removeNode(node); addToHead(node); &#125; public DLinkedNode removeTail() &#123; DLinkedNode value = tail.prev; removeNode(value); return value; &#125;&#125; 六三、二叉树的最大深度 思路：深度遍历和广度遍历 12345678public int maxDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; // 当前层的层高是其下左节点和右节点层高的最大值然后加上当前层的1&#125; 12345678910111213141516171819202122public int maxDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int res = 0; while(!queue.isEmpty()) &#123; int size = queue.size(); // 当前层的节点数 while(size-- &gt; 0) &#123; TreeNode node = queue.poll(); // 当前层的左节点和右节点放入queue if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; res ++; // 每层遍历完，层高 ++ &#125; return res;&#125; 六四、相同的树 思路：深度遍历和广度遍历 方法一：深度遍历 1234567891011public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null) &#123; return true; &#125; else if(p == null || q == null) &#123; return false; &#125; else if(p.val != q.val) &#123; return false; &#125; else &#123; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125;&#125; 方法二：广度遍历 1234567891011121314151617181920212223242526272829303132333435363738public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null) &#123; return true; &#125; else if(p == null || q == null) &#123; return false; &#125; Queue&lt;TreeNode&gt; queue1 = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; queue2 = new LinkedList&lt;&gt;(); queue1.offer(p); queue2.offer(q); while(!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123; TreeNode one = queue1.poll(); TreeNode two = queue2.poll(); if(one.val != two.val) &#123; return false; &#125; TreeNode l1 = one.left, r1 = one.right, l2 = two.left, r2 = two.right; if(l1 == null ^ l2 == null) &#123; // 相同为0，相反为1。为1时，进if。此时l1和l2的状态不同，即返回false return false; &#125; if(r1 == null ^ r2 == null) &#123; return false; &#125; if(l1 != null) &#123; queue1.offer(l1); &#125; if(r1 != null) &#123; queue1.offer(r1); &#125; if(l2 != null) &#123; queue2.offer(l2); &#125; if(r2 != null) &#123; queue2.offer(r2); &#125; &#125; return queue1.isEmpty() &amp;&amp; queue2.isEmpty();&#125; 六五、反转二叉树 123456789public TreeNode invertTree(TreeNode root) &#123; if(root != null) &#123; TreeNode left = root.left; root.left = invertTree(root.right); root.right = invertTree(left); return root; &#125; return null;&#125; 六六、对称二叉树 思路：可以看成是比较两个二叉树是否对称 1234567891011121314151617class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return check(root, root); &#125; public boolean check(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null) &#123; return true; &#125; else if(p == null || q == null) &#123; return false; &#125; else if(p.val != q.val) &#123; return false; &#125; else &#123; return check(p.left, q.right) &amp;&amp; check(p.right, q.left); &#125; &#125;&#125; 123456789101112131415161718192021222324252627class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return check(root, root); &#125; public boolean check(TreeNode p, TreeNode q) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(p); queue.offer(q); while(!queue.isEmpty()) &#123; p = queue.poll(); q = queue.poll(); if(p == null &amp;&amp; q == null) &#123; continue; &#125; else if(p == null || q == null) &#123; return false; &#125; else if(p.val != q.val) &#123; return false; &#125; queue.offer(p.left); queue.offer(q.right); queue.offer(p.right); queue.offer(q.left); &#125; return true; &#125;&#125; *六七、从前序与中序遍历序列构造二叉树 思路：根据前序可以知道根节点，然后可以根据中序确定当前根节点左子树和右子树的数量 方法一： 1、遍历中序，将中序的节点信息和对应的下标信息存放在map中； 2、根据前序判断出根节点，然后根据map判断出根节点在中序中的位置，然后根据中序判断出左子树和右子树的节点数目； 3、确定好根节点之后： ​ 左子树在preorder中的范围为[pleft+1, pleft+left_size]，右子树在preorder中的范围为[pleft+1+left_size, pright]。pleft+left_size实际上是pleft+1+left_size-1，表示从pleft+1处开始算起，总共有left_size个数。比如从1开始，有5个数，实际上是1、2、3、4、5。所以算术为1+5-1。 ​ 左子树在inorder中的范围为[ileft, iroot-1]，右子树在inorder中的范围为[iroot+1, iright]。 12345678910111213141516171819202122232425262728class Solution &#123; private Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;&gt;(); private int root_index = 0; public TreeNode build(int[] preorder, int[] inorder, Integer iLeft,Integer iRight) &#123; if(iLeft &gt; iRight) &#123; return null; &#125; // 前序的第一个节点就是根节点 int rootNum = preorder[root_index ++]; // 确定中序根节点的位置 int index = indexMap.get(rootNum); // 得到左子树的节点个数 TreeNode root = new TreeNode(rootNum); root.left = build(preorder, inorder, iLeft, index - 1); root.right = build(preorder, inorder, index + 1, iRight); return root; &#125; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; int n = preorder.length; // 将中序中的节点信息保存在map中，使能快速定位根节点位置 for(int i = 0; i &lt; n; i ++) &#123; indexMap.put(inorder[i], i); &#125; return build(preorder, inorder, 0, n - 1); &#125;&#125; 方法二： 12345678910111213141516171819202122232425262728class Solution &#123; private Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;&gt;(); private int root_index = 0; public TreeNode build(int[] preorder, int[] inorder, Integer iLeft,Integer iRight) &#123; if(iLeft &gt; iRight) &#123; return null; &#125; // 前序的第一个节点就是根节点 int rootNum = preorder[root_index ++]; // 确定中序根节点的位置 int index = indexMap.get(rootNum); // 得到左子树的节点个数 TreeNode root = new TreeNode(rootNum); root.left = build(preorder, inorder, iLeft, index - 1); root.right = build(preorder, inorder, index + 1, iRight); return root; &#125; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; int n = preorder.length; // 将中序中的节点信息保存在map中，使能快速定位根节点位置 for(int i = 0; i &lt; n; i ++) &#123; indexMap.put(inorder[i], i); &#125; return build(preorder, inorder, 0, n - 1); &#125;&#125; *六八、从中序与后序遍历序列构造二叉树 思路：后序遍历，最后的节点即是根节点。 1234567891011121314151617181920212223242526class Solution &#123; private HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); private Integer post_index; public TreeNode build(int[] inorder, int[] postorder, int iLeft, int iRight) &#123; if(iLeft &gt; iRight) &#123; return null; &#125; // 后序遍历的最后一个节点是根节点 int rootNum = postorder[post_index --]; TreeNode root = new TreeNode(rootNum); int index = map.get(rootNum); root.right = build(inorder, postorder, index + 1, iRight); root.left = build(inorder, postorder, iLeft, index - 1); return root; &#125; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; post_index = postorder.length - 1; for(int i = post_index; i &gt;= 0; i --) &#123; map.put(inorder[i], i); &#125; return build(inorder, postorder, 0, post_index); &#125;&#125; *六九、填充每个节点的下一个右侧节点指针2 思路：可以使用一个队列，存储每一层的节点，然后进行指向处理。也可以将每一层当作一个链表，进行指向处理。 方法一：使用队列 1234567891011121314151617181920212223242526public Node connect(Node root) &#123; if(root == null) &#123; return root; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) &#123; Node pre = null; int levels = queue.size(); while(levels -- &gt; 0) &#123; Node node = queue.poll(); node.next = null; if(pre != null) &#123; pre.next = node; &#125; pre = node; if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; &#125; return root;&#125; 方法二：每一层都作为链表 遍历某一层时，将其下一层的节点进行指向处理。 123456789101112131415161718192021222324252627public Node connect(Node root) &#123; if(root == null) &#123; return root; &#125; // cur可以看成每一层的链表 Node cur = root; while(cur != null) &#123; // 下一层没有节点时，cur = dummy.next会为null // 遍历当前层时，将下一层添加一个哑节点，这样遍历下一层时，可以直接cur = dummy.next即可。 Node dummy = new Node(0); Node pre = dummy; // 遍历当前层 while(cur != null) &#123; if(cur.left != null) &#123; pre.next = cur.left; pre = pre.next; &#125; if(cur.right != null) &#123; pre.next = cur.right; pre = pre.next; &#125; cur = cur.next; // 遍历上一层的时候，这一层就已经有指向关系了，所以要判断不同节点的下一层，可以用cur.next &#125; // 换到下一层 cur = dummy.next; &#125; return root;&#125; *七十、二叉树展开为链表 思路：前序遍历时，最上层根节点的右子树一定会在左子树最后一个右节点的后面。 方法一：从头开始遍历，直接移位拼接 1、当前根节点root为cur，其左子树节点为next。 2、存在一个pre节点，使其从当前cur节点的左子树开始，一直找到最底层最右侧的节点。 3、然后将当前cur节点的右子树移到pre节点的后面（右侧），即pre.right = cur.right。 4、将当前cur节点的左子树移到cur右子树的位置。 5、更新cur的节点为其右侧第一个节点（原左侧第一个节点）cur = cur.right。 12345678910111213141516public void flatten(TreeNode root) &#123; TreeNode cur = root; while(cur != null) &#123; if(cur.left != null) &#123; TreeNode next = cur.left; TreeNode pre = next; while(pre.right != null) &#123; pre = pre.right; &#125; pre.right = cur.right; cur.left = null; cur.right = next; &#125; cur = cur.right; &#125;&#125; 方法二：使用栈 1、当获取到一个节点时，首先将此节点放到前一个节点的右侧，并将上一个节点的左侧置为null。 2、将当前节点的右侧节点先放入栈中，然后再将其左侧节点放入栈中。这样优先弹出的就是左侧节点，满足前序遍历条件。 3、将当前弹出的节点作为前一个节点pre，然后循环如此，直到栈为空。 123456789101112131415161718192021222324public void flatten(TreeNode root) &#123; if(root == null) &#123; return; &#125; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); stack.push(root); TreeNode pre = null; while(!stack.isEmpty()) &#123; TreeNode node = stack.pop(); if(pre != null) &#123; pre.left = null; pre.right = node; &#125; // right先入栈，left后入栈。这样弹出时，首先弹出left，并且进行拼接。 TreeNode left = node.left, right = node.right; if(right != null) &#123; stack.push(right); &#125; if(left != null) &#123; stack.push(left); &#125; pre = node; &#125;&#125; 七一、路径总和 方法一：广度优先搜索 实际始将每个叶子节点存在的路径和都算出来，然后进行比对。 1、使用两个队列，queNode用来保存节点、queVal用来保存节点值。 2、从队列queNode和queVal中弹出一个节点，然后将当前节点的左右节点依次放入队列queNode中，然后将此节点左右节点值和此节点值的和放入队列queVal中。这样我们遍历其左右子节点left和right的时候，就可以直接从queVal中拿到此时left和right的路径和是多少，从而去判断是否满足条件。 3、循环如此，直到队列中弹出的节点没有了左右节点，这个时候就判断当前节点所对应的值是否符合条件，不符合则继续弹出。 12345678910111213141516171819202122232425262728public boolean hasPathSum(TreeNode root, int targetSum) &#123; if(root == null) &#123; return false; &#125; Queue&lt;TreeNode&gt; queNode = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; queVal = new LinkedList&lt;&gt;(); queNode.offer(root); queVal.offer(root.val); while(!queNode.isEmpty()) &#123; TreeNode node = queNode.poll(); Integer val = queVal.poll(); if(node.left == null &amp;&amp; node.right == null) &#123; if(val == targetSum) &#123; return true; &#125; continue; &#125; if(node.left != null) &#123; queNode.offer(node.left); queVal.offer(node.left.val + val); &#125; if(node.right != null) &#123; queNode.offer(node.right); queVal.offer(node.right.val + val); &#125; &#125; return false;&#125; 方法二：递归 每递归一个节点的时候，就将sum - val的值传递给下一次递归，如果其子节点都为空的时候，就可以直接判断当前节点的值val和sum是否相等，判断左右子树有一方成立即可。 123456789public boolean hasPathSum(TreeNode root, int targetSum) &#123; if(root == null) &#123; return false; &#125; if(root.left == null &amp;&amp; root.right == null) &#123; return targetSum == root.val; &#125; return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);&#125; *七二、求根节点到叶子节点数字之和 方法一：广度优先搜索 123456789101112131415161718192021222324252627public int sumNumbers(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; int res = 0; Queue&lt;TreeNode&gt; queNode = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; queVal = new LinkedList&lt;&gt;(); queNode.offer(root); queVal.offer(root.val); while(!queNode.isEmpty()) &#123; TreeNode node = queNode.poll(); Integer val = queVal.poll(); if(node.left == null &amp;&amp; node.right == null) &#123; res += val; continue; &#125; if(node.left != null) &#123; queNode.offer(node.left); queVal.offer(val * 10 + node.left.val); &#125; if(node.right != null) &#123; queNode.offer(node.right); queVal.offer(val * 10 + node.right.val); &#125; &#125; return res;&#125; 方法二：深度优先搜索 1234567891011121314151617class Solution &#123; public int sumNumbers(TreeNode root) &#123; return sumTree(root, 0); &#125; public int sumTree(TreeNode node, int res) &#123; if(node == null) &#123; return 0; &#125; res = res * 10 + node.val; if(node.left == null &amp;&amp; node.right == null) &#123; return res; &#125; else &#123; return sumTree(node.left, res) + sumTree(node.right, res); &#125; &#125;&#125; **七三、二叉树中的最大路径和 思路：就是计算每一层的最大路径，然后再取最大值。若左侧为负数，则抛弃左边。右侧为负数，则抛弃右边。根节点为负数，则比较左边和右边的大小。然而，计算每一层的最大路径，需要知道左右节点的最大贡献值，最大贡献值只能是左右节点数的一半的最大路径，比如20+15和20+7比较大小，取最大值。因为计算路劲和不能重复经过某个节点。 若树只有一层，那么最大路径就可以看成是左-&gt;根-&gt;右之和（若有一个不大于0，则可以不用计算）。 比如15-&gt;20-&gt;7。 若树有多层，除开最上层的树，那么我们就只能用到每一层树的一半路径大小，而不能去使用每层树的全路径。 比如10-&gt;20-&gt;15或10-&gt;20-&gt;7，而不是10-&gt;20-&gt;15-&gt;20-&gt;7。 如此，便可以知道，需要计算每层树的根节点的最大贡献值，即一半树的最大路径大小（若这个数为负数，则可以不计算这个根节点产生的贡献值，将此根节点排除在外，即当 0 处理）。也就是说： 每一层树的每一个节点的最大贡献值为root.val + Math.max(leftGain, rightGain)； 每一层树的最大路径和为root.val + leftGain + rightGain。 可能多层树的最大路径和还没有某一层的路径和大，所以需要每计算出一层最大路径和之后，和先前计算的路径和比较，取最大值。 12345678910111213141516171819202122232425class Solution &#123; int maxSum = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; maxGain(root); return maxSum; &#125; public int maxGain(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; // 递归计算左右子树的最大贡献值 int leftGain = Math.max(maxGain(root.left), 0); int rightGain = Math.max(maxGain(root.right), 0); // 当前节点的最大路径和 int curMaxSum = root.val + leftGain + rightGain; maxSum = Math.max(maxSum, curMaxSum); // 返回当前节点的最大贡献值 return root.val + Math.max(leftGain, rightGain); &#125;&#125; *七四、二叉搜索树迭代器 思路：可使用递归或迭代的方式中序遍历二叉树，从而 next( ) 中去输出值 方法一：递归、使用list按照中序遍历的先后顺序存储二叉树的节点值 123456789101112131415161718192021222324252627class BSTIterator &#123; private int idx; private List&lt;Integer&gt; arr; public BSTIterator(TreeNode root) &#123; idx = 0; arr = new ArrayList&lt;Integer&gt;(); inorderTraversal(root, arr); &#125; public int next() &#123; return arr.get(idx ++); &#125; public boolean hasNext() &#123; return idx &lt; arr.size(); &#125; public void inorderTraversal(TreeNode root, List&lt;Integer&gt; arr) &#123; if(root == null) &#123; return; &#125; inorderTraversal(root.left, arr); arr.add(root.val); inorderTraversal(root.right, arr); &#125;&#125; 方法二：迭代、使用栈维护二叉树的中序遍历节点即可 123456789101112131415161718192021222324class BSTIterator &#123; private TreeNode cur; private Deque&lt;TreeNode&gt; stack; public BSTIterator(TreeNode root) &#123; cur = root; stack = new LinkedList&lt;TreeNode&gt;(); &#125; public int next() &#123; while(cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); // 按照 (左-&gt;中-&gt;右) 弹出，然后返回。 int res = cur.val; cur = cur.right; return res; &#125; public boolean hasNext() &#123; return !(cur == null &amp;&amp; stack.isEmpty()); &#125;&#125; *七五、二叉树的最近公共祖先 方法一：递归 判断每个节点的左子树和右子树是否存在p或者q，或者当前节点和p或者q相等。若满足其中任意一项则返回true，表示从p或者q开始往上走，会经历当前节点。其判断条件为 left || right || (root.val == p.val || root.val == q.val)。 从p和q往上走的树路径中，刚开始相交的那个节点，即为最近公共祖先。可以看作是，从一个节点开始，p和q分别在其左子树或右子树当中，或者这个节点和p或q重合且p或q在其任意一条子树上。 比如：有个节点node，p在其左子树上，q在其右子树上，此时node就是p和q的最近公共祖先。又或者有个节点node，它和p重叠，q在其左子树或右子树上，此时node也是p和q的最近公共祖先。 判断条件为 (left &amp;&amp; right) || ((root.val == p.val || root.val == q.val) &amp;&amp; (left || right))。 1234567891011121314151617181920class Solution &#123; private TreeNode res = null; public boolean dfs(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null) &#123; return false; &#125; boolean left = dfs(root.left, p, q); boolean right = dfs(root.right, p, q); if((left &amp;&amp; right) || ((root.val == p.val || root.val == q.val) &amp;&amp; (left || right))) &#123; res = root; &#125; return left || right || (root.val == p.val || root.val == q.val); &#125; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; dfs(root, p, q); return res; &#125;&#125; 方法二：存储父节点 将二叉树的每个节点按照 (self，parent) 存储起来。然后从 p 节点开始，将值存放在Set集合中，并且将 p.parent 重新赋值给 p，循环将值放入Set集合中，直到 p 为空为止。p.parent 其实就是使用 map.get(p.val) 即可。然后，判断Set集合中是否包含了q.val，如果包含，则此时的 q 就是最近公共祖先。若不包含，则将 q.parent 重新赋值给 q，循环判断，直到 q 为空为止。若始终没有，则 p 和 q 没有最近公共祖先。 123456789101112131415161718192021222324252627282930class Solution &#123; Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;&gt;(); Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); public void dfs(TreeNode root) &#123; if(root.left != null) &#123; parent.put(root.left.val, root); dfs(root.left); &#125; if(root.right != null) &#123; parent.put(root.right.val, root); dfs(root.right); &#125; &#125; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; dfs(root); while(p != null) &#123; visited.add(p.val); p = parent.get(p.val); &#125; while(q != null) &#123; if(visited.contains(q.val)) &#123; return q; &#125; q = parent.get(q.val); &#125; return null; &#125;&#125; *七六、二叉树的右视图 思路：遍历到每一层时，每一层最右侧节点即为需要打印的节点 12345678910111213141516171819202122232425class Solution &#123; private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); private TreeNode node; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; if(root != null) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) &#123; int size = queue.size(); while(size -- &gt; 0) &#123; node = queue.poll(); // node最后肯定是这一层最右侧的节点 if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; res.add(node.val); &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}